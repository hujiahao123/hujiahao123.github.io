{"meta":{"title":"宁静致远","subtitle":"blog","description":"花开堪折直须折,莫待无花空折枝。","author":"宁静致远","url":"https://hujiahao.top","root":"/"},"pages":[{"title":"","date":"2020-04-29T11:57:59.725Z","updated":"2020-04-29T11:57:59.725Z","comments":true,"path":"nav.html","permalink":"https://hujiahao.top/nav.html","excerpt":"","text":"window.onload=function(){ window.location.href = 'https://www.baidu.com/'; }"},{"title":"","date":"2020-03-29T23:59:52.000Z","updated":"2020-03-29T23:59:52.000Z","comments":true,"path":"about/index.html","permalink":"https://hujiahao.top/about/index.html","excerpt":"","text":"关于 关于博主： 在校学生，软件工程专业，对web开发有着浓厚的兴趣。 现在主要学习java后端开发 性格内向,不喜交际 平时爱刷B站、论坛和博客，关注前沿技术。 喜欢打球，看电影，看书。 关于本站： 基于Hexo框架，部署在Github和Coding上。 本博客是作者在学习开发过程中积累的笔记，文章体裁不限。自 2020年4月开始一直持续更新。如果这些笔记对你的学习有帮助，欢迎通过以下方式支持一下，你的支持是我持续维护的动力👇👇 联系方式 Email: &#x38;&#54;&#50;&#57;&#x36;&#48;&#48;&#52;&#x30;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d; QQ:862960040"},{"title":"分类","date":"2020-04-23T01:25:09.000Z","updated":"2020-04-23T01:25:09.000Z","comments":true,"path":"categories/index.html","permalink":"https://hujiahao.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-15T15:11:33.479Z","updated":"2021-03-15T15:11:33.479Z","comments":true,"path":"friends/index.html","permalink":"https://hujiahao.top/friends/index.html","excerpt":"","text":""},{"title":"links","date":"2020-04-23T01:27:48.000Z","updated":"2020-04-23T01:27:48.000Z","comments":true,"path":"links/index.html","permalink":"https://hujiahao.top/links/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-06T02:47:14.532Z","updated":"2021-09-06T02:47:14.532Z","comments":true,"path":"love/index.html","permalink":"https://hujiahao.top/love/index.html","excerpt":"","text":"时光轴💕 这里记录着文儿与豪一起经历的故事🧑👧 // 把想要替换的元素id替换掉box // 封装方法 var over = function () { // 1.获取当前时间 let secondtime = new Date(); // 1.获取网站建立时的日期 let firsttime = new Date(\"2020/10/23\"); // 2.获取时间间隔的时间戳 let timespan = secondtime.getTime() - firsttime.getTime(); // 3.获取天 let day = Math.floor(timespan / (1000 * 60 * 60 * 24)); // 4.获取小时 let hour = Math.floor(timespan / (1000 * 60 * 60) % 24); // 5.获取分钟 let minute = Math.floor(timespan / (1000 * 60) % 60); // 6.获取秒 let second = Math.floor(timespan / 1000 % 60); return '第' +' '+ day +' '+ \"天\" + ' '+ hour + ' ' + \"时\"+' ' + minute + ' '+ \"分\" + ' '+ second +' '+ '秒'; } // 获取要修改的元素 let box = document.getElementById('box'); // 定时器循环调用 setInterval(() => { box.innerHTML = over(); }, 1000); 2021 2021-08-19 300 天 快 乐 ！ 2021-07-06 第一次带文儿参观了我的校园。 2021-05-28 第一次给文儿过生日，第一次和文儿一起吃烛光晚餐。 2021-05-11 200 天 快 乐 ！ 2021-05-09 我们一起去看了《扫黑-决战》 2021-05-04 我们一起去了管城区，去逛了锦荣商贸城，吃了超好吃的饸烙面，还去逛了一家小商品店。 2021-04-27 和文儿一起在龙子湖看月亮。 2021-04-22 第一次去了文儿的学校里面，看了天一湖、大长楼、药植园，还去餐厅吃了饭。 2021-04-18 我们一起去了郑州动物园。 2021-04-03 ~ 2021-04-05 洛阳三日游，我们一起去了龙门石窟(雨中浪漫观景，石窟很壮观，刻的也很精细，就是好多都不完整了，很可惜)、洛阳博物馆(碰到一个超级可爱的小朋友)、中国国花园(人太多，没进去)、应天门(夜景很壮观)、丽景门小吃街(街是真的长，小吃超级多)，洛邑古城。最后还要吐槽一下洛阳的交通，还有那电动车… 印象深刻啊。 ~自行车真香。 2021-03-20 我们一起去了二七广场，逛了德化街、小吃街，看了二七塔,中午吃了旋转自助小火锅,下午去电影院看了《你好，李焕英》,还去了人民公园,晚上一起吃的新疆炒米粉(爆赞),吃饭时候还一起看了《发财日记》。 2021-02-27 我们一起去看了《人潮汹涌》。 2021-02-26 我们一起共度元宵夜。 2021-02-10 20:05 最有默契的一次。 2021-01-31 100 天 快 乐 ！ 2020 2020-12-31 和你第一次跨年，我们去看了《温暖的抱抱》,还去了郑州最文艺的商城-永威木色购物公园,然后在会展中心看了美丽的夜景,并在玉米楼前合影。 2020-12-12 我们一起去看了《如果声音不记得》,然后我们第一次亲吻啦😘 2020-11-21 我们一起去看了《风平浪静》,还第一次牵你的小手 2020-10-31 我们一起去看了《一点就到家》 2020-10-24 我们在一起啦❤️ Waiting for you … 在等你呢 …"},{"title":"","date":"2021-03-16T05:11:14.646Z","updated":"2021-03-16T05:11:14.646Z","comments":true,"path":"message/index.html","permalink":"https://hujiahao.top/message/index.html","excerpt":"","text":""},{"title":"","date":"2021-02-05T05:41:03.794Z","updated":"2021-02-05T05:41:03.794Z","comments":true,"path":"love1/index.html","permalink":"https://hujiahao.top/love1/index.html","excerpt":"","text":"Love 时光轴💕 2021年 1月31日2021 100 天 快 乐 ！ 2020年 12月31日2020 和你第一次跨年，我们去看了《温暖的抱抱》，还去了郑州最文艺的商城——永威木色购物公园，然后在会展中心看了美丽的夜景，并在玉米楼前合影。 12月12日2020 我们一起去看了《如果声音不记得》,然后我们第一次亲吻啦😘 11月21日2020 我们一起去看了《风平浪静》,还第一次牵你的小手 10月31日2020 我们一起去看了《一点就到家》 10月24日2020 我们在一起啦❤️ Waitingfor you ... 在等你呢... 一起做💕 一起要做的100件事。"},{"title":"Love💕相爱","date":"2021-03-14T06:06:21.262Z","updated":"2021-03-14T06:06:21.262Z","comments":true,"path":"love/index1.html","permalink":"https://hujiahao.top/love/index1.html","excerpt":"","text":"时光轴😘 //这是要遍历时间轴的数据 var dimeAxis=[ { date:'2 0 2 1 年', title:'"},{"title":"搜索","date":"2021-01-14T07:01:20.801Z","updated":"2021-01-14T07:01:20.801Z","comments":true,"path":"search/index.html","permalink":"https://hujiahao.top/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-31T08:33:07.000Z","updated":"2020-03-31T08:33:07.000Z","comments":true,"path":"tags/index.html","permalink":"https://hujiahao.top/tags/index.html","excerpt":"","text":""},{"title":"Love💕Todos","date":"2021-03-01T13:06:06.083Z","updated":"2021-03-01T13:06:06.083Z","comments":true,"path":"todo/index.html","permalink":"https://hujiahao.top/todo/index.html","excerpt":"","text":"这里记录着文儿与豪将会一起完成的事🧑👧💕 //这是要遍历时间轴的数据 var lovetodos=[ { todo:'', achieve:'1.一起去电影院看一场电影', checked:'checked' }, { todo:'', achieve:'2.一起牵手逛街', checked:'checked' }, { todo:'3.一起去一趟迪士尼游乐园', achieve:'', checked:'' }, { todo:'4.一起去游泳', achieve:'' }, { todo:'5.一起唱歌并且录下来', achieve:'' }, { todo:'6.一起在厨房做次饭', achieve:'' }, {todo:'7.一起过次烛光晚餐🍷',achieve:'',checked:''}, {todo:'8.一起过生日',achieve:'',checked:''}, {todo:'9.一起打扫卫生',achieve:'',checked:''}, {todo:'10.一起去一次鬼屋',achieve:'',checked:''}, {todo:'11.一起去蹦极',achieve:'',checked:''}, {todo:'12.一起养一只宠物',achieve:'',checked:''}, {todo:'13.一起研究口红色号',achieve:'',checked:''}, {todo:'14.一起抓娃娃',achieve:'',checked:''}, {todo:'',achieve:'15.一起换情侣头像',checked:'checked'}, {todo:'16.一起去做次陶艺',achieve:'',checked:''}, {todo:'‍',achieve:'17.一起锻炼身体🤸',checked:'checked'}, {todo:'18.一起去吃一次全家桶',achieve:'',checked:''}, {todo:'19.一起去旅游⛰',achieve:'',checked:''}, {todo:'20.一起换手机壁纸',achieve:'',checked:''}, {todo:'21.一起坐一次摩天轮',achieve:'',checked:''}, {todo:'22.一起拍视频记录生活',achieve:'',checked:''}, {todo:'23.一起刷牙，然后亲亲',achieve:'',checked:''}, {todo:'24.一起去看一次海，去沙滩👙',achieve:'',checked:''}, {todo:'25.一起去爬山',achieve:'',checked:''}, {todo:'26.一起看日出',achieve:'',checked:''}, {todo:'27.互穿对方的衣服，拍照留念',achieve:'',checked:''}, {todo:'28.一起坐一次摩天轮',achieve:'',checked:''}, {todo:'29.一起逛超市买好吃的',achieve:'',checked:''}, {todo:'30.一起去书店看书，分享自己喜欢的书籍📕',achieve:'',checked:''}, {todo:'31.一起在下雨天追剧☔️',achieve:'',checked:''}, {todo:'32.一起做一次蛋糕甜点',achieve:'',checked:''}, {todo:'33.一起看日落',achieve:'',checked:''}, {todo:'34.一起上下班，坐地铁',achieve:'',checked:''}, {todo:'35.一起弹吉他',achieve:'',checked:''}, {todo:'36.一起去买菜',achieve:'',checked:''}, {todo:'37.一起玩游戏🎮',achieve:'',checked:''}, {todo:'38.一起坐一次飞机✈️',achieve:'',checked:''}, {todo:'39.一起种花草',achieve:'',checked:''}, {todo:'40.一起养宠物',achieve:'',checked:''}, {todo:'41.一起用情侣手机壳',achieve:'',checked:''}, {todo:'42.一起去一次海底世界',achieve:'',checked:''}, {todo:'43.一起喝醉一次',achieve:'',checked:''}, {todo:'44.一起打扑克牌♣️',achieve:'',checked:''}, {todo:'45.一起去天安门看升国旗',achieve:'',checked:''}, {todo:'46.一起修理电器',achieve:'',checked:''}, {todo:'47.一起看烟花',achieve:'',checked:''}, {todo:'',achieve:'48.一起吃火锅',checked:'checked'}, {todo:'49.一起庆祝恋爱纪念日',achieve:'',checked:''}, {todo:'50.一起去一次教堂⛪️',achieve:'',checked:''}, {todo:'51.一起看雪，堆雪人☃️',achieve:'',checked:''}, {todo:'52.一起换发型，剪头发',achieve:'',checked:''}, {todo:'53.一起和朋友们去吃饭',achieve:'',checked:''}, {todo:'',achieve:'54.一起听音乐，听同一首歌',checked:'checked'}, {todo:'55.一起坐一次船',achieve:'',checked:''}, {todo:'56.一起露营，住一次帐篷 ⛺',achieve:'',checked:''}, {todo:'57.一起DIY手工✂️',achieve:'',checked:''}, {todo:'',achieve:'58.给对方准备礼物',checked:'checked'}, {todo:'59.一起去我们上过的小学',achieve:'',checked:''}, {todo:'60.一起去我们上过的中学',achieve:'',checked:''}, {todo:'61.一起去我们上过的大学',achieve:'',checked:''}, {todo:'62.一起在沙发上躺着',achieve:'',checked:''}, {todo:'63.一起睡个懒觉，赖个床😴',achieve:'',checked:''}, {todo:'64.偷偷为对方买喜欢又舍不得的东西',achieve:'',checked:''}, {todo:'65.互换角色一天',achieve:'',checked:''}, {todo:'66.一起坐一次巴士，在没去过的地方下车',achieve:'',checked:''}, {todo:'67.一起规划未来',achieve:'',checked:''}, {todo:'68.给对方准备一次浪漫的求婚✨',achieve:'',checked:''}, {todo:'69.一起在午夜看一次恐怖片',achieve:'',checked:''}, {todo:'70.一起安静的听雨声',achieve:'',checked:''}, {todo:'71.一起看一场演唱会',achieve:'',checked:''}, {todo:'72.一起去挑选一束花',achieve:'',checked:''}, {todo:'73.一起去跳一次广场舞',achieve:'',checked:''}, {todo:'74.一起去见证一次别人的婚礼',achieve:'',checked:''}, {todo:'75.一起为对方按摩一次',achieve:'',checked:''}, {todo:'76.一起放一次风筝',achieve:'',checked:''}, {todo:'77.一起吐槽一次对方的缺点',achieve:'',checked:''}, {todo:'78.一起打扮自己',achieve:'',checked:''}, {todo:'79.一起去见彼此的朋友',achieve:'',checked:''}, {todo:'80.一起看星星⭐',achieve:'',checked:''}, {todo:'81.一起为对方剪指甲',achieve:'',checked:''}, {todo:'82.一起去看樱花',achieve:'',checked:''}, {todo:'83.一起敷面膜',achieve:'',checked:''}, {todo:'84.一起去自驾游',achieve:'',checked:''}, {todo:'85.一起去一次动物园',achieve:'',checked:''}, {todo:'86.一起骑自行车',achieve:'',checked:''}, {todo:'87.一起拍照洗照片贴房间',achieve:'',checked:''}, {todo:'88.一起洗衣服',achieve:'',checked:''}, {todo:'89.为对方录想对他说的话',achieve:'',checked:''}, {todo:'90.一起去听一次相声',achieve:'',checked:''}, {todo:'91.一起玩一次真心话大冒险⛳',achieve:'',checked:''}, {todo:'92.一起去许愿池许个愿❣️',achieve:'',checked:''}, {todo:'93.一起入住一次五星级酒店，看夜景',achieve:'',checked:''}, {todo:'94.一起去K歌',achieve:'',checked:''}, {todo:'95.一起穿情侣装',achieve:'',checked:''}, {todo:'95.一起拜见父母',achieve:'',checked:''}, {todo:'96.一起挑选婚纱',achieve:'',checked:''}, {todo:'97.一起装修我们的房子',achieve:'',checked:''}, {todo:'98.一起做饭',achieve:'',checked:''}, {todo:'99.一起为我们的小家添置东西',achieve:'',checked:''}, {todo:'100.在一起啊，也不算太久，就余生吧',achieve:'',checked:''}, ]; $(document).ready(function(){ $.each(lovetodos,function(i,e){ var html='' + e.todo+''+e.achieve+''+'' ; $('.love-todos').append(html); }); });"},{"title":"","date":"2021-03-24T05:44:16.603Z","updated":"2021-03-24T05:44:16.603Z","comments":true,"path":"yiqing/index.html","permalink":"https://hujiahao.top/yiqing/index.html","excerpt":"","text":""},{"title":"","date":"2021-02-04T11:14:07.167Z","updated":"2021-02-04T11:14:07.167Z","comments":true,"path":"love/love/index.html","permalink":"https://hujiahao.top/love/love/index.html","excerpt":"","text":"jQuery自适应宽度动画时间轴代码 $(function(){ var bigEvent =[{ 'year' : 2015, 'events' :[ { 'mouths' : 2, 'times' :'2015年2月29', 'even' :'某某某创业团队正式成立，确定以“个性化定制”为核心的校园综合服务团队，覆盖20多所大学，成为小' },{ 'mouths' : 4, 'times' :'2015年4月3', 'even' :'某某某创业团队正式成立，确定以“个性化定制”为核心的校园综合服务团队，覆盖20多所大学，成为小' },{ 'mouths' : 10, 'times' :'2015年10月11日', 'even' :'某某某创业团队正式成立，确定以“个性化定制”为核心的校园综合服务团队，覆盖20多所大学，成为小' }] },{ 'year' : 2016, 'events' :[ { 'mouths' : 2, 'times' :'2016年2月18', 'even' :'某某某创业团队正式成立，确定以“个性化定制”为核心的校园综合服务团队，覆盖20多所大学，成为小' },{ 'mouths' : 4, 'times' :'2016年4月15', 'even' :'某某某创业团队正式成立，确定以“个性化定制”为核心的校园综合服务团队，覆盖20多所大学，成为小' } ]}]; $('.event_wrap').eventFlow({'events':bigEvent}); })"},{"title":"时光轴","date":"2021-02-03T09:47:44.839Z","updated":"2021-02-03T09:47:44.839Z","comments":true,"path":"love/photos/index.html","permalink":"https://hujiahao.top/love/photos/index.html","excerpt":"","text":""},{"title":"","date":"2021-01-26T07:01:46.567Z","updated":"2021-01-26T07:01:46.567Z","comments":true,"path":"love/新建文件夹/index.html","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/index.html","excerpt":"","text":"时间轴 时间轴 2020年 //这是要遍历时间轴的数据 var dimeAxis=[ { date:'12月31日', title:'和你第一次跨年，我们去看了《温暖的抱抱》，还去了郑州最文艺的商城——永威木色购物公园，然后在会展中心看了美丽的夜景，并在玉米楼前合影。', achievement:'' }, { date:'12月12日', title:'我们一起去看了《如果声音不记得》,然后我们第一次亲吻啦😘', achievement:'' }, { date:'11月21日', title:'我们一起去看了《风平浪静》,还第一次牵你的小手', achievement:'' }, { date:'10月31日', title:'我们一起去看了《一点就到家》', achievement:'' }, { date:'10月24日', title:'我们在一起啦❤️', achievement:'' }, { date:'Waiting for you ', title:'在等你呢', achievement:'' } ]; $(function(){ $.each(dimeAxis,function(i,e){ var html=''+ ''+e.date+''+ ''+e.achievement+''+ ''+e.title+''+ ''; $('.time-axis').append(html); }); });"},{"title":"","date":"2021-02-08T06:16:24.071Z","updated":"2021-02-08T06:16:24.071Z","comments":true,"path":"love/todo/index.html","permalink":"https://hujiahao.top/love/todo/index.html","excerpt":"","text":"这里记录着文儿与豪将会一起完成的事🧑👧💕 //这是要遍历时间轴的数据 var lovetodos=[ { todo:'', achieve:'1.一起去电影院看一场电影', checked:'checked' }, { todo:'', achieve:'2.一起牵手逛街', checked:'checked' }, { todo:'3.一起去一趟迪士尼游乐园', achieve:'', checked:'' }, { todo:'4.一起去游泳', achieve:'' }, { todo:'5.一起唱歌并且录下来', achieve:'' }, { todo:'6.一起在厨房做次饭', achieve:'' }, {todo:'7.一起过次烛光晚餐🍷',achieve:'',checked:''}, {todo:'8.一起过生日',achieve:'',checked:''}, {todo:'9.一起打扫卫生',achieve:'',checked:''}, {todo:'10.一起去一次鬼屋',achieve:'',checked:''}, {todo:'11.一起去蹦极',achieve:'',checked:''}, {todo:'12.一起养一只宠物',achieve:'',checked:''}, {todo:'13.一起研究口红色号',achieve:'',checked:''}, {todo:'14.一起抓娃娃',achieve:'',checked:''}, {todo:'',achieve:'15.一起换情侣头像',checked:'checked'}, {todo:'16.一起去做次陶艺',achieve:'',checked:''}, {todo:'‍',achieve:'17.一起锻炼身体🤸',checked:'checked'}, {todo:'18.一起去吃一次全家桶',achieve:'',checked:''}, {todo:'19.一起去旅游⛰',achieve:'',checked:''}, {todo:'20.一起换手机壁纸',achieve:'',checked:''}, {todo:'21.一起坐一次摩天轮',achieve:'',checked:''}, {todo:'22.一起拍视频记录生活',achieve:'',checked:''}, {todo:'23.一起刷牙，然后亲亲',achieve:'',checked:''}, {todo:'24.一起去看一次海，去沙滩👙',achieve:'',checked:''}, {todo:'25.一起去爬山',achieve:'',checked:''}, {todo:'26.一起看日出',achieve:'',checked:''}, {todo:'27.互穿对方的衣服，拍照留念',achieve:'',checked:''}, {todo:'28.一起坐一次摩天轮',achieve:'',checked:''}, {todo:'29.一起逛超市买好吃的',achieve:'',checked:''}, {todo:'30.一起去书店看书，分享自己喜欢的书籍📕',achieve:'',checked:''}, {todo:'31.一起在下雨天追剧☔️',achieve:'',checked:''}, {todo:'32.一起做一次蛋糕甜点',achieve:'',checked:''}, {todo:'33.一起看日落',achieve:'',checked:''}, {todo:'34.一起上下班，坐地铁',achieve:'',checked:''}, {todo:'35.一起弹吉他',achieve:'',checked:''}, {todo:'36.一起去买菜',achieve:'',checked:''}, {todo:'37.一起玩游戏🎮',achieve:'',checked:''}, {todo:'38.一起坐一次飞机✈️',achieve:'',checked:''}, {todo:'39.一起种花草',achieve:'',checked:''}, {todo:'40.一起养宠物',achieve:'',checked:''}, {todo:'41.一起用情侣手机壳',achieve:'',checked:''}, {todo:'42.一起去一次海底世界',achieve:'',checked:''}, {todo:'43.一起喝醉一次',achieve:'',checked:''}, {todo:'44.一起打扑克牌♣️',achieve:'',checked:''}, {todo:'45.一起去天安门看升国旗',achieve:'',checked:''}, {todo:'46.一起修理电器',achieve:'',checked:''}, {todo:'47.一起看烟花',achieve:'',checked:''}, {todo:'',achieve:'48.一起吃火锅',checked:'checked'}, {todo:'49.一起庆祝恋爱纪念日',achieve:'',checked:''}, {todo:'50.一起去一次教堂⛪️',achieve:'',checked:''}, {todo:'51.一起看雪，堆雪人☃️',achieve:'',checked:''}, {todo:'52.一起换发型，剪头发',achieve:'',checked:''}, {todo:'53.一起和朋友们去吃饭',achieve:'',checked:''}, {todo:'',achieve:'54.一起听音乐，听同一首歌',checked:'checked'}, {todo:'55.一起坐一次船',achieve:'',checked:''}, {todo:'56.一起露营，住一次帐篷 ⛺',achieve:'',checked:''}, {todo:'57.一起DIY手工✂️',achieve:'',checked:''}, {todo:'',achieve:'58.给对方准备礼物',checked:'checked'}, {todo:'59.一起去我们上过的小学',achieve:'',checked:''}, {todo:'60.一起去我们上过的中学',achieve:'',checked:''}, {todo:'61.一起去我们上过的大学',achieve:'',checked:''}, {todo:'62.一起在沙发上躺着',achieve:'',checked:''}, {todo:'63.一起睡个懒觉，赖个床😴',achieve:'',checked:''}, {todo:'64.偷偷为对方买喜欢又舍不得的东西',achieve:'',checked:''}, {todo:'65.互换角色一天',achieve:'',checked:''}, {todo:'66.一起坐一次巴士，在没去过的地方下车',achieve:'',checked:''}, {todo:'67.一起规划未来',achieve:'',checked:''}, {todo:'68.给对方准备一次浪漫的求婚✨',achieve:'',checked:''}, {todo:'69.一起在午夜看一次恐怖片',achieve:'',checked:''}, {todo:'70.一起安静的听雨声',achieve:'',checked:''}, {todo:'71.一起看一场演唱会',achieve:'',checked:''}, {todo:'72.一起去挑选一束花',achieve:'',checked:''}, {todo:'73.一起去跳一次广场舞',achieve:'',checked:''}, {todo:'74.一起去见证一次别人的婚礼',achieve:'',checked:''}, {todo:'75.一起为对方按摩一次',achieve:'',checked:''}, {todo:'76.一起放一次风筝',achieve:'',checked:''}, {todo:'77.一起吐槽一次对方的缺点',achieve:'',checked:''}, {todo:'78.一起打扮自己',achieve:'',checked:''}, {todo:'79.一起去见彼此的朋友',achieve:'',checked:''}, {todo:'80.一起看星星⭐',achieve:'',checked:''}, {todo:'81.一起为对方剪指甲',achieve:'',checked:''}, {todo:'82.一起去看樱花',achieve:'',checked:''}, {todo:'83.一起敷面膜',achieve:'',checked:''}, {todo:'84.一起去自驾游',achieve:'',checked:''}, {todo:'85.一起去一次动物园',achieve:'',checked:''}, {todo:'86.一起骑自行车',achieve:'',checked:''}, {todo:'87.一起拍照洗照片贴房间',achieve:'',checked:''}, {todo:'88.一起洗衣服',achieve:'',checked:''}, {todo:'89.为对方录想对他说的话',achieve:'',checked:''}, {todo:'90.一起去听一次相声',achieve:'',checked:''}, {todo:'91.一起玩一次真心话大冒险⛳',achieve:'',checked:''}, {todo:'92.一起去许愿池许个愿❣️',achieve:'',checked:''}, {todo:'93.一起入住一次五星级酒店，看夜景',achieve:'',checked:''}, {todo:'94.一起去K歌',achieve:'',checked:''}, {todo:'95.一起穿情侣装',achieve:'',checked:''}, {todo:'95.一起拜见父母',achieve:'',checked:''}, {todo:'96.一起挑选婚纱',achieve:'',checked:''}, {todo:'97.一起装修我们的房子',achieve:'',checked:''}, {todo:'98.一起做饭',achieve:'',checked:''}, {todo:'99.一起为我们的小家添置东西',achieve:'',checked:''}, {todo:'100.在一起啊，也不算太久，就余生吧',achieve:'',checked:''}, ]; $(function(){ $.each(lovetodos,function(i,e){ var html='' + e.todo+''+e.achieve+''+'' ; $('.love-todos').append(html); }); });"},{"title":"Love💕Todos","date":"2021-02-08T06:44:09.459Z","updated":"2021-02-08T06:44:09.459Z","comments":true,"path":"love/todo/index.html","permalink":"https://hujiahao.top/love/todo/index.html","excerpt":"","text":"这里记录着文儿与豪将会一起完成的事🧑👧💕 1.一起去电影院看一场电影 //这是要遍历时间轴的数据 var lovetodos=[ { todo:'', achieve:'1.一起去电影院看一场电影', checked:'checked' }, { todo:'', achieve:'2.一起牵手逛街', checked:'checked' }, { todo:'3.一起去一趟迪士尼游乐园', achieve:'', checked:'' }, { todo:'4.一起去游泳', achieve:'' }, { todo:'5.一起唱歌并且录下来', achieve:'' }, { todo:'6.一起在厨房做次饭', achieve:'' }, {todo:'7.一起过次烛光晚餐🍷',achieve:'',checked:''}, {todo:'8.一起过生日',achieve:'',checked:''}, {todo:'9.一起打扫卫生',achieve:'',checked:''}, {todo:'10.一起去一次鬼屋',achieve:'',checked:''}, {todo:'11.一起去蹦极',achieve:'',checked:''}, {todo:'12.一起养一只宠物',achieve:'',checked:''}, {todo:'13.一起研究口红色号',achieve:'',checked:''}, {todo:'14.一起抓娃娃',achieve:'',checked:''}, {todo:'',achieve:'15.一起换情侣头像',checked:'checked'}, {todo:'16.一起去做次陶艺',achieve:'',checked:''}, {todo:'‍',achieve:'17.一起锻炼身体🤸',checked:'checked'}, {todo:'18.一起去吃一次全家桶',achieve:'',checked:''}, {todo:'19.一起去旅游⛰',achieve:'',checked:''}, {todo:'20.一起换手机壁纸',achieve:'',checked:''}, {todo:'21.一起坐一次摩天轮',achieve:'',checked:''}, {todo:'22.一起拍视频记录生活',achieve:'',checked:''}, {todo:'23.一起刷牙，然后亲亲',achieve:'',checked:''}, {todo:'24.一起去看一次海，去沙滩👙',achieve:'',checked:''}, {todo:'25.一起去爬山',achieve:'',checked:''}, {todo:'26.一起看日出',achieve:'',checked:''}, {todo:'27.互穿对方的衣服，拍照留念',achieve:'',checked:''}, {todo:'28.一起坐一次摩天轮',achieve:'',checked:''}, {todo:'29.一起逛超市买好吃的',achieve:'',checked:''}, {todo:'30.一起去书店看书，分享自己喜欢的书籍📕',achieve:'',checked:''}, {todo:'31.一起在下雨天追剧☔️',achieve:'',checked:''}, {todo:'32.一起做一次蛋糕甜点',achieve:'',checked:''}, {todo:'33.一起看日落',achieve:'',checked:''}, {todo:'34.一起上下班，坐地铁',achieve:'',checked:''}, {todo:'35.一起弹吉他',achieve:'',checked:''}, {todo:'36.一起去买菜',achieve:'',checked:''}, {todo:'37.一起玩游戏🎮',achieve:'',checked:''}, {todo:'38.一起坐一次飞机✈️',achieve:'',checked:''}, {todo:'39.一起种花草',achieve:'',checked:''}, {todo:'40.一起养宠物',achieve:'',checked:''}, {todo:'41.一起用情侣手机壳',achieve:'',checked:''}, {todo:'42.一起去一次海底世界',achieve:'',checked:''}, {todo:'43.一起喝醉一次',achieve:'',checked:''}, {todo:'44.一起打扑克牌♣️',achieve:'',checked:''}, {todo:'45.一起去天安门看升国旗',achieve:'',checked:''}, {todo:'46.一起修理电器',achieve:'',checked:''}, {todo:'47.一起看烟花',achieve:'',checked:''}, {todo:'',achieve:'48.一起吃火锅',checked:'checked'}, {todo:'49.一起庆祝恋爱纪念日',achieve:'',checked:''}, {todo:'50.一起去一次教堂⛪️',achieve:'',checked:''}, {todo:'51.一起看雪，堆雪人☃️',achieve:'',checked:''}, {todo:'52.一起换发型，剪头发',achieve:'',checked:''}, {todo:'53.一起和朋友们去吃饭',achieve:'',checked:''}, {todo:'',achieve:'54.一起听音乐，听同一首歌',checked:'checked'}, {todo:'55.一起坐一次船',achieve:'',checked:''}, {todo:'56.一起露营，住一次帐篷 ⛺',achieve:'',checked:''}, {todo:'57.一起DIY手工✂️',achieve:'',checked:''}, {todo:'',achieve:'58.给对方准备礼物',checked:'checked'}, {todo:'59.一起去我们上过的小学',achieve:'',checked:''}, {todo:'60.一起去我们上过的中学',achieve:'',checked:''}, {todo:'61.一起去我们上过的大学',achieve:'',checked:''}, {todo:'62.一起在沙发上躺着',achieve:'',checked:''}, {todo:'63.一起睡个懒觉，赖个床😴',achieve:'',checked:''}, {todo:'64.偷偷为对方买喜欢又舍不得的东西',achieve:'',checked:''}, {todo:'65.互换角色一天',achieve:'',checked:''}, {todo:'66.一起坐一次巴士，在没去过的地方下车',achieve:'',checked:''}, {todo:'67.一起规划未来',achieve:'',checked:''}, {todo:'68.给对方准备一次浪漫的求婚✨',achieve:'',checked:''}, {todo:'69.一起在午夜看一次恐怖片',achieve:'',checked:''}, {todo:'70.一起安静的听雨声',achieve:'',checked:''}, {todo:'71.一起看一场演唱会',achieve:'',checked:''}, {todo:'72.一起去挑选一束花',achieve:'',checked:''}, {todo:'73.一起去跳一次广场舞',achieve:'',checked:''}, {todo:'74.一起去见证一次别人的婚礼',achieve:'',checked:''}, {todo:'75.一起为对方按摩一次',achieve:'',checked:''}, {todo:'76.一起放一次风筝',achieve:'',checked:''}, {todo:'77.一起吐槽一次对方的缺点',achieve:'',checked:''}, {todo:'78.一起打扮自己',achieve:'',checked:''}, {todo:'79.一起去见彼此的朋友',achieve:'',checked:''}, {todo:'80.一起看星星⭐',achieve:'',checked:''}, {todo:'81.一起为对方剪指甲',achieve:'',checked:''}, {todo:'82.一起去看樱花',achieve:'',checked:''}, {todo:'83.一起敷面膜',achieve:'',checked:''}, {todo:'84.一起去自驾游',achieve:'',checked:''}, {todo:'85.一起去一次动物园',achieve:'',checked:''}, {todo:'86.一起骑自行车',achieve:'',checked:''}, {todo:'87.一起拍照洗照片贴房间',achieve:'',checked:''}, {todo:'88.一起洗衣服',achieve:'',checked:''}, {todo:'89.为对方录想对他说的话',achieve:'',checked:''}, {todo:'90.一起去听一次相声',achieve:'',checked:''}, {todo:'91.一起玩一次真心话大冒险⛳',achieve:'',checked:''}, {todo:'92.一起去许愿池许个愿❣️',achieve:'',checked:''}, {todo:'93.一起入住一次五星级酒店，看夜景',achieve:'',checked:''}, {todo:'94.一起去K歌',achieve:'',checked:''}, {todo:'95.一起穿情侣装',achieve:'',checked:''}, {todo:'95.一起拜见父母',achieve:'',checked:''}, {todo:'96.一起挑选婚纱',achieve:'',checked:''}, {todo:'97.一起装修我们的房子',achieve:'',checked:''}, {todo:'98.一起做饭',achieve:'',checked:''}, {todo:'99.一起为我们的小家添置东西',achieve:'',checked:''}, {todo:'100.在一起啊，也不算太久，就余生吧',achieve:'',checked:''}, ]; $(function(){ $.each(lovetodos,function(i,e){ var html='' + e.todo+''+e.achieve+''+'' ; $('.love-todos').append(html); }); });"},{"title":"","date":"2021-02-05T05:49:05.968Z","updated":"2021-02-05T05:49:05.968Z","comments":true,"path":"love1/css/history.css","permalink":"https://hujiahao.top/love1/css/history.css","excerpt":"","text":"body, p, form, input, textarea, ul, li, h1, h2, h3, h4, dl, dt, dd, table, td, th { margin:0; padding:0; } table, td, th { border-collapse:collapse; } ul, li { list-style:none; } h1, h2, h3, h4 { font-size:100%; } img, input, textarea { vertical-align: middle; border:0; } a { text-decoration:none; } a:hover { text-decoration:underline; } body { position:relative;} .clearfix:after{content:\" \"; display:block; height:0; clear:both; visibility:hidden;} .clearfix{zoom:1;} .fl { float:left;} .fr { float:right;} /*.public*/ .main {margin:0 auto; width:980px;} a { blr:expression(this.onFocus=this.blur()) } /*��� IE*/ a { outline:none; } /*���firefox��*/ .main { padding:45px 0; min-height:720px; } /*history*/ .history { background:url(../images/back2.png) repeat-y 204px 0; overflow:hidden; position:relative;} .history-date { overflow:hidden;} .history-date h2 { background:url(../images/icon1.jpg) #fff no-repeat 196px 0; height:17px; font-size:25px; font-family:΢���ź�; font-weight:normal; padding-left:45px; margin-bottom:74px; color:#00bbff } .history-date h2.first { position:absolute; left:0; top:0; width:935px; z-index:99;} .history-date h2 a { color:#00bbff; display:inline-block; *display:inline; zoom:1; margin:21px 97px 0 0;} .history-date h2 a:hover { text-decoration:none;} .history-date h2 img { vertical-align:-5px;} .history-date h2.date02 { background:none;} .history-date ul {} .history-date ul li { background:url(../images/icon2.jpg) no-repeat 180px 0; padding-bottom:50px; zoom:1; } .history-date ul li.last { padding-bottom:0;} .history-date ul li:after{content:\" \"; display:block; height:0; clear:both; visibility:hidden;} .history-date ul li h3 { float:left; width:168px; text-align:right; padding-right:19px;color:#c3c3c3; font:normal 18px/16px Arial;} .history-date ul li h3 span { display:block; color:#d0d0d0; font-size:12px;} .history-date ul li dl { float:left; padding-left:41px; margin-top:-5px; font-family:΢���ź�;} .history-date ul li dl dt { font:16px/22px ΢���ź�; color:#737373; } .history-date ul li dl dt span { display:block; color:#787878; font-size:12px;} .history-date ul li.green h3 { color:#1db702;} .history-date ul li.green h3 span { color:#a8dda3; } .history-date ul li.green dl { margin-top:-8px;} .history-date ul li.green dl dt { font-size:18px; line-height:28px;} .history-date ul li.green dl dt a { /*background:url(../images/icon09.gif) no-repeat 0 0; width:19px; height:16px;*/ display:inline-block; *display:inline; zoom:1; overflow:hidden; vertical-align: middle; margin-left:12px;} .history-date ul li.green dl dd { padding-top:20px; display:none;} .history-date ul li.green dl dd img { float:left;} .history-date ul li.green dl dd p { overflow:hidden; zoom:1; line-height:21px; color:#787878;} .history-date h2.first .more-history {font-size: 16px; background: transparent; margin-left: 30px;} .history-date h2.first .more-history:hover {text-decoration: underline;} *body .history-date ul li dl dt {_font-size:12px !important; _font-weight:bold;} *body .history-date ul li dl dt span {_font-weight:normal !important;} *body .history-date ul li.green dl dt a {_background:transparent !important; *background:transparent !important;*font-size:12px !important; _font-weight:normal !important;} .todo{ font-size: 18px; padding-left: 20px; text-decoration: none; } .todo:hover{ text-decoration: solid; }"},{"title":"","date":"2021-02-05T05:33:51.953Z","updated":"2021-02-05T05:33:51.953Z","comments":true,"path":"love1/todo/index.html","permalink":"https://hujiahao.top/love1/todo/index.html","excerpt":"","text":"Love 这里记录着文儿与豪将会一起完成的事🧑👧💕 //这是要遍历时间轴的数据 var lovetodos=[ { todo:'', achieve:'1.一起去电影院看一场电影', checked:'checked' }, { todo:'', achieve:'2.一起牵手逛街', checked:'checked' }, { todo:'3.一起去一趟迪士尼游乐园', achieve:'', checked:'' }, { todo:'4.一起去游泳', achieve:'' }, { todo:'5.一起唱歌并且录下来', achieve:'' }, { todo:'6.一起在厨房做次饭', achieve:'' }, {todo:'7.一起过次烛光晚餐🍷',achieve:'',checked:''}, {todo:'8.一起过生日',achieve:'',checked:''}, {todo:'9.一起打扫卫生',achieve:'',checked:''}, {todo:'10.一起去一次鬼屋',achieve:'',checked:''}, {todo:'11.一起去蹦极',achieve:'',checked:''}, {todo:'12.一起养一只宠物',achieve:'',checked:''}, {todo:'13.一起研究口红色号',achieve:'',checked:''}, {todo:'14.一起抓娃娃',achieve:'',checked:''}, {todo:'',achieve:'15.一起换情侣头像',checked:'checked'}, {todo:'16.一起去做次陶艺',achieve:'',checked:''}, {todo:'‍',achieve:'17.一起锻炼身体🤸',checked:'checked'}, {todo:'18.一起去吃一次全家桶',achieve:'',checked:''}, {todo:'19.一起去旅游⛰',achieve:'',checked:''}, {todo:'20.一起换手机壁纸',achieve:'',checked:''}, {todo:'21.一起坐一次摩天轮',achieve:'',checked:''}, {todo:'22.一起拍视频记录生活',achieve:'',checked:''}, {todo:'23.一起刷牙，然后亲亲',achieve:'',checked:''}, {todo:'24.一起去看一次海，去沙滩👙',achieve:'',checked:''}, {todo:'25.一起去爬山',achieve:'',checked:''}, {todo:'26.一起看日出',achieve:'',checked:''}, {todo:'27.互穿对方的衣服，拍照留念',achieve:'',checked:''}, {todo:'28.一起坐一次摩天轮',achieve:'',checked:''}, {todo:'29.一起逛超市买好吃的',achieve:'',checked:''}, {todo:'30.一起去书店看书，分享自己喜欢的书籍📕',achieve:'',checked:''}, {todo:'31.一起在下雨天追剧☔️',achieve:'',checked:''}, {todo:'32.一起做一次蛋糕甜点',achieve:'',checked:''}, {todo:'33.一起看日落',achieve:'',checked:''}, {todo:'34.一起上下班，坐地铁',achieve:'',checked:''}, {todo:'35.一起弹吉他',achieve:'',checked:''}, {todo:'36.一起去买菜',achieve:'',checked:''}, {todo:'37.一起玩游戏🎮',achieve:'',checked:''}, {todo:'38.一起坐一次飞机✈️',achieve:'',checked:''}, {todo:'39.一起种花草',achieve:'',checked:''}, {todo:'40.一起养宠物',achieve:'',checked:''}, {todo:'41.一起用情侣手机壳',achieve:'',checked:''}, {todo:'42.一起去一次海底世界',achieve:'',checked:''}, {todo:'43.一起喝醉一次',achieve:'',checked:''}, {todo:'44.一起打扑克牌♣️',achieve:'',checked:''}, {todo:'45.一起去天安门看升国旗',achieve:'',checked:''}, {todo:'46.一起修理电器',achieve:'',checked:''}, {todo:'47.一起看烟花',achieve:'',checked:''}, {todo:'',achieve:'48.一起吃火锅',checked:'checked'}, {todo:'49.一起庆祝恋爱纪念日',achieve:'',checked:''}, {todo:'50.一起去一次教堂⛪️',achieve:'',checked:''}, {todo:'51.一起看雪，堆雪人☃️',achieve:'',checked:''}, {todo:'52.一起换发型，剪头发',achieve:'',checked:''}, {todo:'53.一起和朋友们去吃饭',achieve:'',checked:''}, {todo:'',achieve:'54.一起听音乐，听同一首歌',checked:'checked'}, {todo:'55.一起坐一次船',achieve:'',checked:''}, {todo:'56.一起露营，住一次帐篷 ⛺',achieve:'',checked:''}, {todo:'57.一起DIY手工✂️',achieve:'',checked:''}, {todo:'',achieve:'58.给对方准备礼物',checked:'checked'}, {todo:'59.一起去我们上过的小学',achieve:'',checked:''}, {todo:'60.一起去我们上过的中学',achieve:'',checked:''}, {todo:'61.一起去我们上过的大学',achieve:'',checked:''}, {todo:'62.一起在沙发上躺着',achieve:'',checked:''}, {todo:'63.一起睡个懒觉，赖个床😴',achieve:'',checked:''}, {todo:'64.偷偷为对方买喜欢又舍不得的东西',achieve:'',checked:''}, {todo:'65.互换角色一天',achieve:'',checked:''}, {todo:'66.一起坐一次巴士，在没去过的地方下车',achieve:'',checked:''}, {todo:'67.一起规划未来',achieve:'',checked:''}, {todo:'68.给对方准备一次浪漫的求婚✨',achieve:'',checked:''}, {todo:'69.一起在午夜看一次恐怖片',achieve:'',checked:''}, {todo:'70.一起安静的听雨声',achieve:'',checked:''}, {todo:'71.一起看一场演唱会',achieve:'',checked:''}, {todo:'72.一起去挑选一束花',achieve:'',checked:''}, {todo:'73.一起去跳一次广场舞',achieve:'',checked:''}, {todo:'74.一起去见证一次别人的婚礼',achieve:'',checked:''}, {todo:'75.一起为对方按摩一次',achieve:'',checked:''}, {todo:'76.一起放一次风筝',achieve:'',checked:''}, {todo:'77.一起吐槽一次对方的缺点',achieve:'',checked:''}, {todo:'78.一起打扮自己',achieve:'',checked:''}, {todo:'79.一起去见彼此的朋友',achieve:'',checked:''}, {todo:'80.一起看星星⭐',achieve:'',checked:''}, {todo:'81.一起为对方剪指甲',achieve:'',checked:''}, {todo:'82.一起去看樱花',achieve:'',checked:''}, {todo:'83.一起敷面膜',achieve:'',checked:''}, {todo:'84.一起去自驾游',achieve:'',checked:''}, {todo:'85.一起去一次动物园',achieve:'',checked:''}, {todo:'86.一起骑自行车',achieve:'',checked:''}, {todo:'87.一起拍照洗照片贴房间',achieve:'',checked:''}, {todo:'88.一起洗衣服',achieve:'',checked:''}, {todo:'89.为对方录想对他说的话',achieve:'',checked:''}, {todo:'90.一起去听一次相声',achieve:'',checked:''}, {todo:'91.一起玩一次真心话大冒险⛳',achieve:'',checked:''}, {todo:'92.一起去许愿池许个愿❣️',achieve:'',checked:''}, {todo:'93.一起入住一次五星级酒店，看夜景',achieve:'',checked:''}, {todo:'94.一起去K歌',achieve:'',checked:''}, {todo:'95.一起穿情侣装',achieve:'',checked:''}, {todo:'95.一起拜见父母',achieve:'',checked:''}, {todo:'96.一起挑选婚纱',achieve:'',checked:''}, {todo:'97.一起装修我们的房子',achieve:'',checked:''}, {todo:'98.一起做饭',achieve:'',checked:''}, {todo:'99.一起为我们的小家添置东西',achieve:'',checked:''}, {todo:'100.在一起啊，也不算太久，就余生吧',achieve:'',checked:''}, ]; $(function(){ $.each(lovetodos,function(i,e){ var html='' + e.todo+''+e.achieve+''+'' ; $('.love-todos').append(html); }); });"},{"title":"","date":"2021-02-04T11:08:17.267Z","updated":"2021-02-04T11:08:17.267Z","comments":true,"path":"love/love/css/home.css","permalink":"https://hujiahao.top/love/love/css/home.css","excerpt":"","text":"html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } table { border-collapse: collapse; border-spacing: 0; } /* display */ .dn{display:none;} .di{display:inline;} .db{display:block;} .dib{display:inline-block;} div.dib{*display:inline; *zoom:1;}/* other block level tag(eg. p, li, h1~h6), using 'inline_any' instead */ /* height */ .h0{height:0;} .h16{height:14px;} .h16{height:16px;} .h18{height:18px;} .h20{height:20px;} .h22{height:22px;} .h24{height:24px;} .h30{height:30px;} /* width */ /* percent width value */ .pct10{width:10%;} .pct15{width:15%;} .pct20{width:20%;} .pct25{width:25%;} .pct30{width:30%;} .pct33{width:33.3%;} .pct40{width:40%;} .pct50{width:50%;} .pct60{width:60%;} .pct66{width:66.6%;} .pct70{width:70%;} .pct75{width:75%;} .pct80{width:80%;} .pct90{width:90%;} .pct100{width:100%;} /* line-height */ .lh0{line-height:0;} .lh16{line-height:14px;} .lh16{line-height:16px;} .lh18{line-height:18px;} .lh20{line-height:20px;} .lh22{line-height:22px;} .lh24{line-height:24px;} .lh30{line-height:30px;} /* margin */ .m0{margin:0;} .ml1{margin-left:1px;} .ml2{margin-left:2px;} .ml5{margin-left:5px;} .ml10{margin-left:10px;} .ml15{margin-left:15px;} .ml20{margin-left:20px;} .ml30{margin-left:30px;} .mr1{margin-right:1px;} .mr2{margin-right:2px;} .mr5{margin-right:5px;} .mr10{margin-right:10px;} .mr15{margin-right:15px;} .mr20{margin-right:20px;} .mr30{margin-right:30px;} .mt1{margin-top:1px;} .mt2{margin-top:2px;} .mt5{margin-top:5px;} .mt10{margin-top:10px;} .mt15{margin-top:15px;} .mt20{margin-top:20px;} .mt30{margin-top:30px;} .mb1{margin-bottom:1px;} .mb2{margin-bottom:2px;} .mb5{margin-bottom:5px;} .mb10{margin-bottom:10px;} .mb15{margin-bottom:15px;} .mb20{margin-bottom:20px;} .mb30{margin-bottom:30px;} /* margin negative */ .ml-1{margin-left:-1px;} .mr-1{margin-right:-1px;} .mt-1{margin-top:-1px;} .mb-1{margin-bottom:-1px;} .ml-3{margin-left:-3px;} .mr-3{margin-right:-3px;} .mt-3{margin-top:-3px;} .mb-3{margin-bottom:-3px;} .ml-20{margin-left:-20px;} .mr-20{margin-right:-20px;} .mt-20{margin-top:-20px;} .mb-20{margin-bottom:-20px;} /* padding */ .p0{padding:0;} .p1{padding:1px;} .pl1{padding-left:1px;} .pt1{padding-top:1px;} .pr1{padding-right:1px;} .pb1{padding-bottom:1px;} .p2{padding:2px;} .pl2{padding-left:2px;} .pt2{padding-top:2px;} .pr2{padding-right:2px;} .pb2{padding-bottom:2px;} .pl5{padding-left:5px;} .p5{padding:5px;} .pt5{padding-top:5px;} .pr5{padding-right:5px;} .pb5{padding-bottom:5px;} .p10{padding:10px;} .pl10{padding-left:10px;} .pt10{padding-top:10px;} .pr10{padding-right:10px;} .pb10{padding-bottom:10px;} .p15{padding:15px;} .pl15{padding-left:15px;} .pt15{padding-top:15px;} .pr15{padding-right:15px;} .pb15{padding-bottom:15px;} .p20{padding:20px;} .pl20{padding-left:20px;} .pt20{padding-top:20px;} .pr20{padding-right:20px;} .pb20{padding-bottom:20px;} .p30{padding:30px;} .pl30{padding-left:30px;} .pt30{padding-top:30px;} .pr30{padding-right:30px;} .pb30{padding-bottom:30px;} /* border-color name rule: border(b)-position(l/r/t/b/d)-width(null/2)-style(null/sh)-color(first one letter/first two letter) |-> All colors are safe color*/ .bdc{border:1px solid #ccc;} .blc{border-left:1px solid #ccc;} .brc{border-right:1px solid #ccc;} .btc{border-top:1px solid #ccc;} .bbc{border-bottom:1px solid #ccc;} .bdd{border:1px solid #ddd;} .bld{border-left:1px solid #ddd;} .brd{border-right:1px solid #ddd;} .btd{border-top:1px solid #ddd;} .bbd{border-bottom:1px solid #ddd;} .bde{border:1px solid #eee;} .ble{border-left:1px solid #eee;} .bre{border-right:1px solid #eee;} .bte{border-top:1px solid #eee;} .bbe{border-bottom:1px solid #eee;} /* background-color name rule: bg - (key word/Hex color) |-> All colors are safe color */ .bgwh{background-color:#fff;} /* safe color */ .g0{color:#000;} .g3{color:#333;} .g6{color:#666;} .g9{color:#999;} .gc{color:#ccc;} .wh{color:white;} /* font-size */ .f0{font-size:0;} .f12{font-size:12px;} .f13{font-size:13px;} .f14{font-size:14px;} .f15{font-size:15px;} .f16{font-size:16px;} .f18{font-size:18px;} .f20{font-size:20px;} .f24{font-size:24px;} .f28{font-size:28px;} /* font-family */ .fa{font-family:Arial;} .ft{font-family:Tahoma;} .fv{font-family:Verdana;} .fs{font-family:Simsun;} .fl{font-family:'Lucida Console';} .fw{font-family:'Microsoft Yahei';} /* font-style */ .n{font-weight:normal; font-style:normal; white-space: normal;} .b{font-weight:bold;} .i{font-style:italic;} /* text-align */ .tc{text-align:center;} .tr{text-align:right;} .tl{text-align:left;} .tj{text-align:justify;} /* text-decoration */ .tdl{text-decoration:underline;} .tdn,.tdn:hover,.tdn a:hover,a.tdl:hover{text-decoration:none;} /* letter-spacing */ .lt-1{letter-spacing:-1px;} .lt0{letter-spacing:0;} .lt1{letter-spacing:1px;} /* white-space */ .nowrap{white-space:nowrap;} /* word-wrap */ .bk{word-wrap:break-word;} /* vertical-align */ .vm{vertical-align:middle;} .vtb{vertical-align:text-bottom;} .vb{vertical-align:bottom;} .vt{vertical-align:top;} .v-1{vertical-align:-1px;} .v-2{vertical-align:-2px;} .v-3{vertical-align:-3px;} .v-4{vertical-align:-4px;} .v-5{vertical-align:-5px;} /* float */ .l{float:left;} .r{float:right;} /* clear */ .cl{clear:both;} /* position */ .rel{position:relative;} .abs{position:absolute;} /*z-index*/ .zx1{z-index:1;} .zx2{z-index:2;} /* cursor */ .poi{cursor:pointer;} .def{cursor:default;} /* overflow */ .ovh{overflow:hidden;} .ova{overflow:auto;} /* visibility */ .vh{visibility:hidden;} .vv{visibility:visible;} /* opacity */ .opa0{opacity:0; filer:alpha(opacity=0);} /* zoom */ .z{*zoom:1;} /* ------------------- multiply CSS ------------------ */ /* 块状元素水平居中 */ .auto{margin-left:auto; margin-right:auto;} /* 清除浮动*/ .fix{*zoom:1;} .fix:after{display:table; content:''; clear:both;} /*清除浮动*/ .clearfix:after{ display:block;height:0;content:'.';clear:both;overflow:hidden; } /* 基于display:table-cell的自适应布局 */ .cell{display:table-cell; *display:inline-block; width:2000px; *width:auto;} /* 双栏自适应cell部分连续英文字符换行 */ .cell2{overflow:hidden; _display:inline-block;} /* 单行文字溢出虚点显 示*/ .ell{text-overflow:ellipsis; white-space:nowrap; overflow:hidden;} /* css3过渡动画效果 */ .trans{ -webkit-transition:all .15s; transition:all .15s; } /* 大小不定元素垂直居中 */ .dib_vm{display:inline-block; width:0; height:100%; vertical-align:middle;} /* 加载中背景图片 - 如果您使用该CSS小库，务必修改此图片地址 */ .loading{background:url(about:blank) no-repeat center;} /* 无框文本框文本域 */ .bd_none{border:0; outline:none;} /* 绝对定位隐藏 */ .abs_out{position:absolute; left:-999em; top:-999em;} .abs_clip{position:absolute; clip:rect(0 0 0 0);} /* 按钮禁用 */ .disabled{outline:0 none; cursor:default!important; opacity:.4; filer:alpha(opacity=40); -ms-pointer-events:none; pointer-events:none;} /*inline-block与float等宽列表*/ .inline_box{font-size:1em; letter-spacing:-.25em; font-family:Arial;} .inline_two, .inline_three, .inline_four, .inline_five, .inline_six, .inline_any{display:inline-block; *display:inline; letter-spacing:0; vertical-align:top; *zoom:1;} .float_two, .float_three, .float_four, .float_five, .float_six{float:left;} .inline_two, .float_two{width:50%; *width:49.9%;} .inline_three, .float_three{width:33.33333%; *width:33.3%;} .inline_four, .float_four{width:25%; *width:24.9%;} .inline_five, .float_five{width:20%; *width:19.9%;} .inline_six, .float_six{width:16.66666%; *width:16.6%;} .inline_fix{display:inline-block; width:100%; height:0; overflow:hidden;} body{font-size: 14px;font-family: '微软雅黑';background-color: rgb(247,247,247);height:100%;} .w1000{width:80%;margin:0 auto;} .header.contrainer{background-color: #ccc;height:60px;line-height: 60px;} .header a{display:block;color:#000;text-decoration: none} .body{line-height: 40px;} .body .header{font-size: 20px;margin: 50px 0 100px;} .event_wrap{position:relative;} .event_wrap .middle_line{position:absolute;left:50%;top:0;width:8px;margin-left: 0px;border-left: 1px solid #000;height:100%;} .event_wrap .middle_line i{display:block;height:3.31%;border-bottom: 1px solid #000;width:60%;} .event_wrap .middle_line i.first{padding-top: 75px;} .event_wrap .middle_line i.last{margin-bottom: 25px;} .big_squre{margin-left:-30px;left:50%;display:block;position:absolute;top:8px;width:60px;height:60px;background-color: #6e6e6e;border-radius: 10px;transform:rotate(45deg);-webkit-transform:rotate(45deg);} .big_squre i{transform:rotate(-45deg);-webkit-transform: rotate(-45deg);display: block;position: absolute;left: 11px;color: #fff;top: 11px;font-size: 18px} .small_squire{position:absolute;top:11px;display:block;height:12px;width:12px;padding:3px;border-radius: 3px;transform:rotate(45deg);-webkit-transform:rotate(45deg);background-color: #6e6e6e;} .small_squire i{display:block;width:12px;height:12px;background-color: #fff;border-radius: 3px;} .event_wrap .list{height:300px;position:relative;padding-top: 75px;} .aActiveWid{width:50% !important;filter:alpha(opacity=100) !important;opacity:1 !important;} .event_wrap .list:last-child{height:275px;} .event_wrap .list .ev_text{position:absolute;opacity:0.1;filter:alpha(opacity=10);width:0px;overflow: hidden; -o-transition: all 3s ease; -moz-transition: all 3s ease; -ms-transition: all 3s ease; -webkit-transition: all 3s ease; transition: all 3s ease;} .event_wrap .list_right .ev_text_odd,.event_wrap .list_left .ev_text_event{text-align: left;left:50%;} .event_wrap .list_right .ev_text_event,.event_wrap .list_left .ev_text_odd{text-align: right;left:initial;right:50%;} .event_wrap .list .ev_t1{top: 55px;} .event_wrap .list .ev_t2{top: 80px;} .event_wrap .list .ev_t3{top: 105px;} .event_wrap .list .ev_t4{top: 130px;} .event_wrap .list .ev_t5{top: 155px;} .event_wrap .list .ev_t6{top: 180px;} .event_wrap .list .ev_t7{top: 205px;} .event_wrap .list .ev_t8{top: 230px;} .event_wrap .list .ev_t9{top: 255px;} .event_wrap .list .ev_t10{top: 280px;} .event_wrap .list .ev_t11{top: 305px;} .event_wrap .list .ev_t12{top: 330px;} .event_wrap .list_right .small_squire,.event_wrap .list_left .ev_text_event .small_squire{left:4px;} .event_wrap .list_left .small_squire,.event_wrap .list_right .ev_text_event .small_squire{right:3px;left:inherit;} .event_wrap .list .small_line,.event_wrap .list_left .ev_text_event .samll_line{display: inline-block;position: absolute;height: 1px;overflow: hidden;border-top: 1px solid #000;top: 19px;left: 24px;width: 13%;} .event_wrap .list_left .ev_text_odd .small_line,.event_wrap .list_right .ev_text_event .small_line{right:23px;left:initial;} .ev_text h3{font-size: 18px;padding-left: 20%;width:80%} .ev_text p{line-height: 20px;padding-left:20%;width:80%;height:40px;overflow: hidden;} .list_right .ev_text_event h3,.list_right .ev_text_event p,.list_left .ev_text_odd h3,.list_left .ev_text_odd p{padding-right: 100px;padding-left: inherit}"},{"title":"","date":"2021-01-25T13:54:51.903Z","updated":"2021-01-25T13:54:51.903Z","comments":true,"path":"love/新建文件夹/css/time-axis.css","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/css/time-axis.css","excerpt":"","text":"body{ margin: 0; padding: 0; } .main{ width: 90%; margin: 30px auto; } .time-axis{ margin: 0; padding: 0; position: relative; } .time-axis:before{ content: ''; position: absolute; left: 130; top: 15px; width: 1px; height: 100%; background-color: #E4E4E4; } .time-axis-item{ list-style: none; padding-left: 150px; position: relative; line-height: 30px; padding-top: 6px; font-size: 14px; color: #141414; } .time-axis-achievement{ position: absolute; top: 20%; left: 7%; color:#00c4b6; font-size: 12px; } .time-axis-date{ position: absolute; left: 0; top: 0; width: 120px; color: #1296db; text-align: center; padding-top: 6px; } .time-axis-date span{ position: absolute; right: -18px; top: 41%; display: block; width: 13px; height: 13px; border: 1px solid #ccc; border-radius: 100%; background-color: #fff; } .time-axis-date span:hover{ } .time-axis-date span:after{ content: ''; position: absolute; left: 0; top: 0; right: 0; bottom: 0; width: 7px; height: 7px; margin: auto; background-color: #ccc; border: 1px solid #ccc; border-radius: 100%; } .time-axis-item:first-child .time-axis-date span{ border-color: #48BEB2; } .time-axis-item:first-child .time-axis-date span:after{ background-color: #48BEB2; border-color: #48BEB2; } .time-title{ font-size:18px; font-weight: 500; margin-left: 90px; }"},{"title":"","date":"2021-02-04T11:08:17.254Z","updated":"2021-02-04T11:08:17.254Z","comments":true,"path":"love/love/js/jquery.eventFlow.js","permalink":"https://hujiahao.top/love/love/js/jquery.eventFlow.js","excerpt":"","text":";(function($,window,document,undefined){ var pluginName = 'eventFlow', defaults ={}; function EventFlow(element,options){ this.init(element,options); } EventFlow.prototype = { init : function(element,options){ this.spliceHtml(element,options); var $text = $('.event_wrap .list .ev_text'); var point = []; $text.each(function(index, el) { point.push($(this).offset().top) }); $(window).scroll(function(event) { var s = $(this).scrollTop(); for(var i =0;i point[i] ){ $($text[i]).addClass('aActiveWid'); }else{ $($text[i]).removeClass('aActiveWid') } } }); }, spliceHtml :function(element,options){ var $element = element; var $middleLine = $element.find('.middle_line'); var middleLineI = ''; var list = '' for(var i = 0;i"},{"title":"","date":"2021-01-30T07:47:24.273Z","updated":"2021-01-30T07:47:24.273Z","comments":true,"path":"love/todo/css/LoveTodos.css","permalink":"https://hujiahao.top/love/todo/css/LoveTodos.css","excerpt":"","text":"*{ margin: 0; padding: 0; } .love-desc{ padding: 10px; border: 1px solid #03a9f4; border-radius: .4rem; background-color: #03a9f433; } .return{ float: right; } .love-todos{ margin-top: 30px; margin-left: 10px; font-size: 14px; color: #000; font-weight: 330; line-height: 30px; } .love-todos input{ margin-right: 10px; width: 15px; height: 15px; margin-right: 8px; }"},{"title":"","date":"2021-01-27T02:51:00.129Z","updated":"2021-01-27T02:51:00.129Z","comments":true,"path":"love/新建文件夹/jiaoben7691/index.html","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/jiaoben7691/index.html","excerpt":"","text":"点我有惊喜"},{"title":"","date":"2021-02-05T05:42:02.108Z","updated":"2021-02-05T05:42:02.108Z","comments":true,"path":"love1/todo/css/LoveTodos.css","permalink":"https://hujiahao.top/love1/todo/css/LoveTodos.css","excerpt":"","text":"*{ margin: 0; padding: 0; } .love-desc{ padding: 10px; border: 1px solid #03a9f4; border-radius: .4rem; background-color: #03a9f433; } .return{ float: right; } .love-todos{ margin-top: 30px; margin-left: 10px; font-size: 14px; color: #000; font-weight: 330; line-height: 30px; } .love-todos input{ margin-right: 10px; width: 15px; height: 15px; margin-right: 8px; }"},{"title":"","date":"2021-01-27T02:47:10.433Z","updated":"2021-01-27T02:47:10.433Z","comments":true,"path":"love/新建文件夹/jiaoben7691/js/script.js","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/jiaoben7691/js/script.js","excerpt":"","text":"new Vue({ el: '#app', data() { return { isOpenedTop: false, items: [ { img1: \"img/1.jpg\", title: \"文❤️豪\", isOpen: false }, { img1: \"img/2.jpg\", title: \"文❤️豪\", isOpen: false }, { img1: \"img/3.jpg\", title: \"文❤️豪\", isOpen: false }, { img1: \"img/4.jpg\", title: \"文❤️豪\", isOpen: false }, ] }; }, methods: { topOpen() { this.isOpenedTop = !this.isOpenedTop; }, open(idx, isOpen) { if (this.isOpenedTop) { this.items[idx].isOpen = !isOpen; } }, reset() { this.items.forEach(item => (item.isOpen = false)); this.isOpenedTop = false; } } })"},{"title":"","date":"2021-01-27T02:51:58.904Z","updated":"2021-01-27T02:51:58.904Z","comments":true,"path":"love/新建文件夹/jiaoben7691/css/style.css","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/jiaoben7691/css/style.css","excerpt":"","text":"@import url(\"https://fonts.googleapis.com/css?family=Cute+Font&display=swap\"); html, body { width: 100%; height: 100vw; margin: 0; } body { color: #333; font-family: \"Cute Font\", cursive; background: #dedfdf; overflow: hidden; } * { margin: 0; padding: 0; box-sizing: border-box; -webkit-box-sizing: border-box; } *:before, *:after { content: \"\"; position: absolute; } .container { margin: auto; } .album { -webkit-transform-style: preserve-3d; transform-style: preserve-3d; -webkit-transition: 1s; transition: 1s; margin: auto; width: 600px; height: 700px; -webkit-transform: scale(0.5); transform: scale(0.5); } .album--open { -webkit-transform: translate(65px, 0) rotateX(35deg) rotateY(0deg) rotateZ(35deg) scale(0.5); transform: translate(65px, 0) rotateX(35deg) rotateY(0deg) rotateZ(35deg) scale(0.5); } .album__paper { position: absolute; top: 0; left: 0; width: 100%; height: 100%; -webkit-transition: 1s; transition: 1s; -webkit-transform-origin: 0 50%; transform-origin: 0 50%; -webkit-transform-style: preserve-3d; transform-style: preserve-3d; } .album__paper:not(.first) .album__page { background: #f1f0f0; background-size: 100% 1.5em; } .album__paper:not(.first) .back { background: #d4d3d3; } .album__paper:nth-of-type(1) .back { background: #0095a3; } .album__paper:nth-of-type(1) .album__page { background: #0095a3; } .album__paper.open { box-shadow: 0 1em 0 0 #aaa; -webkit-transform: rotateX(0) rotateY(-180deg) rotateZ(0); transform: rotateX(0) rotateY(-180deg) rotateZ(0); } .album__paper .album__page.front { transition: 1s; -webkit-transition: 1s; transform-origin: 0 50%; -webkit-transform-origin: 0 50%; -webkit-backface-visibility: hidden; backface-visibility: hidden; z-index: 2; } .album__paper .back { transition: 1s; -webkit-transition: 1s; transform-origin: 0 50%; -webkit-transform-origin: 0 50%; background: #e1e1e1; } .album__top-title { font-size: 40px; line-height: 0.8; padding: 20px; text-align: center; margin-top: 20px; } .album__page { width: 100%; height: 100%; position: absolute; -webkit-transform: translateZ(0px); transform: translateZ(0px); } .album__back { width: 3em; height: 700px; background: #007e8a; position: absolute; left: -3em; top: 0; transform-origin: 100% 100%; -webkit-transform-origin: 100% 100%; transform: rotateY(-90deg) rotateX(0deg); -webkit-transform: rotateY(-90deg) rotateX(0deg); } .album__shadow { position: absolute; top: 0; left: 0; width: 600px; height: 700px; background: transparent; transform: translateZ(-3em); -webkit-transform: translateZ(-3em); box-shadow: 1em 1em 0px 0px #aaa; z-index: 1; } .album__bottom { width: 600px; height: 3em; background: #d4d3d3; position: absolute; bottom: 0; left: 0; transform-origin: 100% 100%; -webkit-transform-origin: 100% 100%; transform: rotateX(90deg); -webkit-transform: rotateX(90deg); } .cat-mark { position: relative; width: 200px; height: 170px; background: #333; border-radius: 60% 60% 90px 90px; margin: 150px auto auto; } .cat-mark:before, .cat-mark:after { top: -25px; width: 0; height: 0; border-bottom: 80px solid #333; border-right: 50px solid transparent; border-left: 50px solid transparent; border-radius: 33px; } .cat-mark:before { right: -20px; transform: rotate(32deg); -webkit-transform: rotate(32deg); } .cat-mark:after { left: -20px; transform: rotate(-32deg); -webkit-transform: rotate(-32deg); } .top-content { height: 100%; display: -webkit-box; display: flex; -webkit-box-orient: vertical; -webkit-box-direction: normal; flex-flow: column; } .content { height: 100%; grid-template-columns: 50% 50%; grid-template-rows: 100px auto; } .content__title { grid-row: 1; grid-column: 1 / 3; font-size: 50px; line-height: 0.8; padding: 20px; box-sizing: border-box; } .content__img1 { display: -webkit-box; display: flex; -webkit-box-align: center; align-items: center; -webkit-box-orient: vertical; -webkit-box-direction: normal; flex-flow: column; box-sizing: border-box; } .content__img1 img { margin: 0 auto; width: 90%; height: 100%; height: 580px; border: 10px solid #fff; box-sizing: border-box; } .content__text { width: 100%; padding: 30px; font-size: 30px; box-sizing: border-box; } @media screen and (max-width: 768px) { body { overflow: visible; } }"},{"title":"","date":"2021-01-27T02:50:54.152Z","updated":"2021-01-27T02:50:54.152Z","comments":true,"path":"love/新建文件夹/新建文件夹/jiaoben7691/index.html","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/jiaoben7691/index.html","excerpt":"","text":"JS点击书本相册翻页代码 - 站长素材 Album NaN"},{"title":"","date":"2021-01-27T02:38:13.925Z","updated":"2021-01-27T02:38:13.925Z","comments":true,"path":"love/新建文件夹/新建文件夹/jiaoben7691/说明.html","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/jiaoben7691/%E8%AF%B4%E6%98%8E.html","excerpt":"","text":"�й�վ��վ�����ļ�˵�� A { FONT-SIZE: 12px; COLOR: #000000; TEXT-DECORATION: none } A:hover { COLOR: #ffcc00 } A.blue { COLOR: darkblue } body, p, td { FONT-SIZE: 12px } �� �� &nbsp;���й�վ��վ�����ļ�˵�� &nbsp;&nbsp; �����صĸ��ļ��������й�վ��վ(www.chinaz.com) ����������Ǵ�www.chinaz.com���صģ�������ϵ���Ǿٱ�������վ��E-mail: sc&#064;chinaz.com &nbsp;&nbsp; ʹ��ǰ�������Ķ����������������ʹ�ñ�վ�ṩ���ļ��� &nbsp;&nbsp; 1) ��վ����֤���ṩ���������������ԺͰ�ȫ�ԡ� &nbsp;&nbsp; 2) ����ʹ��ǰ�鶾 (��Ҳ����ʹ������������Դ������ע���) �� &nbsp;&nbsp; 3) �ɱ�վ�ṩ�ĳ����������վ������������غ���ı�վ�Ų����� &nbsp;&nbsp; 4) ת�ر�վ�ṩ����Դ����ɾ����˵���ļ��� &nbsp;&nbsp; 5) ��վ�ṩ�ĳ����Ϊ�����Ѽ�������ó����漰���ֺ������İ�Ȩ������д��֪ͨ���ǡ�E-mail: sc&#064;chinaz.com &nbsp;&nbsp; ���κ�����ɵ�վ����̳(chinaz.com)�������������Եõ�����ļ���֧�֣� &nbsp;&nbsp; ��ϵ����Ա: sc&#064;chinaz.com &nbsp;&nbsp; ���Ͷ��: ads&#064;chinaz.com&nbsp;&nbsp;&nbsp;�й�վ��վ��Ϊ�й���վ�ṩ���������� &nbsp; C H I N A Z . C O M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Powered by CHINAZ.STUDIO"},{"title":"","date":"2021-01-27T02:38:13.886Z","updated":"2021-01-27T02:38:13.886Z","comments":true,"path":"love/新建文件夹/新建文件夹/jiaoben7691/css/style.css","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/jiaoben7691/css/style.css","excerpt":"","text":"@import url(\"https://fonts.googleapis.com/css?family=Cute+Font&display=swap\"); html, body { width: 100%; height: 100vw; margin: 0; } body { color: #333; font-family: \"Cute Font\", cursive; background: #dedfdf; overflow: hidden; } * { margin: 0; padding: 0; box-sizing: border-box; -webkit-box-sizing: border-box; } *:before, *:after { content: \"\"; position: absolute; } .container { margin: auto; } .album { -webkit-transform-style: preserve-3d; transform-style: preserve-3d; -webkit-transition: 1s; transition: 1s; margin: auto; width: 600px; height: 700px; -webkit-transform: scale(0.5); transform: scale(0.5); } .album--open { -webkit-transform: translate(65px, 0) rotateX(35deg) rotateY(0deg) rotateZ(35deg) scale(0.5); transform: translate(65px, 0) rotateX(35deg) rotateY(0deg) rotateZ(35deg) scale(0.5); } .album__paper { position: absolute; top: 0; left: 0; width: 100%; height: 100%; -webkit-transition: 1s; transition: 1s; -webkit-transform-origin: 0 50%; transform-origin: 0 50%; -webkit-transform-style: preserve-3d; transform-style: preserve-3d; } .album__paper:not(.first) .album__page { background: #f1f0f0; background-size: 100% 1.5em; } .album__paper:not(.first) .back { background: #d4d3d3; } .album__paper:nth-of-type(1) .back { background: #0095a3; } .album__paper:nth-of-type(1) .album__page { background: #0095a3; } .album__paper.open { box-shadow: 0 1em 0 0 #aaa; -webkit-transform: rotateX(0) rotateY(-180deg) rotateZ(0); transform: rotateX(0) rotateY(-180deg) rotateZ(0); } .album__paper .album__page.front { transition: 1s; -webkit-transition: 1s; transform-origin: 0 50%; -webkit-transform-origin: 0 50%; -webkit-backface-visibility: hidden; backface-visibility: hidden; z-index: 2; } .album__paper .back { transition: 1s; -webkit-transition: 1s; transform-origin: 0 50%; -webkit-transform-origin: 0 50%; background: #e1e1e1; } .album__top-title { font-size: 100px; line-height: 0.8; padding: 20px; } .album__page { width: 100%; height: 100%; position: absolute; -webkit-transform: translateZ(0px); transform: translateZ(0px); } .album__back { width: 3em; height: 700px; background: #007e8a; position: absolute; left: -3em; top: 0; transform-origin: 100% 100%; -webkit-transform-origin: 100% 100%; transform: rotateY(-90deg) rotateX(0deg); -webkit-transform: rotateY(-90deg) rotateX(0deg); } .album__shadow { position: absolute; top: 0; left: 0; width: 600px; height: 700px; background: transparent; transform: translateZ(-3em); -webkit-transform: translateZ(-3em); box-shadow: 1em 1em 0px 0px #aaa; z-index: 1; } .album__bottom { width: 600px; height: 3em; background: #d4d3d3; position: absolute; bottom: 0; left: 0; transform-origin: 100% 100%; -webkit-transform-origin: 100% 100%; transform: rotateX(90deg); -webkit-transform: rotateX(90deg); } .cat-mark { position: relative; width: 200px; height: 170px; background: #333; border-radius: 60% 60% 90px 90px; margin: 150px auto auto; } .cat-mark:before, .cat-mark:after { top: -25px; width: 0; height: 0; border-bottom: 80px solid #333; border-right: 50px solid transparent; border-left: 50px solid transparent; border-radius: 33px; } .cat-mark:before { right: -20px; transform: rotate(32deg); -webkit-transform: rotate(32deg); } .cat-mark:after { left: -20px; transform: rotate(-32deg); -webkit-transform: rotate(-32deg); } .top-content { height: 100%; display: -webkit-box; display: flex; -webkit-box-orient: vertical; -webkit-box-direction: normal; flex-flow: column; } .content { height: 100%; display: grid; grid-template-columns: 50% 50%; grid-template-rows: 100px auto; } .content__title { grid-row: 1; grid-column: 1 / 3; font-size: 100px; line-height: 0.8; padding: 20px; box-sizing: border-box; } .content__img1 { grid-row: 2 / 4; grid-column: 1 / 2; display: -webkit-box; display: flex; -webkit-box-align: center; align-items: center; -webkit-box-orient: vertical; -webkit-box-direction: normal; flex-flow: column; box-sizing: border-box; } .content__img1 img { margin: auto; width: 90%; border: 10px solid #fff; box-sizing: border-box; } .content__img2 { grid-row: 3 / 4; grid-column: 2 / 4; display: -webkit-box; display: flex; -webkit-box-align: center; align-items: center; box-sizing: border-box; } .content__img2 img { margin: auto; width: 80%; border: 10px solid #fff; box-sizing: border-box; } .content__img3 { grid-row: 2; grid-column: 2; display: -webkit-box; display: flex; -webkit-box-align: center; align-items: center; box-sizing: border-box; } .content__img3 img { margin: auto; width: 60%; border: 10px solid #fff; box-sizing: border-box; } .content__text { width: 100%; padding: 30px; font-size: 30px; box-sizing: border-box; } @media screen and (max-width: 768px) { body { overflow: visible; } }"},{"title":"","date":"2021-01-27T02:38:13.918Z","updated":"2021-01-27T02:38:13.918Z","comments":true,"path":"love/新建文件夹/新建文件夹/jiaoben7691/js/script.js","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/jiaoben7691/js/script.js","excerpt":"","text":"new Vue({ el: '#app', data() { return { isOpenedTop: true, items: [ { img1: \"img/1.jpg\", img2: \"img/2.jpg\", img3: \"img/3.jpg\", title: \"NEKO\", isOpen: false }, { img1: \"img/4.jpg\", img2: \"img/5.jpg\", img3: \"img/6.jpg\", title: \"NYAN\", isOpen: false }, { img1: \"img/7.jpg\", img2: \"img/8.jpg\", img3: \"img/9.jpg\", title: \"NEKO\", isOpen: false }, { img1: \"img/10.jpg\", img2: \"img/11.jpg\", img3: \"img/12.jpg\", title: \"NYANNYAN\", isOpen: false }, { img1: \"img/13.jpg\", img2: \"img/14.jpg\", img3: \"img/15.jpg\", title: \"NEKONEKO\", isOpen: false } ] }; }, methods: { topOpen() { this.isOpenedTop = !this.isOpenedTop; }, open(idx, isOpen) { if (this.isOpenedTop) { this.items[idx].isOpen = !isOpen; } }, reset() { this.items.forEach(item => (item.isOpen = false)); this.isOpenedTop = false; } } })"},{"title":"","date":"2021-02-04T11:51:31.713Z","updated":"2021-02-04T11:51:31.713Z","comments":true,"path":"love1/js/jquery.js","permalink":"https://hujiahao.top/love1/js/jquery.js","excerpt":"","text":"/*! * jQuery JavaScript Library v1.4.2 * http://jquery.com/ * * Copyright 2010, John Resig * Dual licensed under the MIT or GPL Version 2 licenses. * http://jquery.org/license * * Includes Sizzle.js * http://sizzlejs.com/ * Copyright 2010, The Dojo Foundation * Released under the MIT, BSD, and GPL Licenses. * * Date: Sat Feb 13 22:33:48 2010 -0500 */ (function(A,w){function ma(){if(!c.isReady){try{s.documentElement.doScroll(\"left\")}catch(a){setTimeout(ma,1);return}c.ready()}}function Qa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:\"script\"}):c.globalEval(b.text||b.textContent||b.innerHTML||\"\");b.parentNode&&b.parentNode.removeChild(b)}function X(a,b,d,f,e,j){var i=a.length;if(typeof b===\"object\"){for(var o in b)X(a,o,b[o],f,e,d);return a}if(d!==w){f=!j&&f&&c.isFunction(d);for(o=0;o"},{"title":"","date":"2021-02-04T11:08:17.260Z","updated":"2021-02-04T11:08:17.260Z","comments":true,"path":"love/love/js/jquery.min.js","permalink":"https://hujiahao.top/love/love/js/jquery.min.js","excerpt":"","text":"/*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license //@ sourceMappingURL=jquery.min.map */ (function(e,t){var n,r,i=typeof t,o=e.location,a=e.document,s=a.documentElement,l=e.jQuery,u=e.$,c={},p=[],f=\"1.10.2\",d=p.concat,h=p.push,g=p.slice,m=p.indexOf,y=c.toString,v=c.hasOwnProperty,b=f.trim,x=function(e,t){return new x.fn.init(e,t,r)},w=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,T=/\\S+/g,C=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,N=/^(?:\\s*()[^>]*|#([\\w-]*))$/,k=/^(?:|)$/,E=/^[\\],:{}\\s]*$/,S=/(?:^|:|,)(?:\\s*\\[)+/g,A=/\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,j=/\"[^\"\\\\\\r\\n]*\"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g,D=/^-ms-/,L=/-([\\da-z])/gi,H=function(e,t){return t.toUpperCase()},q=function(e){(a.addEventListener||\"load\"===e.type||\"complete\"===a.readyState)&&(_(),x.ready())},_=function(){a.addEventListener?(a.removeEventListener(\"DOMContentLoaded\",q,!1),e.removeEventListener(\"load\",q,!1)):(a.detachEvent(\"onreadystatechange\",q),e.detachEvent(\"onload\",q))};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,n,r){var i,o;if(!e)return this;if(\"string\"==typeof e){if(i=\"\"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof x?n[0]:n,x.merge(this,x.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:a,!0)),k.test(i[1])&&x.isPlainObject(n))for(i in n)x.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(o=a.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=a,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:\"\",length:0,toArray:function(){return g.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(g.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for(\"boolean\"==typeof s&&(c=s,s=arguments[1]||{},l=2),\"object\"==typeof s||x.isFunction(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(o=arguments[l]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(x.isPlainObject(r)||(n=x.isArray(r)))?(n?(n=!1,a=e&&x.isArray(e)?e:[]):a=e&&x.isPlainObject(e)?e:{},s[i]=x.extend(c,a,r)):r!==t&&(s[i]=r));return s},x.extend({expando:\"jQuery\"+(f+Math.random()).replace(/\\D/g,\"\"),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=l),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){if(e===!0?!--x.readyWait:!x.isReady){if(!a.body)return setTimeout(x.ready);x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(a,[x]),x.fn.trigger&&x(a).trigger(\"ready\").off(\"ready\"))}},isFunction:function(e){return\"function\"===x.type(e)},isArray:Array.isArray||function(e){return\"array\"===x.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?c[y.call(e)]||\"object\":typeof e},isPlainObject:function(e){var n;if(!e||\"object\"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!v.call(e,\"constructor\")&&!v.call(e.constructor.prototype,\"isPrototypeOf\"))return!1}catch(r){return!1}if(x.support.ownLast)for(n in e)return v.call(e,n);for(n in e);return n===t||v.call(e,n)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||\"string\"!=typeof e)return null;\"boolean\"==typeof t&&(n=t,t=!1),t=t||a;var r=k.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:\"string\"==typeof n&&(n=x.trim(n),n&&E.test(n.replace(A,\"@\").replace(j,\"]\").replace(S,\"\")))?Function(\"return \"+n)():(x.error(\"Invalid JSON: \"+n),t)},parseXML:function(n){var r,i;if(!n||\"string\"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,\"text/xml\")):(r=new ActiveXObject(\"Microsoft.XMLDOM\"),r.async=\"false\",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName(\"parsererror\").length||x.error(\"Invalid XML: \"+n),r},noop:function(){},globalEval:function(t){t&&x.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(D,\"ms-\").replace(L,H)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:b&&!b.call(\"\\ufeff\\u00a0\")?function(e){return null==e?\"\":b.call(e)}:function(e){return null==e?\"\":(e+\"\").replace(C,\"\")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?x.merge(n,\"string\"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(m)return m.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if(\"number\"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return d.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return\"string\"==typeof n&&(o=e[n],n=e,e=o),x.isFunction(e)?(r=g.call(arguments,2),i=function(){return e.apply(n||this,r.concat(g.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):t},access:function(e,n,r,i,o,a,s){var l=0,u=e.length,c=null==r;if(\"object\"===x.type(r)){o=!0;for(l in r)x.access(e,n,l,r[l],!0,a,s)}else if(i!==t&&(o=!0,x.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(x(e),n)})),n))for(;u>l;l++)n(e[l],r,s?i:i.call(e[l],l,n(e[l],r)));return o?e:c?n.call(e):u?n(e[0],r):a},now:function(){return(new Date).getTime()},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),x.ready.promise=function(t){if(!n)if(n=x.Deferred(),\"complete\"===a.readyState)setTimeout(x.ready);else if(a.addEventListener)a.addEventListener(\"DOMContentLoaded\",q,!1),e.addEventListener(\"load\",q,!1);else{a.attachEvent(\"onreadystatechange\",q),e.attachEvent(\"onload\",q);var r=!1;try{r=null==e.frameElement&&a.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!x.isReady){try{r.doScroll(\"left\")}catch(e){return setTimeout(o,50)}_(),x.ready()}}()}return n.promise(t)},x.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(e,t){c[\"[object \"+t+\"]\"]=t.toLowerCase()});function M(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:\"array\"===n||\"function\"!==n&&(0===t||\"number\"==typeof t&&t>0&&t-1 in e)}r=x(a),function(e,t){var n,r,i,o,a,s,l,u,c,p,f,d,h,g,m,y,v,b=\"sizzle\"+-new Date,w=e.document,T=0,C=0,N=st(),k=st(),E=st(),S=!1,A=function(e,t){return e===t?(S=!0,0):0},j=typeof t,D=1"},{"title":"","date":"2021-02-04T04:27:03.171Z","updated":"2021-02-04T04:27:03.171Z","comments":true,"path":"love/todo/js/jquery-1.7.2.min.js","permalink":"https://hujiahao.top/love/todo/js/jquery-1.7.2.min.js","excerpt":"","text":"/*! jQuery v1.7.2 jquery.com | jquery.org/license */ (function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cu(a){if(!cj[a]){var b=c.body,d=f(\"\").appendTo(b),e=d.css(\"display\");d.remove();if(e===\"none\"||e===\"\"){ck||(ck=c.createElement(\"iframe\"),ck.frameBorder=ck.width=ck.height=0),b.appendChild(ck);if(!cl||!ck.createElement)cl=(ck.contentWindow||ck.contentDocument).document,cl.write((f.support.boxModel?\"\":\"\")+\"\"),cl.close();d=cl.createElement(a),cl.body.appendChild(d),e=f.css(d,\"display\"),b.removeChild(ck)}cj[a]=e}return cj[a]}function ct(a,b){var c={};f.each(cp.concat.apply([],cp.slice(0,b)),function(){c[this]=a});return c}function cs(){cq=b}function cr(){setTimeout(cs,0);return cq=f.now()}function ci(){try{return new a.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(b){}}function ch(){try{return new a.XMLHttpRequest}catch(b){}}function cb(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g"},{"title":"","date":"2021-01-25T06:17:35.318Z","updated":"2021-01-25T06:17:35.318Z","comments":true,"path":"love1/todo/js/jquery-1.7.2.min.js","permalink":"https://hujiahao.top/love1/todo/js/jquery-1.7.2.min.js","excerpt":"","text":"/*! jQuery v1.7.2 jquery.com | jquery.org/license */ (function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cu(a){if(!cj[a]){var b=c.body,d=f(\"\").appendTo(b),e=d.css(\"display\");d.remove();if(e===\"none\"||e===\"\"){ck||(ck=c.createElement(\"iframe\"),ck.frameBorder=ck.width=ck.height=0),b.appendChild(ck);if(!cl||!ck.createElement)cl=(ck.contentWindow||ck.contentDocument).document,cl.write((f.support.boxModel?\"\":\"\")+\"\"),cl.close();d=cl.createElement(a),cl.body.appendChild(d),e=f.css(d,\"display\"),b.removeChild(ck)}cj[a]=e}return cj[a]}function ct(a,b){var c={};f.each(cp.concat.apply([],cp.slice(0,b)),function(){c[this]=a});return c}function cs(){cq=b}function cr(){setTimeout(cs,0);return cq=f.now()}function ci(){try{return new a.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(b){}}function ch(){try{return new a.XMLHttpRequest}catch(b){}}function cb(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g"},{"title":"","date":"2021-01-25T06:17:35.318Z","updated":"2021-01-25T06:17:35.318Z","comments":true,"path":"love/新建文件夹/js/jquery-1.7.2.min.js","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/js/jquery-1.7.2.min.js","excerpt":"","text":"/*! jQuery v1.7.2 jquery.com | jquery.org/license */ (function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cu(a){if(!cj[a]){var b=c.body,d=f(\"\").appendTo(b),e=d.css(\"display\");d.remove();if(e===\"none\"||e===\"\"){ck||(ck=c.createElement(\"iframe\"),ck.frameBorder=ck.width=ck.height=0),b.appendChild(ck);if(!cl||!ck.createElement)cl=(ck.contentWindow||ck.contentDocument).document,cl.write((f.support.boxModel?\"\":\"\")+\"\"),cl.close();d=cl.createElement(a),cl.body.appendChild(d),e=f.css(d,\"display\"),b.removeChild(ck)}cj[a]=e}return cj[a]}function ct(a,b){var c={};f.each(cp.concat.apply([],cp.slice(0,b)),function(){c[this]=a});return c}function cs(){cq=b}function cr(){setTimeout(cs,0);return cq=f.now()}function ci(){try{return new a.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(b){}}function ch(){try{return new a.XMLHttpRequest}catch(b){}}function cb(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g"},{"title":"","date":"2021-01-27T02:17:43.713Z","updated":"2021-01-27T02:17:43.713Z","comments":true,"path":"love/新建文件夹/jiaoben7691/js/vue.min.js","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/jiaoben7691/js/vue.min.js","excerpt":"","text":"/*! * Vue.js v2.6.11 * (c) 2014-2019 Evan You * Released under the MIT License. */ !function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=e||self).Vue=t()}(this,function(){\"use strict\";var e=Object.freeze({});function t(e){return null==e}function n(e){return null!=e}function r(e){return!0===e}function i(e){return\"string\"==typeof e||\"number\"==typeof e||\"symbol\"==typeof e||\"boolean\"==typeof e}function o(e){return null!==e&&\"object\"==typeof e}var a=Object.prototype.toString;function s(e){return\"[object Object]\"===a.call(e)}function c(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function u(e){return n(e)&&\"function\"==typeof e.then&&\"function\"==typeof e.catch}function l(e){return null==e?\"\":Array.isArray(e)||s(e)&&e.toString===a?JSON.stringify(e,null,2):String(e)}function f(e){var t=parseFloat(e);return isNaN(t)?e:t}function p(e,t){for(var n=Object.create(null),r=e.split(\",\"),i=0;i-1)return e.splice(n,1)}}var m=Object.prototype.hasOwnProperty;function y(e,t){return m.call(e,t)}function g(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var _=/-(\\w)/g,b=g(function(e){return e.replace(_,function(e,t){return t?t.toUpperCase():\"\"})}),$=g(function(e){return e.charAt(0).toUpperCase()+e.slice(1)}),w=/\\B([A-Z])/g,C=g(function(e){return e.replace(w,\"-$1\").toLowerCase()});var x=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var r=arguments.length;return r?r>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function k(e,t){t=t||0;for(var n=e.length-t,r=new Array(n);n--;)r[n]=e[n+t];return r}function A(e,t){for(var n in t)e[n]=t[n];return e}function O(e){for(var t={},n=0;n0,G=(J&&J.indexOf(\"android\"),J&&/iphone|ipad|ipod|ios/.test(J)||\"ios\"===K),X=(J&&/chrome\\/\\d+/.test(J),J&&/phantomjs/.test(J),J&&J.match(/firefox\\/(\\d+)/)),Y={}.watch,Q=!1;if(z)try{var ee={};Object.defineProperty(ee,\"passive\",{get:function(){Q=!0}}),window.addEventListener(\"test-passive\",null,ee)}catch(e){}var te=function(){return void 0===B&&(B=!z&&!V&&\"undefined\"!=typeof global&&(global.process&&\"server\"===global.process.env.VUE_ENV)),B},ne=z&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function re(e){return\"function\"==typeof e&&/native code/.test(e.toString())}var ie,oe=\"undefined\"!=typeof Symbol&&re(Symbol)&&\"undefined\"!=typeof Reflect&&re(Reflect.ownKeys);ie=\"undefined\"!=typeof Set&&re(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var ae=S,se=0,ce=function(){this.id=se++,this.subs=[]};ce.prototype.addSub=function(e){this.subs.push(e)},ce.prototype.removeSub=function(e){h(this.subs,e)},ce.prototype.depend=function(){ce.target&&ce.target.addDep(this)},ce.prototype.notify=function(){for(var e=this.subs.slice(),t=0,n=e.length;t"},{"title":"","date":"2021-01-27T02:38:13.919Z","updated":"2021-01-27T02:38:13.919Z","comments":true,"path":"love/新建文件夹/新建文件夹/jiaoben7691/js/vue.min.js","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/jiaoben7691/js/vue.min.js","excerpt":"","text":"/*! * Vue.js v2.6.11 * (c) 2014-2019 Evan You * Released under the MIT License. */ !function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=e||self).Vue=t()}(this,function(){\"use strict\";var e=Object.freeze({});function t(e){return null==e}function n(e){return null!=e}function r(e){return!0===e}function i(e){return\"string\"==typeof e||\"number\"==typeof e||\"symbol\"==typeof e||\"boolean\"==typeof e}function o(e){return null!==e&&\"object\"==typeof e}var a=Object.prototype.toString;function s(e){return\"[object Object]\"===a.call(e)}function c(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function u(e){return n(e)&&\"function\"==typeof e.then&&\"function\"==typeof e.catch}function l(e){return null==e?\"\":Array.isArray(e)||s(e)&&e.toString===a?JSON.stringify(e,null,2):String(e)}function f(e){var t=parseFloat(e);return isNaN(t)?e:t}function p(e,t){for(var n=Object.create(null),r=e.split(\",\"),i=0;i-1)return e.splice(n,1)}}var m=Object.prototype.hasOwnProperty;function y(e,t){return m.call(e,t)}function g(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var _=/-(\\w)/g,b=g(function(e){return e.replace(_,function(e,t){return t?t.toUpperCase():\"\"})}),$=g(function(e){return e.charAt(0).toUpperCase()+e.slice(1)}),w=/\\B([A-Z])/g,C=g(function(e){return e.replace(w,\"-$1\").toLowerCase()});var x=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var r=arguments.length;return r?r>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function k(e,t){t=t||0;for(var n=e.length-t,r=new Array(n);n--;)r[n]=e[n+t];return r}function A(e,t){for(var n in t)e[n]=t[n];return e}function O(e){for(var t={},n=0;n0,G=(J&&J.indexOf(\"android\"),J&&/iphone|ipad|ipod|ios/.test(J)||\"ios\"===K),X=(J&&/chrome\\/\\d+/.test(J),J&&/phantomjs/.test(J),J&&J.match(/firefox\\/(\\d+)/)),Y={}.watch,Q=!1;if(z)try{var ee={};Object.defineProperty(ee,\"passive\",{get:function(){Q=!0}}),window.addEventListener(\"test-passive\",null,ee)}catch(e){}var te=function(){return void 0===B&&(B=!z&&!V&&\"undefined\"!=typeof global&&(global.process&&\"server\"===global.process.env.VUE_ENV)),B},ne=z&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function re(e){return\"function\"==typeof e&&/native code/.test(e.toString())}var ie,oe=\"undefined\"!=typeof Symbol&&re(Symbol)&&\"undefined\"!=typeof Reflect&&re(Reflect.ownKeys);ie=\"undefined\"!=typeof Set&&re(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var ae=S,se=0,ce=function(){this.id=se++,this.subs=[]};ce.prototype.addSub=function(e){this.subs.push(e)},ce.prototype.removeSub=function(e){h(this.subs,e)},ce.prototype.depend=function(){ce.target&&ce.target.addDep(this)},ce.prototype.notify=function(){for(var e=this.subs.slice(),t=0,n=e.length;t"},{"title":"","date":"2021-01-27T02:17:48.442Z","updated":"2021-01-27T02:17:48.442Z","comments":true,"path":"love/新建文件夹/jiaoben7691/js/vuetify.min.js","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/jiaoben7691/js/vuetify.min.js","excerpt":"","text":"/*! * Vuetify v2.3.0-beta.6 * Forged by John Leider * Released under the MIT License. */ !function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e(require(\"vue\")):\"function\"==typeof define&&define.amd?define([\"vue\"],e):\"object\"==typeof exports?exports.Vuetify=e(require(\"vue\")):t.Vuetify=e(t.Vue)}(\"undefined\"!=typeof self?self:this,function(t){return function(t){var e={};function i(n){if(e[n])return e[n].exports;var r=e[n]={i:n,l:!1,exports:{}};return t[n].call(r.exports,r,r.exports,i),r.l=!0,r.exports}return i.m=t,i.c=e,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},i.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var r in t)i.d(n,r,function(e){return t[e]}.bind(null,r));return n},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p=\"/dist/\",i(i.s=96)}([function(e,i){e.exports=t},,function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){\"use strict\";i.r(e);var n={};i.r(n),i.d(n,\"linear\",function(){return lt}),i.d(n,\"easeInQuad\",function(){return ut}),i.d(n,\"easeOutQuad\",function(){return ct}),i.d(n,\"easeInOutQuad\",function(){return ht}),i.d(n,\"easeInCubic\",function(){return dt}),i.d(n,\"easeOutCubic\",function(){return pt}),i.d(n,\"easeInOutCubic\",function(){return ft}),i.d(n,\"easeInQuart\",function(){return vt}),i.d(n,\"easeOutQuart\",function(){return mt}),i.d(n,\"easeInOutQuart\",function(){return gt}),i.d(n,\"easeInQuint\",function(){return yt}),i.d(n,\"easeOutQuint\",function(){return bt}),i.d(n,\"easeInOutQuint\",function(){return St});var r={};i.r(r),i.d(r,\"VApp\",function(){return f}),i.d(r,\"VAppBar\",function(){return $i}),i.d(r,\"VAppBarNavIcon\",function(){return an}),i.d(r,\"VAlert\",function(){return hn}),i.d(r,\"VAutocomplete\",function(){return Bs}),i.d(r,\"VAvatar\",function(){return Wr}),i.d(r,\"VBadge\",function(){return Ms}),i.d(r,\"VBanner\",function(){return Vs}),i.d(r,\"VBottomNavigation\",function(){return Hs}),i.d(r,\"VBottomSheet\",function(){return Us}),i.d(r,\"VBreadcrumbs\",function(){return Js}),i.d(r,\"VBreadcrumbsItem\",function(){return Xs}),i.d(r,\"VBreadcrumbsDivider\",function(){return Zs}),i.d(r,\"VBtn\",function(){return sn}),i.d(r,\"VBtnToggle\",function(){return to}),i.d(r,\"VCalendar\",function(){return Ma}),i.d(r,\"VCalendarDaily\",function(){return Ea}),i.d(r,\"VCalendarWeekly\",function(){return Ia}),i.d(r,\"VCalendarMonthly\",function(){return Oa}),i.d(r,\"VCard\",function(){return Va}),i.d(r,\"VCardActions\",function(){return Pa}),i.d(r,\"VCardSubtitle\",function(){return ja}),i.d(r,\"VCardText\",function(){return Ha}),i.d(r,\"VCardTitle\",function(){return Fa}),i.d(r,\"VCarousel\",function(){return qa}),i.d(r,\"VCarouselItem\",function(){return Ka}),i.d(r,\"VCheckbox\",function(){return el}),i.d(r,\"VSimpleCheckbox\",function(){return mr}),i.d(r,\"VChip\",function(){return Fn}),i.d(r,\"VChipGroup\",function(){return ol}),i.d(r,\"VColorPicker\",function(){return Kl}),i.d(r,\"VColorPickerSwatches\",function(){return Xl}),i.d(r,\"VColorPickerCanvas\",function(){return wl}),i.d(r,\"VContent\",function(){return Jl}),i.d(r,\"VCombobox\",function(){return tu}),i.d(r,\"VCounter\",function(){return cs}),i.d(r,\"VData\",function(){return ru}),i.d(r,\"VDataIterator\",function(){return uu}),i.d(r,\"VDataFooter\",function(){return ou}),i.d(r,\"VDataTable\",function(){return Eu}),i.d(r,\"VEditDialog\",function(){return Du}),i.d(r,\"VTableOverflow\",function(){return Lu}),i.d(r,\"VDataTableHeader\",function(){return bu}),i.d(r,\"VSimpleTable\",function(){return $u}),i.d(r,\"VVirtualTable\",function(){return Mu}),i.d(r,\"VDatePicker\",function(){return cc}),i.d(r,\"VDatePickerTitle\",function(){return Pu}),i.d(r,\"VDatePickerHeader\",function(){return Yu}),i.d(r,\"VDatePickerDateTable\",function(){return Qu}),i.d(r,\"VDatePickerMonthTable\",function(){return tc}),i.d(r,\"VDatePickerYears\",function(){return ec}),i.d(r,\"VDialog\",function(){return Ys}),i.d(r,\"VDivider\",function(){return yr}),i.d(r,\"VExpansionPanels\",function(){return dc}),i.d(r,\"VExpansionPanel\",function(){return fc}),i.d(r,\"VExpansionPanelHeader\",function(){return gc}),i.d(r,\"VExpansionPanelContent\",function(){return vc}),i.d(r,\"VFileInput\",function(){return Cc}),i.d(r,\"VFooter\",function(){return $c}),i.d(r,\"VForm\",function(){return Oc}),i.d(r,\"VContainer\",function(){return Tc}),i.d(r,\"VCol\",function(){return jc}),i.d(r,\"VRow\",function(){return eh}),i.d(r,\"VSpacer\",function(){return ih}),i.d(r,\"VLayout\",function(){return nh}),i.d(r,\"VFlex\",function(){return rh}),i.d(r,\"VHover\",function(){return sh}),i.d(r,\"VIcon\",function(){return Ti}),i.d(r,\"VImg\",function(){return li}),i.d(r,\"VInput\",function(){return as}),i.d(r,\"VItem\",function(){return ah}),i.d(r,\"VItemGroup\",function(){return Hr}),i.d(r,\"VLabel\",function(){return ts}),i.d(r,\"VLazy\",function(){return uh}),i.d(r,\"VListItemActionText\",function(){return Ur}),i.d(r,\"VListItemContent\",function(){return qr}),i.d(r,\"VListItemTitle\",function(){return Xr}),i.d(r,\"VListItemSubtitle\",function(){return Zr}),i.d(r,\"VList\",function(){return _r}),i.d(r,\"VListGroup\",function(){return Ar}),i.d(r,\"VListItem\",function(){return kr}),i.d(r,\"VListItemAction\",function(){return $r}),i.d(r,\"VListItemAvatar\",function(){return Gr}),i.d(r,\"VListItemIcon\",function(){return Tr}),i.d(r,\"VListItemGroup\",function(){return Nr}),i.d(r,\"VMenu\",function(){return pr}),i.d(r,\"VMessages\",function(){return is}),i.d(r,\"VNavigationDrawer\",function(){return hh}),i.d(r,\"VOverflowBtn\",function(){return ph}),i.d(r,\"VOverlay\",function(){return Ns}),i.d(r,\"VPagination\",function(){return gh}),i.d(r,\"VSheet\",function(){return Re}),i.d(r,\"VParallax\",function(){return yh}),i.d(r,\"VPicker\",function(){return nc}),i.d(r,\"VProgressCircular\",function(){return Ei}),i.d(r,\"VProgressLinear\",function(){return fs}),i.d(r,\"VRadioGroup\",function(){return Sh}),i.d(r,\"VRadio\",function(){return wh}),i.d(r,\"VRangeSlider\",function(){return Oh}),i.d(r,\"VRating\",function(){return _h}),i.d(r,\"VResponsive\",function(){return Xe}),i.d(r,\"VSelect\",function(){return Is}),i.d(r,\"VSkeletonLoader\",function(){return Ah}),i.d(r,\"VSlider\",function(){return ll}),i.d(r,\"VSlideGroup\",function(){return rl}),i.d(r,\"VSlideItem\",function(){return Eh}),i.d(r,\"VSnackbar\",function(){return Dh}),i.d(r,\"VSparkline\",function(){return Yh}),i.d(r,\"VSpeedDial\",function(){return Gh}),i.d(r,\"VStepper\",function(){return qh}),i.d(r,\"VStepperContent\",function(){return Zh}),i.d(r,\"VStepperStep\",function(){return Xh}),i.d(r,\"VStepperHeader\",function(){return Kh}),i.d(r,\"VStepperItems\",function(){return Jh}),i.d(r,\"VSubheader\",function(){return xr}),i.d(r,\"VSwitch\",function(){return td}),i.d(r,\"VSystemBar\",function(){return id}),i.d(r,\"VTabs\",function(){return cd}),i.d(r,\"VTab\",function(){return dd}),i.d(r,\"VTabItem\",function(){return pd}),i.d(r,\"VTabsItems\",function(){return ad}),i.d(r,\"VTabsSlider\",function(){return ld}),i.d(r,\"VTextarea\",function(){return vd}),i.d(r,\"VTextField\",function(){return Ss}),i.d(r,\"VThemeProvider\",function(){return zn}),i.d(r,\"VTimeline\",function(){return gd}),i.d(r,\"VTimelineItem\",function(){return bd}),i.d(r,\"VTimePicker\",function(){return Td}),i.d(r,\"VTimePickerClock\",function(){return wd}),i.d(r,\"VTimePickerTitle\",function(){return Sd}),i.d(r,\"VToolbar\",function(){return hi}),i.d(r,\"VToolbarItems\",function(){return Ad}),i.d(r,\"VToolbarTitle\",function(){return Bd}),i.d(r,\"VTooltip\",function(){return Ed}),i.d(r,\"VTreeview\",function(){return Gd}),i.d(r,\"VTreeviewNode\",function(){return Hd}),i.d(r,\"VVirtualScroll\",function(){return Ud}),i.d(r,\"VWindow\",function(){return Ga}),i.d(r,\"VWindowItem\",function(){return Xa}),i.d(r,\"VCarouselTransition\",function(){return yn}),i.d(r,\"VCarouselReverseTransition\",function(){return bn}),i.d(r,\"VTabTransition\",function(){return Sn}),i.d(r,\"VTabReverseTransition\",function(){return xn}),i.d(r,\"VMenuTransition\",function(){return wn}),i.d(r,\"VFabTransition\",function(){return Cn}),i.d(r,\"VDialogTransition\",function(){return kn}),i.d(r,\"VDialogBottomTransition\",function(){return $n}),i.d(r,\"VFadeTransition\",function(){return In}),i.d(r,\"VScaleTransition\",function(){return On}),i.d(r,\"VScrollXTransition\",function(){return _n}),i.d(r,\"VScrollXReverseTransition\",function(){return Tn}),i.d(r,\"VScrollYTransition\",function(){return Bn}),i.d(r,\"VScrollYReverseTransition\",function(){return An}),i.d(r,\"VSlideXTransition\",function(){return En}),i.d(r,\"VSlideXReverseTransition\",function(){return Dn}),i.d(r,\"VSlideYTransition\",function(){return Mn}),i.d(r,\"VSlideYReverseTransition\",function(){return Ln}),i.d(r,\"VExpandTransition\",function(){return Vn}),i.d(r,\"VExpandXTransition\",function(){return Pn});var s={};i.r(s),i.d(s,\"ClickOutside\",function(){return or}),i.d(s,\"Color\",function(){return Zd}),i.d(s,\"Intersect\",function(){return Ue}),i.d(s,\"Mutate\",function(){return tp}),i.d(s,\"Resize\",function(){return lr}),i.d(s,\"Ripple\",function(){return Ki}),i.d(s,\"Scroll\",function(){return pi}),i.d(s,\"Touch\",function(){return Wa});i(10);var o=i(0),a=i.n(o),l=function(){return(l=Object.assign||function(t){for(var e,i=1,n=arguments.length;i"},{"title":"","date":"2021-01-27T02:38:13.923Z","updated":"2021-01-27T02:38:13.923Z","comments":true,"path":"love/新建文件夹/新建文件夹/jiaoben7691/js/vuetify.min.js","permalink":"https://hujiahao.top/love/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/jiaoben7691/js/vuetify.min.js","excerpt":"","text":"/*! * Vuetify v2.3.0-beta.6 * Forged by John Leider * Released under the MIT License. */ !function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e(require(\"vue\")):\"function\"==typeof define&&define.amd?define([\"vue\"],e):\"object\"==typeof exports?exports.Vuetify=e(require(\"vue\")):t.Vuetify=e(t.Vue)}(\"undefined\"!=typeof self?self:this,function(t){return function(t){var e={};function i(n){if(e[n])return e[n].exports;var r=e[n]={i:n,l:!1,exports:{}};return t[n].call(r.exports,r,r.exports,i),r.l=!0,r.exports}return i.m=t,i.c=e,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},i.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var r in t)i.d(n,r,function(e){return t[e]}.bind(null,r));return n},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p=\"/dist/\",i(i.s=96)}([function(e,i){e.exports=t},,function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){},function(t,e,i){\"use strict\";i.r(e);var n={};i.r(n),i.d(n,\"linear\",function(){return lt}),i.d(n,\"easeInQuad\",function(){return ut}),i.d(n,\"easeOutQuad\",function(){return ct}),i.d(n,\"easeInOutQuad\",function(){return ht}),i.d(n,\"easeInCubic\",function(){return dt}),i.d(n,\"easeOutCubic\",function(){return pt}),i.d(n,\"easeInOutCubic\",function(){return ft}),i.d(n,\"easeInQuart\",function(){return vt}),i.d(n,\"easeOutQuart\",function(){return mt}),i.d(n,\"easeInOutQuart\",function(){return gt}),i.d(n,\"easeInQuint\",function(){return yt}),i.d(n,\"easeOutQuint\",function(){return bt}),i.d(n,\"easeInOutQuint\",function(){return St});var r={};i.r(r),i.d(r,\"VApp\",function(){return f}),i.d(r,\"VAppBar\",function(){return $i}),i.d(r,\"VAppBarNavIcon\",function(){return an}),i.d(r,\"VAlert\",function(){return hn}),i.d(r,\"VAutocomplete\",function(){return Bs}),i.d(r,\"VAvatar\",function(){return Wr}),i.d(r,\"VBadge\",function(){return Ms}),i.d(r,\"VBanner\",function(){return Vs}),i.d(r,\"VBottomNavigation\",function(){return Hs}),i.d(r,\"VBottomSheet\",function(){return Us}),i.d(r,\"VBreadcrumbs\",function(){return Js}),i.d(r,\"VBreadcrumbsItem\",function(){return Xs}),i.d(r,\"VBreadcrumbsDivider\",function(){return Zs}),i.d(r,\"VBtn\",function(){return sn}),i.d(r,\"VBtnToggle\",function(){return to}),i.d(r,\"VCalendar\",function(){return Ma}),i.d(r,\"VCalendarDaily\",function(){return Ea}),i.d(r,\"VCalendarWeekly\",function(){return Ia}),i.d(r,\"VCalendarMonthly\",function(){return Oa}),i.d(r,\"VCard\",function(){return Va}),i.d(r,\"VCardActions\",function(){return Pa}),i.d(r,\"VCardSubtitle\",function(){return ja}),i.d(r,\"VCardText\",function(){return Ha}),i.d(r,\"VCardTitle\",function(){return Fa}),i.d(r,\"VCarousel\",function(){return qa}),i.d(r,\"VCarouselItem\",function(){return Ka}),i.d(r,\"VCheckbox\",function(){return el}),i.d(r,\"VSimpleCheckbox\",function(){return mr}),i.d(r,\"VChip\",function(){return Fn}),i.d(r,\"VChipGroup\",function(){return ol}),i.d(r,\"VColorPicker\",function(){return Kl}),i.d(r,\"VColorPickerSwatches\",function(){return Xl}),i.d(r,\"VColorPickerCanvas\",function(){return wl}),i.d(r,\"VContent\",function(){return Jl}),i.d(r,\"VCombobox\",function(){return tu}),i.d(r,\"VCounter\",function(){return cs}),i.d(r,\"VData\",function(){return ru}),i.d(r,\"VDataIterator\",function(){return uu}),i.d(r,\"VDataFooter\",function(){return ou}),i.d(r,\"VDataTable\",function(){return Eu}),i.d(r,\"VEditDialog\",function(){return Du}),i.d(r,\"VTableOverflow\",function(){return Lu}),i.d(r,\"VDataTableHeader\",function(){return bu}),i.d(r,\"VSimpleTable\",function(){return $u}),i.d(r,\"VVirtualTable\",function(){return Mu}),i.d(r,\"VDatePicker\",function(){return cc}),i.d(r,\"VDatePickerTitle\",function(){return Pu}),i.d(r,\"VDatePickerHeader\",function(){return Yu}),i.d(r,\"VDatePickerDateTable\",function(){return Qu}),i.d(r,\"VDatePickerMonthTable\",function(){return tc}),i.d(r,\"VDatePickerYears\",function(){return ec}),i.d(r,\"VDialog\",function(){return Ys}),i.d(r,\"VDivider\",function(){return yr}),i.d(r,\"VExpansionPanels\",function(){return dc}),i.d(r,\"VExpansionPanel\",function(){return fc}),i.d(r,\"VExpansionPanelHeader\",function(){return gc}),i.d(r,\"VExpansionPanelContent\",function(){return vc}),i.d(r,\"VFileInput\",function(){return Cc}),i.d(r,\"VFooter\",function(){return $c}),i.d(r,\"VForm\",function(){return Oc}),i.d(r,\"VContainer\",function(){return Tc}),i.d(r,\"VCol\",function(){return jc}),i.d(r,\"VRow\",function(){return eh}),i.d(r,\"VSpacer\",function(){return ih}),i.d(r,\"VLayout\",function(){return nh}),i.d(r,\"VFlex\",function(){return rh}),i.d(r,\"VHover\",function(){return sh}),i.d(r,\"VIcon\",function(){return Ti}),i.d(r,\"VImg\",function(){return li}),i.d(r,\"VInput\",function(){return as}),i.d(r,\"VItem\",function(){return ah}),i.d(r,\"VItemGroup\",function(){return Hr}),i.d(r,\"VLabel\",function(){return ts}),i.d(r,\"VLazy\",function(){return uh}),i.d(r,\"VListItemActionText\",function(){return Ur}),i.d(r,\"VListItemContent\",function(){return qr}),i.d(r,\"VListItemTitle\",function(){return Xr}),i.d(r,\"VListItemSubtitle\",function(){return Zr}),i.d(r,\"VList\",function(){return _r}),i.d(r,\"VListGroup\",function(){return Ar}),i.d(r,\"VListItem\",function(){return kr}),i.d(r,\"VListItemAction\",function(){return $r}),i.d(r,\"VListItemAvatar\",function(){return Gr}),i.d(r,\"VListItemIcon\",function(){return Tr}),i.d(r,\"VListItemGroup\",function(){return Nr}),i.d(r,\"VMenu\",function(){return pr}),i.d(r,\"VMessages\",function(){return is}),i.d(r,\"VNavigationDrawer\",function(){return hh}),i.d(r,\"VOverflowBtn\",function(){return ph}),i.d(r,\"VOverlay\",function(){return Ns}),i.d(r,\"VPagination\",function(){return gh}),i.d(r,\"VSheet\",function(){return Re}),i.d(r,\"VParallax\",function(){return yh}),i.d(r,\"VPicker\",function(){return nc}),i.d(r,\"VProgressCircular\",function(){return Ei}),i.d(r,\"VProgressLinear\",function(){return fs}),i.d(r,\"VRadioGroup\",function(){return Sh}),i.d(r,\"VRadio\",function(){return wh}),i.d(r,\"VRangeSlider\",function(){return Oh}),i.d(r,\"VRating\",function(){return _h}),i.d(r,\"VResponsive\",function(){return Xe}),i.d(r,\"VSelect\",function(){return Is}),i.d(r,\"VSkeletonLoader\",function(){return Ah}),i.d(r,\"VSlider\",function(){return ll}),i.d(r,\"VSlideGroup\",function(){return rl}),i.d(r,\"VSlideItem\",function(){return Eh}),i.d(r,\"VSnackbar\",function(){return Dh}),i.d(r,\"VSparkline\",function(){return Yh}),i.d(r,\"VSpeedDial\",function(){return Gh}),i.d(r,\"VStepper\",function(){return qh}),i.d(r,\"VStepperContent\",function(){return Zh}),i.d(r,\"VStepperStep\",function(){return Xh}),i.d(r,\"VStepperHeader\",function(){return Kh}),i.d(r,\"VStepperItems\",function(){return Jh}),i.d(r,\"VSubheader\",function(){return xr}),i.d(r,\"VSwitch\",function(){return td}),i.d(r,\"VSystemBar\",function(){return id}),i.d(r,\"VTabs\",function(){return cd}),i.d(r,\"VTab\",function(){return dd}),i.d(r,\"VTabItem\",function(){return pd}),i.d(r,\"VTabsItems\",function(){return ad}),i.d(r,\"VTabsSlider\",function(){return ld}),i.d(r,\"VTextarea\",function(){return vd}),i.d(r,\"VTextField\",function(){return Ss}),i.d(r,\"VThemeProvider\",function(){return zn}),i.d(r,\"VTimeline\",function(){return gd}),i.d(r,\"VTimelineItem\",function(){return bd}),i.d(r,\"VTimePicker\",function(){return Td}),i.d(r,\"VTimePickerClock\",function(){return wd}),i.d(r,\"VTimePickerTitle\",function(){return Sd}),i.d(r,\"VToolbar\",function(){return hi}),i.d(r,\"VToolbarItems\",function(){return Ad}),i.d(r,\"VToolbarTitle\",function(){return Bd}),i.d(r,\"VTooltip\",function(){return Ed}),i.d(r,\"VTreeview\",function(){return Gd}),i.d(r,\"VTreeviewNode\",function(){return Hd}),i.d(r,\"VVirtualScroll\",function(){return Ud}),i.d(r,\"VWindow\",function(){return Ga}),i.d(r,\"VWindowItem\",function(){return Xa}),i.d(r,\"VCarouselTransition\",function(){return yn}),i.d(r,\"VCarouselReverseTransition\",function(){return bn}),i.d(r,\"VTabTransition\",function(){return Sn}),i.d(r,\"VTabReverseTransition\",function(){return xn}),i.d(r,\"VMenuTransition\",function(){return wn}),i.d(r,\"VFabTransition\",function(){return Cn}),i.d(r,\"VDialogTransition\",function(){return kn}),i.d(r,\"VDialogBottomTransition\",function(){return $n}),i.d(r,\"VFadeTransition\",function(){return In}),i.d(r,\"VScaleTransition\",function(){return On}),i.d(r,\"VScrollXTransition\",function(){return _n}),i.d(r,\"VScrollXReverseTransition\",function(){return Tn}),i.d(r,\"VScrollYTransition\",function(){return Bn}),i.d(r,\"VScrollYReverseTransition\",function(){return An}),i.d(r,\"VSlideXTransition\",function(){return En}),i.d(r,\"VSlideXReverseTransition\",function(){return Dn}),i.d(r,\"VSlideYTransition\",function(){return Mn}),i.d(r,\"VSlideYReverseTransition\",function(){return Ln}),i.d(r,\"VExpandTransition\",function(){return Vn}),i.d(r,\"VExpandXTransition\",function(){return Pn});var s={};i.r(s),i.d(s,\"ClickOutside\",function(){return or}),i.d(s,\"Color\",function(){return Zd}),i.d(s,\"Intersect\",function(){return Ue}),i.d(s,\"Mutate\",function(){return tp}),i.d(s,\"Resize\",function(){return lr}),i.d(s,\"Ripple\",function(){return Ki}),i.d(s,\"Scroll\",function(){return pi}),i.d(s,\"Touch\",function(){return Wa});i(10);var o=i(0),a=i.n(o),l=function(){return(l=Object.assign||function(t){for(var e,i=1,n=arguments.length;i"}],"posts":[{"title":"IO流01","slug":"IO流01","date":"2021-09-19T11:59:00.000Z","updated":"2021-09-19T11:59:00.000Z","comments":true,"path":"2021/09/19/IO流01/","link":"","permalink":"https://hujiahao.top/2021/09/19/IO%E6%B5%8101/","excerpt":"","text":"1.File类1.1File类概述和构造方法【应用】 File类介绍 它是文件和目录路径名的抽象表示 文件和目录是可以通过File封装成对象的 对于File而言,其封装的并不是一个真正存在的文件,仅仅是一个路径名而已.它可以是存在的,也可以是不存在的.将来是要通过具体的操作把这个路径的内容转换为具体存在的 File类的构造方法 方法名 说明 File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 File(String parent, String child) 从父路径名字符串和子路径名字符串创建新的 File实例 File(File parent, String child) 从父抽象路径名和子路径名字符串创建新的 File实例 示例代码 12345678910111213141516public class FileDemo01 &#123; public static void main(String[] args) &#123; //File(String pathname): 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 File f1 = new File(&quot;E:\\\\itcast\\\\java.txt&quot;); System.out.println(f1); //File(String parent, String child): 从父路径名字符串和子路径名字符串创建新的 File实例 File f2 = new File(&quot;E:\\\\itcast&quot;,&quot;java.txt&quot;); System.out.println(f2); //File(File parent, String child): 从父抽象路径名和子路径名字符串创建新的 File实例 File f3 = new File(&quot;E:\\\\itcast&quot;); File f4 = new File(f3,&quot;java.txt&quot;); System.out.println(f4); &#125;&#125; 1.2绝对路径和相对路径【理解】 绝对路径 是一个完整的路径,从盘符开始 相对路径 是一个简化的路径,相对当前项目下的路径 示例代码 12345678910public class FileDemo02 &#123; public static void main(String[] args) &#123; // 是一个完整的路径,从盘符开始 File file1 = new File(&quot;D:\\\\itheima\\\\a.txt&quot;); // 是一个简化的路径,从当前项目根目录开始 File file2 = new File(&quot;a.txt&quot;); File file3 = new File(&quot;模块名\\\\a.txt&quot;); &#125;&#125; 1.3File类创建功能【应用】 方法分类 方法名 说明 public boolean createNewFile() 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 public boolean mkdir() 创建由此抽象路径名命名的目录 public boolean mkdirs() 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录 示例代码 123456789101112131415161718192021222324public class FileDemo02 &#123; public static void main(String[] args) throws IOException &#123; //需求1：我要在E:\\\\itcast目录下创建一个文件java.txt File f1 = new File(&quot;E:\\\\itcast\\\\java.txt&quot;); System.out.println(f1.createNewFile()); System.out.println(&quot;--------&quot;); //需求2：我要在E:\\\\itcast目录下创建一个目录JavaSE File f2 = new File(&quot;E:\\\\itcast\\\\JavaSE&quot;); System.out.println(f2.mkdir()); System.out.println(&quot;--------&quot;); //需求3：我要在E:\\\\itcast目录下创建一个多级目录JavaWEB\\\\HTML File f3 = new File(&quot;E:\\\\itcast\\\\JavaWEB\\\\HTML&quot;);// System.out.println(f3.mkdir()); System.out.println(f3.mkdirs()); System.out.println(&quot;--------&quot;); //需求4：我要在E:\\\\itcast目录下创建一个文件javase.txt File f4 = new File(&quot;E:\\\\itcast\\\\javase.txt&quot;);// System.out.println(f4.mkdir()); System.out.println(f4.createNewFile()); &#125;&#125; 1.4File类删除功能【应用】 方法分类 方法名 说明 public boolean delete() 删除由此抽象路径名表示的文件或目录 示例代码 123456789101112131415161718192021222324252627282930public class FileDemo03 &#123; public static void main(String[] args) throws IOException &#123;// File f1 = new File(&quot;E:\\\\itcast\\\\java.txt&quot;); //需求1：在当前模块目录下创建java.txt文件 File f1 = new File(&quot;myFile\\\\java.txt&quot;);// System.out.println(f1.createNewFile()); //需求2：删除当前模块目录下的java.txt文件 System.out.println(f1.delete()); System.out.println(&quot;--------&quot;); //需求3：在当前模块目录下创建itcast目录 File f2 = new File(&quot;myFile\\\\itcast&quot;);// System.out.println(f2.mkdir()); //需求4：删除当前模块目录下的itcast目录 System.out.println(f2.delete()); System.out.println(&quot;--------&quot;); //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt File f3 = new File(&quot;myFile\\\\itcast&quot;);// System.out.println(f3.mkdir()); File f4 = new File(&quot;myFile\\\\itcast\\\\java.txt&quot;);// System.out.println(f4.createNewFile()); //需求6：删除当前模块下的目录itcast System.out.println(f4.delete()); System.out.println(f3.delete()); &#125;&#125; 1.5File类判断和获取功能【应用】 判断功能 方法名 说明 public boolean isDirectory() 测试此抽象路径名表示的File是否为目录 public boolean isFile() 测试此抽象路径名表示的File是否为文件 public boolean exists() 测试此抽象路径名表示的File是否存在 获取功能 方法名 说明 public String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串 public String getPath() 将此抽象路径名转换为路径名字符串 public String getName() 返回由此抽象路径名表示的文件或目录的名称 public File[] listFiles() 返回此抽象路径名表示的目录中的文件和目录的File对象数组 示例代码 1234567891011121314151617181920212223242526272829303132public class FileDemo04 &#123; public static void main(String[] args) &#123; //创建一个File对象 File f = new File(&quot;myFile\\\\java.txt&quot;);// public boolean isDirectory()：测试此抽象路径名表示的File是否为目录// public boolean isFile()：测试此抽象路径名表示的File是否为文件// public boolean exists()：测试此抽象路径名表示的File是否存在 System.out.println(f.isDirectory()); System.out.println(f.isFile()); System.out.println(f.exists());// public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串// public String getPath()：将此抽象路径名转换为路径名字符串// public String getName()：返回由此抽象路径名表示的文件或目录的名称 System.out.println(f.getAbsolutePath()); System.out.println(f.getPath()); System.out.println(f.getName()); System.out.println(&quot;--------&quot;);// public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组 File f2 = new File(&quot;E:\\\\itcast&quot;); File[] fileArray = f2.listFiles(); for(File file : fileArray) &#123;// System.out.println(file);// System.out.println(file.getName()); if(file.isFile()) &#123; System.out.println(file.getName()); &#125; &#125; &#125;&#125; 1.6File类练习一【应用】 案例需求 在当前模块下的aaa文件夹中创建一个a.txt文件 实现步骤 创建File对象,指向aaa文件夹 判断aaa文件夹是否存在,如果不存在则创建 创建File对象,指向aaa文件夹下的a.txt文件 创建这个文件 代码实现 1234567891011121314151617181920public class Test1 &#123; public static void main(String[] args) throws IOException &#123; //练习一：在当前模块下的aaa文件夹中创建一个a.txt文件 /* File file = new File(&quot;filemodule\\\\aaa\\\\a.txt&quot;); file.createNewFile();*/ //注意点:文件所在的文件夹必须要存在. //1.创建File对象,指向aaa文件夹 File file = new File(&quot;filemodule\\\\aaa&quot;); //2.判断aaa文件夹是否存在,如果不存在则创建 if(!file.exists())&#123; //如果文件夹不存在,就创建出来 file.mkdirs(); &#125; //3.创建File对象,指向aaa文件夹下的a.txt文件 File newFile = new File(file,&quot;a.txt&quot;); //4.创建这个文件 newFile.createNewFile(); &#125;&#125; 1.7File类练习二【应用】 案例需求 删除一个多级文件夹 实现步骤 定义一个方法,接收一个File对象 遍历这个File对象,获取它下边的每个文件和文件夹对象 判断当前遍历到的File对象是文件还是文件夹 如果是文件,直接删除 如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 代码实现 1234567891011121314151617181920212223242526272829303132333435public class Test2 &#123; public static void main(String[] args) &#123; //练习二：删除一个多级文件夹 //delete方法 //只能删除文件和空文件夹. //如果现在要删除一个有内容的文件夹? //先删掉这个文件夹里面所有的内容. //最后再删除这个文件夹 File src = new File(&quot;C:\\\\Users\\\\apple\\\\Desktop\\\\src&quot;); deleteDir(src); &#125; //1.定义一个方法,接收一个File对象 private static void deleteDir(File src) &#123; //先删掉这个文件夹里面所有的内容. //递归 方法在方法体中自己调用自己. //注意: 可以解决所有文件夹和递归相结合的题目 //2.遍历这个File对象,获取它下边的每个文件和文件夹对象 File[] files = src.listFiles(); //3.判断当前遍历到的File对象是文件还是文件夹 for (File file : files) &#123; //4.如果是文件,直接删除 if(file.isFile())&#123; file.delete(); &#125;else&#123; //5.如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 deleteDir(file);//参数一定要是src文件夹里面的文件夹File对象 &#125; &#125; //6.参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 src.delete(); &#125;&#125; 1.8File类练习三【应用】 案例需求 统计一个文件夹中每种文件的个数并打印 打印格式如下： txt:3个 doc:4个 jpg:6个 … 实现步骤 定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 遍历File对象,获取它下边的每一个文件和文件夹对象 判断当前File对象是文件还是文件夹 如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 没出现过,将这种类型文件的后缀名存入集合中,次数存1 出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Test3 &#123; public static void main(String[] args) &#123; //统计一个文件夹中,每种文件出现的次数. //统计 --- 定义一个变量用来统计. ---- 弊端:同时只能统计一种文件 //利用map集合进行数据统计,键 --- 文件后缀名 值 ---- 次数 File file = new File(&quot;filemodule&quot;); HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;(); getCount(hm, file); System.out.println(hm); &#125; //1.定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 private static void getCount(HashMap&lt;String, Integer&gt; hm, File file) &#123; //2.遍历File对象,获取它下边的每一个文件和文件夹对象 File[] files = file.listFiles(); for (File f : files) &#123; //3.判断当前File对象是文件还是文件夹 if(f.isFile())&#123; //如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 String fileName = f.getName(); String[] fileNameArr = fileName.split(&quot;\\\\.&quot;); if(fileNameArr.length == 2)&#123; String fileEndName = fileNameArr[1]; if(hm.containsKey(fileEndName))&#123; //出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 Integer count = hm.get(fileEndName); //这种文件又出现了一次. count++; //把已经出现的次数给覆盖掉. hm.put(fileEndName,count); &#125;else&#123; // 没出现过,将这种类型文件的后缀名存入集合中,次数存1 hm.put(fileEndName,1); &#125; &#125; &#125;else&#123; //如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象代码实现 getCount(hm,f); &#125; &#125; &#125; &#125; 2.字节流 2.1 IO流概述和分类【理解】 IO流介绍 IO：输入/输出(Input/Output) 流：是一种抽象概念,是对数据传输的总称.也就是说数据在设备间的传输称为流,流的本质是数据传输 IO流就是用来处理设备间数据传输问题的.常见的应用: 文件复制; 文件上传; 文件下载 IO流的分类 按照数据的流向 输入流：读数据 输出流：写数据 按照数据类型来分 字节流 字节输入流 字节输出流 字符流 字符输入流 字符输出流 IO流的使用场景 如果操作的是纯文本文件,优先使用字符流 如果操作的是图片、视频、音频等二进制文件,优先使用字节流 如果不确定文件类型,优先使用字节流.字节流是万能的流 2.2字节流写数据【应用】 字节流抽象基类 InputStream：这个抽象类是表示字节输入流的所有类的超类 OutputStream：这个抽象类是表示字节输出流的所有类的超类 子类名特点：子类名称都是以其父类名作为子类名的后缀 字节输出流 FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 使用字节输出流写数据的步骤 创建字节输出流对象(调用系统功能创建了文件,创建字节输出流对象,让字节输出流对象指向文件) 调用字节输出流对象的写数据方法 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源) 示例代码 123456789101112131415161718192021public class FileOutputStreamDemo01 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输出流对象 /* 注意点: 1.如果文件不存在,会帮我们创建 2.如果文件存在,会把文件清空 */ //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(&quot;myByteStream\\\\fos.txt&quot;); //void write(int b)：将指定的字节写入此文件输出流 fos.write(97);// fos.write(57);// fos.write(55); //最后都要释放资源 //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。 fos.close(); &#125;&#125; 2.3字节流写数据的三种方式【应用】 写数据的方法分类 方法名 说明 void write(int b) 将指定的字节写入此文件输出流 一次写一个字节数据 void write(byte[] b) 将 b.length字节从指定的字节数组写入此文件输出流 一次写一个字节数组数据 void write(byte[] b, int off, int len) 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 一次写一个字节数组的部分数据 示例代码 12345678910111213141516171819202122232425262728public class FileOutputStreamDemo02 &#123; public static void main(String[] args) throws IOException &#123; //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(&quot;myByteStream\\\\fos.txt&quot;); //FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件// FileOutputStream fos = new FileOutputStream(new File(&quot;myByteStream\\\\fos.txt&quot;)); //void write(int b)：将指定的字节写入此文件输出流// fos.write(97);// fos.write(98);// fos.write(99);// fos.write(100);// fos.write(101);// void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流// byte[] bys = &#123;97, 98, 99, 100, 101&#125;; //byte[] getBytes()：返回字符串对应的字节数组 byte[] bys = &quot;abcde&quot;.getBytes();// fos.write(bys); //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流// fos.write(bys,0,bys.length); fos.write(bys,1,3); //释放资源 fos.close(); &#125;&#125; 2.4字节流写数据的两个小问题【应用】 字节流写数据如何实现换行 windows:\\r\\n linux:\\n mac:\\r 字节流写数据如何实现追加写入 public FileOutputStream(String name,boolean append) 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头 示例代码 12345678910111213141516public class FileOutputStreamDemo03 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输出流对象// FileOutputStream fos = new FileOutputStream(&quot;myByteStream\\\\fos.txt&quot;); FileOutputStream fos = new FileOutputStream(&quot;myByteStream\\\\fos.txt&quot;,true); //写数据 for (int i = 0; i &lt; 10; i++) &#123; fos.write(&quot;hello&quot;.getBytes()); fos.write(&quot;\\r\\n&quot;.getBytes()); &#125; //释放资源 fos.close(); &#125;&#125; 2.5字节流写数据加异常处理【应用】 异常处理格式 try-catch-finally 1234567try&#123; 可能出现异常的代码;&#125;catch(异常类名 变量名)&#123; 异常的处理代码;&#125;finally&#123; 执行所有清除操作;&#125; finally特点 被finally控制的语句一定会执行，除非JVM退出 示例代码 1234567891011121314151617181920public class FileOutputStreamDemo04 &#123; public static void main(String[] args) &#123; //加入finally来实现释放资源 FileOutputStream fos = null; try &#123; fos = new FileOutputStream(&quot;myByteStream\\\\fos.txt&quot;); fos.write(&quot;hello&quot;.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 2.6字节流读数据(一次读一个字节数据)【应用】 字节输入流 FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream,该文件由文件系统中的路径名name命名 字节输入流读取数据的步骤 创建字节输入流对象 调用字节输入流对象的读数据方法 释放资源 示例代码 1234567891011121314151617181920public class FileInputStreamDemo01 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输入流对象 //FileInputStream(String name) FileInputStream fis = new FileInputStream(&quot;myByteStream\\\\fos.txt&quot;); int by; /* fis.read()：读数据 by=fis.read()：把读取到的数据赋值给by by != -1：判断读取到的数据是否是-1 */ while ((by=fis.read())!=-1) &#123; System.out.print((char)by); &#125; //释放资源 fis.close(); &#125;&#125; 2.7字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt” (文件可以是任意文件) 实现步骤 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地) 数据源： ​ E:\\itcast\\窗里窗外.txt — 读数据 — InputStream — FileInputStream 目的地： ​ myByteStream\\窗里窗外.txt — 写数据 — OutputStream — FileOutputStream 代码实现 123456789101112131415161718public class CopyTxtDemo &#123; public static void main(String[] args) throws IOException &#123; //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(&quot;E:\\\\itcast\\\\窗里窗外.txt&quot;); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(&quot;myByteStream\\\\窗里窗外.txt&quot;); //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节) int by; while ((by=fis.read())!=-1) &#123; fos.write(by); &#125; //释放资源 fos.close(); fis.close(); &#125;&#125; 2.8字节流读数据(一次读一个字节数组数据)【应用】 一次读一个字节数组的方法 public int read(byte[] b)：从输入流读取最多b.length个字节的数据 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数 示例代码 12345678910111213141516public class FileInputStreamDemo02 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输入流对象 FileInputStream fis = new FileInputStream(&quot;myByteStream\\\\fos.txt&quot;); byte[] bys = new byte[1024]; //1024及其整数倍 int len; //循环读取 while ((len=fis.read(bys))!=-1) &#123; System.out.print(new String(bys,0,len)); &#125; //释放资源 fis.close(); &#125;&#125; 2.9字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\mn.jpg”复制到模块目录下的“mn.jpg” (文件可以是任意文件去) 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) 释放资源 代码实现 12345678910111213141516171819public class CopyJpgDemo &#123; public static void main(String[] args) throws IOException &#123; //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(&quot;E:\\\\itcast\\\\mn.jpg&quot;); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(&quot;myByteStream\\\\mn.jpg&quot;); //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) byte[] bys = new byte[1024]; int len; while ((len=fis.read(bys))!=-1) &#123; fos.write(bys,0,len); &#125; //释放资源 fos.close(); fis.close(); &#125;&#125; 3.字节缓冲流 3.1字节缓冲流构造方法【应用】 字节缓冲流介绍 lBufferOutputStream：该类实现缓冲输出流.通过设置这样的输出流,应用程序可以向底层输出流写入字节,而不必为写入的每个字节导致底层系统的调用 lBufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组.当从流中读取或跳过字节时,内部缓冲区将根据需要从所包含的输入流中重新填充,一次很多字节 构造方法： 方法名 说明 BufferedOutputStream(OutputStream out) 创建字节缓冲输出流对象 BufferedInputStream(InputStream in) 创建字节缓冲输入流对象 示例代码 1234567891011121314151617181920212223242526272829303132public class BufferStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //字节缓冲输出流：BufferedOutputStream(OutputStream out) BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;myByteStream\\\\bos.txt&quot;)); //写数据 bos.write(&quot;hello\\r\\n&quot;.getBytes()); bos.write(&quot;world\\r\\n&quot;.getBytes()); //释放资源 bos.close(); //字节缓冲输入流：BufferedInputStream(InputStream in) BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;myByteStream\\\\bos.txt&quot;)); //一次读取一个字节数据// int by;// while ((by=bis.read())!=-1) &#123;// System.out.print((char)by);// &#125; //一次读取一个字节数组数据 byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) &#123; System.out.print(new String(bys,0,len)); &#125; //释放资源 bis.close(); &#125;&#125; 3.2字节缓冲流复制视频【应用】 案例需求 把“E:\\itcast\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi” 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制视频 释放资源 代码实现 123456789101112131415161718192021222324252627282930313233343536373839public class CopyAviDemo &#123; public static void main(String[] args) throws IOException &#123; //复制视频// method1(); method2(); &#125; //字节缓冲流一次读写一个字节数组 public static void method2() throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;E:\\\\itcast\\\\字节流复制图片.avi&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;myByteStream\\\\字节流复制图片.avi&quot;)); byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) &#123; bos.write(bys,0,len); &#125; bos.close(); bis.close(); &#125; //字节缓冲流一次读写一个字节 public static void method1() throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;E:\\\\itcast\\\\字节流复制图片.avi&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;myByteStream\\\\字节流复制图片.avi&quot;)); int by; while ((by=bis.read())!=-1) &#123; bos.write(by); &#125; bos.close(); bis.close(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"集合04","slug":"集合04","date":"2021-09-18T11:59:00.000Z","updated":"2021-09-18T11:59:00.000Z","comments":true,"path":"2021/09/18/集合04/","link":"","permalink":"https://hujiahao.top/2021/09/18/%E9%9B%86%E5%90%8804/","excerpt":"","text":"1.可变参数1.1可变参数【应用】 可变参数介绍 可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了 方法的参数类型已经确定,个数不确定,我们可以使用可变参数 可变参数定义格式 1修饰符 返回值类型 方法名(数据类型… 变量名) &#123; &#125; 可变参数的注意事项 这里的变量其实是一个数组 如果一个方法有多个参数，包含可变参数，可变参数要放在最后 可变参数的基本使用 123456789101112131415161718192021222324public class ArgsDemo01 &#123; public static void main(String[] args) &#123; System.out.println(sum(10, 20)); System.out.println(sum(10, 20, 30)); System.out.println(sum(10, 20, 30, 40)); System.out.println(sum(10,20,30,40,50)); System.out.println(sum(10,20,30,40,50,60)); System.out.println(sum(10,20,30,40,50,60,70)); System.out.println(sum(10,20,30,40,50,60,70,80,90,100)); &#125;// public static int sum(int b,int... a) &#123;// return 0;// &#125; public static int sum(int... a) &#123; int sum = 0; for(int i : a) &#123; sum += i; &#125; return sum; &#125;&#125; 1.2创建不可变集合【理解】 方法介绍 在List、Set、Map接口中,都存在of方法,可以创建一个不可变的集合 这个集合不能添加,不能删除,不能修改 但是可以结合集合的带参构造,实现集合的批量添加 在Map接口中,还有一个ofEntries方法可以提高代码的阅读性 首先会把键值对封装成一个Entry对象,再把这个Entry对象添加到集合当中 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MyVariableParameter4 &#123; public static void main(String[] args) &#123; // static &lt;E&gt; List&lt;E&gt; of(E…elements) 创建一个具有指定元素的List集合对象 //static &lt;E&gt; Set&lt;E&gt; of(E…elements) 创建一个具有指定元素的Set集合对象 //static &lt;K , V&gt; Map&lt;K，V&gt; of(E…elements) 创建一个具有指定元素的Map集合对象 //method1(); //method2(); //method3(); //method4(); &#125; private static void method4() &#123; Map&lt;String, String&gt; map = Map.ofEntries( Map.entry(&quot;zhangsan&quot;, &quot;江苏&quot;), Map.entry(&quot;lisi&quot;, &quot;北京&quot;)); System.out.println(map); &#125; private static void method3() &#123; Map&lt;String, String&gt; map = Map.of(&quot;zhangsan&quot;, &quot;江苏&quot;, &quot;lisi&quot;, &quot;北京&quot;, &quot;wangwu&quot;, &quot;天津&quot;); System.out.println(map); &#125; private static void method2() &#123; //传递的参数当中，不能存在重复的元素。 Set&lt;String&gt; set = Set.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;,&quot;a&quot;); System.out.println(set); &#125; private static void method1() &#123; List&lt;String&gt; list = List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;); System.out.println(list); //list.add(&quot;Q&quot;); //list.remove(&quot;a&quot;); //list.set(0,&quot;A&quot;); //System.out.println(list);// ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();// list2.add(&quot;aaa&quot;);// list2.add(&quot;aaa&quot;);// list2.add(&quot;aaa&quot;);// list2.add(&quot;aaa&quot;); //集合的批量添加。 //首先是通过调用List.of方法来创建一个不可变的集合，of方法的形参就是一个可变参数。 //再创建一个ArrayList集合，并把这个不可变的集合中所有的数据，都添加到ArrayList中。 ArrayList&lt;String&gt; list3 = new ArrayList&lt;&gt;(List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)); System.out.println(list3); &#125;&#125; 2.Stream流 2.1体验Stream流【理解】 案例需求 按照下面的要求完成集合的创建和遍历 创建一个集合，存储多个字符串元素 把集合中所有以”张”开头的元素存储到一个新的集合 把”张”开头的集合中的长度为3的元素存储到一个新的集合 遍历上一步得到的集合 原始方式示例代码 12345678910111213141516171819202122232425public class MyStream1 &#123; public static void main(String[] args) &#123; //集合的批量添加 ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(List.of(&quot;张三丰&quot;,&quot;张无忌&quot;,&quot;张翠山&quot;,&quot;王二麻子&quot;,&quot;张良&quot;,&quot;谢广坤&quot;)); //list.add() //遍历list1把以张开头的元素添加到list2中。 ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); for (String s : list1) &#123; if(s.startsWith(&quot;张&quot;))&#123; list2.add(s); &#125; &#125; //遍历list2集合，把其中长度为3的元素，再添加到list3中。 ArrayList&lt;String&gt; list3 = new ArrayList&lt;&gt;(); for (String s : list2) &#123; if(s.length() == 3)&#123; list3.add(s); &#125; &#125; for (String s : list3) &#123; System.out.println(s); &#125; &#125;&#125; 使用Stream流示例代码 1234567891011public class StreamDemo &#123; public static void main(String[] args) &#123; //集合的批量添加 ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(List.of(&quot;张三丰&quot;,&quot;张无忌&quot;,&quot;张翠山&quot;,&quot;王二麻子&quot;,&quot;张良&quot;,&quot;谢广坤&quot;)); //Stream流 list1.stream().filter(s-&gt;s.startsWith(&quot;张&quot;)) .filter(s-&gt;s.length() == 3) .forEach(s-&gt; System.out.println(s)); &#125;&#125; Stream流的好处 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印 Stream流把真正的函数式编程风格引入到Java中 代码简洁 2.2Stream流的常见生成方式【应用】 Stream流的思想 Stream流的三类方法 获取Stream流 创建一条流水线,并把数据放到流水线上准备进行操作 中间方法 流水线上的操作 一次操作完毕之后,还可以继续进行其他操作 终结方法 一个Stream流只能有一个终结方法 是流水线上的最后一个操作 生成Stream流的方式 Collection体系集合 使用默认方法stream()生成流， default Stream stream() Map体系集合 把Map转成Set集合，间接的生成流 数组 通过Arrays中的静态方法stream生成流 同种数据类型的多个数据 通过Stream接口的静态方法of(T… values)生成流 代码演示 123456789101112131415161718192021222324public class StreamDemo &#123; public static void main(String[] args) &#123; //Collection体系的集合可以使用默认方法stream()生成流 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Stream&lt;String&gt; listStream = list.stream(); Set&lt;String&gt; set = new HashSet&lt;String&gt;(); Stream&lt;String&gt; setStream = set.stream(); //Map体系的集合间接的生成流 Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;Integer&gt; valueStream = map.values().stream(); Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; entryStream = map.entrySet().stream(); //数组可以通过Arrays中的静态方法stream生成流 String[] strArray = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;; Stream&lt;String&gt; strArrayStream = Arrays.stream(strArray); //同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流 Stream&lt;String&gt; strArrayStream2 = Stream.of(&quot;hello&quot;, &quot;world&quot;, &quot;java&quot;); Stream&lt;Integer&gt; intStream = Stream.of(10, 20, 30); &#125;&#125; 2.3Stream流中间操作方法【应用】 概念 中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作 常见方法 方法名 说明 Stream filter(Predicate predicate) 用于对流中的数据进行过滤 Stream limit(long maxSize) 返回此流中的元素组成的流，截取前指定参数个数的数据 Stream skip(long n) 跳过指定参数个数的数据，返回由该流的剩余元素组成的流 static Stream concat(Stream a, Stream b) 合并a和b两个流为一个流 Stream distinct() 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 filter代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyStream3 &#123; public static void main(String[] args) &#123;// Stream&lt;T&gt; filter(Predicate predicate)：过滤// Predicate接口中的方法 boolean test(T t)：对给定的参数进行判断，返回一个布尔值 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;张三丰&quot;); list.add(&quot;张无忌&quot;); list.add(&quot;张翠山&quot;); list.add(&quot;王二麻子&quot;); list.add(&quot;张良&quot;); list.add(&quot;谢广坤&quot;); //filter方法获取流中的 每一个数据. //而test方法中的s,就依次表示流中的每一个数据. //我们只要在test方法中对s进行判断就可以了. //如果判断的结果为true,则当前的数据留下 //如果判断的结果为false,则当前数据就不要.// list.stream().filter(// new Predicate&lt;String&gt;() &#123;// @Override// public boolean test(String s) &#123;// boolean result = s.startsWith(&quot;张&quot;);// return result;// &#125;// &#125;// ).forEach(s-&gt; System.out.println(s)); //因为Predicate接口中只有一个抽象方法test //所以我们可以使用lambda表达式来简化// list.stream().filter(// (String s)-&gt;&#123;// boolean result = s.startsWith(&quot;张&quot;);// return result;// &#125;// ).forEach(s-&gt; System.out.println(s)); list.stream().filter(s -&gt;s.startsWith(&quot;张&quot;)).forEach(s-&gt; System.out.println(s)); &#125;&#125; limit&amp;skip代码演示 123456789101112131415161718192021222324public class StreamDemo02 &#123; public static void main(String[] args) &#123; //创建一个集合，存储多个字符串元素 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;林青霞&quot;); list.add(&quot;张曼玉&quot;); list.add(&quot;王祖贤&quot;); list.add(&quot;柳岩&quot;); list.add(&quot;张敏&quot;); list.add(&quot;张无忌&quot;); //需求1：取前3个数据在控制台输出 list.stream().limit(3).forEach(s-&gt; System.out.println(s)); System.out.println(&quot;--------&quot;); //需求2：跳过3个元素，把剩下的元素在控制台输出 list.stream().skip(3).forEach(s-&gt; System.out.println(s)); System.out.println(&quot;--------&quot;); //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出 list.stream().skip(2).limit(2).forEach(s-&gt; System.out.println(s)); &#125;&#125; concat&amp;distinct代码演示 12345678910111213141516171819202122232425public class StreamDemo03 &#123; public static void main(String[] args) &#123; //创建一个集合，存储多个字符串元素 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;林青霞&quot;); list.add(&quot;张曼玉&quot;); list.add(&quot;王祖贤&quot;); list.add(&quot;柳岩&quot;); list.add(&quot;张敏&quot;); list.add(&quot;张无忌&quot;); //需求1：取前4个数据组成一个流 Stream&lt;String&gt; s1 = list.stream().limit(4); //需求2：跳过2个数据组成一个流 Stream&lt;String&gt; s2 = list.stream().skip(2); //需求3：合并需求1和需求2得到的流，并把结果在控制台输出// Stream.concat(s1,s2).forEach(s-&gt; System.out.println(s)); //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复 Stream.concat(s1,s2).distinct().forEach(s-&gt; System.out.println(s)); &#125;&#125; 2.4Stream流终结操作方法【应用】 概念 终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作 常见方法 方法名 说明 void forEach(Consumer action) 对此流的每个元素执行操作 long count() 返回此流中的元素数 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MyStream5 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;张三丰&quot;); list.add(&quot;张无忌&quot;); list.add(&quot;张翠山&quot;); list.add(&quot;王二麻子&quot;); list.add(&quot;张良&quot;); list.add(&quot;谢广坤&quot;); //method1(list); // long count()：返回此流中的元素数 long count = list.stream().count(); System.out.println(count); &#125; private static void method1(ArrayList&lt;String&gt; list) &#123; // void forEach(Consumer action)：对此流的每个元素执行操作 // Consumer接口中的方法void accept(T t)：对给定的参数执行此操作 //在forEach方法的底层,会循环获取到流中的每一个数据. //并循环调用accept方法,并把每一个数据传递给accept方法 //s就依次表示了流中的每一个数据. //所以,我们只要在accept方法中,写上处理的业务逻辑就可以了. list.stream().forEach( new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125; ); System.out.println(&quot;====================&quot;); //lambda表达式的简化格式 //是因为Consumer接口中,只有一个accept方法 list.stream().forEach( (String s)-&gt;&#123; System.out.println(s); &#125; ); System.out.println(&quot;====================&quot;); //lambda表达式还是可以进一步简化的. list.stream().forEach(s-&gt;System.out.println(s)); &#125;&#125; 2.5Stream流的收集操作【应用】 概念 对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中 常用方法 方法名 说明 R collect(Collector collector) 把结果收集到集合中 工具类Collectors提供了具体的收集方式 方法名 说明 public static Collector toList() 把元素收集到List集合中 public static Collector toSet() 把元素收集到Set集合中 public static Collector toMap(Function keyMapper,Function valueMapper) 把元素收集到Map集合中 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// toList和toSet方法演示 public class MyStream7 &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; list1.add(i); &#125; list1.add(10); list1.add(10); list1.add(10); list1.add(10); list1.add(10); //filter负责过滤数据的. //collect负责收集数据. //获取流中剩余的数据,但是他不负责创建容器,也不负责把数据添加到容器中. //Collectors.toList() : 在底层会创建一个List集合.并把所有的数据添加到List集合中. List&lt;Integer&gt; list = list1.stream().filter(number -&gt; number % 2 == 0) .collect(Collectors.toList()); System.out.println(list); Set&lt;Integer&gt; set = list1.stream().filter(number -&gt; number % 2 == 0) .collect(Collectors.toSet()); System.out.println(set);&#125;&#125;/**Stream流的收集方法 toMap方法演示创建一个ArrayList集合，并添加以下字符串。字符串中前面是姓名，后面是年龄&quot;zhangsan,23&quot;&quot;lisi,24&quot;&quot;wangwu,25&quot;保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值*/public class MyStream8 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;zhangsan,23&quot;); list.add(&quot;lisi,24&quot;); list.add(&quot;wangwu,25&quot;); Map&lt;String, Integer&gt; map = list.stream().filter( s -&gt; &#123; String[] split = s.split(&quot;,&quot;); int age = Integer.parseInt(split[1]); return age &gt;= 24; &#125; // collect方法只能获取到流中剩余的每一个数据. //在底层不能创建容器,也不能把数据添加到容器当中 //Collectors.toMap 创建一个map集合并将数据添加到集合当中 // s 依次表示流中的每一个数据 //第一个lambda表达式就是如何获取到Map中的键 //第二个lambda表达式就是如何获取Map中的值 ).collect(Collectors.toMap( s -&gt; s.split(&quot;,&quot;)[0], s -&gt; Integer.parseInt(s.split(&quot;,&quot;)[1]) )); System.out.println(map); &#125;&#125; 5.6Stream流综合练习【应用】 案例需求 现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作 男演员只要名字为3个字的前三人 女演员只要姓林的，并且不要第一个 把过滤后的男演员姓名和女演员姓名合并到一起 把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据 演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法 代码实现 演员类 123456789101112131415public class Actor &#123; private String name; public Actor(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435public class StreamTest &#123; public static void main(String[] args) &#123; //创建集合 ArrayList&lt;String&gt; manList = new ArrayList&lt;String&gt;(); manList.add(&quot;周润发&quot;); manList.add(&quot;成龙&quot;); manList.add(&quot;刘德华&quot;); manList.add(&quot;吴京&quot;); manList.add(&quot;周星驰&quot;); manList.add(&quot;李连杰&quot;); ArrayList&lt;String&gt; womanList = new ArrayList&lt;String&gt;(); womanList.add(&quot;林心如&quot;); womanList.add(&quot;张曼玉&quot;); womanList.add(&quot;林青霞&quot;); womanList.add(&quot;柳岩&quot;); womanList.add(&quot;林志玲&quot;); womanList.add(&quot;王祖贤&quot;); //男演员只要名字为3个字的前三人 Stream&lt;String&gt; manStream = manList.stream().filter(s -&gt; s.length() == 3).limit(3); //女演员只要姓林的，并且不要第一个 Stream&lt;String&gt; womanStream = womanList.stream().filter(s -&gt; s.startsWith(&quot;林&quot;)).skip(1); //把过滤后的男演员姓名和女演员姓名合并到一起 Stream&lt;String&gt; stream = Stream.concat(manStream, womanStream); // 将流中的数据封装成Actor对象之后打印 stream.forEach(name -&gt; &#123; Actor actor = new Actor(name); System.out.println(actor); &#125;); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"集合03","slug":"集合03","date":"2021-09-17T11:59:00.000Z","updated":"2021-09-17T11:59:00.000Z","comments":true,"path":"2021/09/17/集合03/","link":"","permalink":"https://hujiahao.top/2021/09/17/%E9%9B%86%E5%90%8803/","excerpt":"","text":"1.红黑树1.1概述【理解】 红黑树的特点 平衡二叉B树 每一个节点可以是红或者黑 红黑树不是高度平衡的,它的平衡是通过”自己的红黑规则”进行实现的 红黑树的红黑规则有哪些 每一个节点或是红色的,或者是黑色的 根节点必须是黑色 如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况) 对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点 红黑树添加节点的默认颜色 添加节点时,默认为红色,效率高 红黑树添加节点后如何保持红黑规则 根节点位置 直接变为黑色 非根节点位置 父节点为黑色 不需要任何操作,默认红色即可 父节点为红色 叔叔节点为红色 将”父节点”设为黑色,将”叔叔节点”设为黑色 将”祖父节点”设为红色 如果”祖父节点”为根节点,则将根节点再次变成黑色 叔叔节点为黑色 将”父节点”设为黑色 将”祖父节点”设为红色 以”祖父节点”为支点进行旋转 1.2成绩排序案例【应用】 案例需求 用TreeSet集合存储多个学生信息(姓名,语文成绩,数学成绩,英语成绩),并遍历该集合 要求: 按照总分从高到低出现 代码实现 学生类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Student implements Comparable&lt;Student&gt; &#123; private String name; private int chinese; private int math; private int english; public Student() &#123; &#125; public Student(String name, int chinese, int math, int english) &#123; this.name = name; this.chinese = chinese; this.math = math; this.english = english; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getChinese() &#123; return chinese; &#125; public void setChinese(int chinese) &#123; this.chinese = chinese; &#125; public int getMath() &#123; return math; &#125; public void setMath(int math) &#123; this.math = math; &#125; public int getEnglish() &#123; return english; &#125; public void setEnglish(int english) &#123; this.english = english; &#125; public int getSum() &#123; return this.chinese + this.math + this.english; &#125; @Override public int compareTo(Student o) &#123; // 主要条件: 按照总分进行排序 int result = o.getSum() - this.getSum(); // 次要条件: 如果总分一样,就按照语文成绩排序 result = result == 0 ? o.getChinese() - this.getChinese() : result; // 如果语文成绩也一样,就按照数学成绩排序 result = result == 0 ? o.getMath() - this.getMath() : result; // 如果总分一样,各科成绩也都一样,就按照姓名排序 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; &#125;&#125; 测试类 12345678910111213141516171819public class TreeSetDemo &#123; public static void main(String[] args) &#123; //创建TreeSet集合对象，通过比较器排序进行排序 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(); //创建学生对象 Student s1 = new Student(&quot;jack&quot;, 98, 100, 95); Student s2 = new Student(&quot;rose&quot;, 95, 95, 95); Student s3 = new Student(&quot;sam&quot;, 100, 93, 98); //把学生对象添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); //遍历集合 for (Student s : ts) &#123; System.out.println(s.getName() + &quot;,&quot; + s.getChinese() + &quot;,&quot; + s.getMath() + &quot;,&quot; + s.getEnglish() + &quot;,&quot; + s.getSum()); &#125; &#125;&#125; 2.HashSet集合 2.1HashSet集合概述和特点【应用】 底层数据结构是哈希表 存取无序 不可以存储重复元素 没有索引,不能使用普通for循环遍历 2.2HashSet集合的基本应用【应用】存储字符串并遍历 123456789101112131415161718public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建集合对象 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add(&quot;hello&quot;); set.add(&quot;world&quot;); set.add(&quot;java&quot;); //不包含重复元素的集合 set.add(&quot;world&quot;); //遍历 for(String s : set) &#123; System.out.println(s); &#125; &#125;&#125; 2.3哈希值【理解】 哈希值简介 ​ 是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值 如何获取哈希值 ​ Object类中的public int hashCode()：返回对象的哈希码值 哈希值的特点 同一个对象多次调用hashCode()方法返回的哈希值是相同的 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同 2.4哈希表结构【理解】 JDK1.8以前 ​ 数组 + 链表 JDK1.8以后 节点个数少于等于8个 ​ 数组 + 链表 节点个数多于8个 ​ 数组 + 红黑树 2.5HashSet集合存储学生对象并遍历【应用】 案例需求 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合 要求：学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125;&#125; 测试类 123456789101112131415161718192021222324public class HashSetDemo02 &#123; public static void main(String[] args) &#123; //创建HashSet集合对象 HashSet&lt;Student&gt; hs = new HashSet&lt;Student&gt;(); //创建学生对象 Student s1 = new Student(&quot;林青霞&quot;, 30); Student s2 = new Student(&quot;张曼玉&quot;, 35); Student s3 = new Student(&quot;王祖贤&quot;, 33); Student s4 = new Student(&quot;王祖贤&quot;, 33); //把学生添加到集合 hs.add(s1); hs.add(s2); hs.add(s3); hs.add(s4); //遍历集合(增强for) for (Student s : hs) &#123; System.out.println(s.getName() + &quot;,&quot; + s.getAge()); &#125; &#125;&#125; 总结 ​ HashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法 3.Map集合3.1Map集合概述和特点【理解】 Map集合概述 1interface Map&lt;K,V&gt; K：键的类型；V：值的类型 Map集合的特点 双列集合,一个键对应一个值 键不可以重复,值可以重复 Map集合的基本使用 123456789101112131415public class MapDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //V put(K key, V value) 将指定的值与该映射中的指定键相关联 map.put(&quot;itheima001&quot;,&quot;林青霞&quot;); map.put(&quot;itheima002&quot;,&quot;张曼玉&quot;); map.put(&quot;itheima003&quot;,&quot;王祖贤&quot;); map.put(&quot;itheima003&quot;,&quot;柳岩&quot;); //输出集合对象 System.out.println(map); &#125;&#125; 3.2Map集合的基本功能【应用】 方法介绍 方法名 说明 V put(K key,V value) 添加元素 V remove(Object key) 根据键删除键值对元素 void clear() 移除所有的键值对元素 boolean containsKey(Object key) 判断集合是否包含指定的键 boolean containsValue(Object value) 判断集合是否包含指定的值 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中键值对的个数 示例代码 12345678910111213141516171819202122232425262728293031public class MapDemo02 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //V put(K key,V value)：添加元素 map.put(&quot;张无忌&quot;,&quot;赵敏&quot;); map.put(&quot;郭靖&quot;,&quot;黄蓉&quot;); map.put(&quot;杨过&quot;,&quot;小龙女&quot;); //V remove(Object key)：根据键删除键值对元素// System.out.println(map.remove(&quot;郭靖&quot;));// System.out.println(map.remove(&quot;郭襄&quot;)); //void clear()：移除所有的键值对元素// map.clear(); //boolean containsKey(Object key)：判断集合是否包含指定的键// System.out.println(map.containsKey(&quot;郭靖&quot;));// System.out.println(map.containsKey(&quot;郭襄&quot;)); //boolean isEmpty()：判断集合是否为空// System.out.println(map.isEmpty()); //int size()：集合的长度，也就是集合中键值对的个数 System.out.println(map.size()); //输出集合对象 System.out.println(map); &#125;&#125; 3.3Map集合的获取功能【应用】 方法介绍 方法名 说明 V get(Object key) 根据键获取值 Set keySet() 获取所有键的集合 Collection values() 获取所有值的集合 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 获取所有键值对对象的集合 示例代码 123456789101112131415161718192021222324252627public class MapDemo03 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素 map.put(&quot;张无忌&quot;, &quot;赵敏&quot;); map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;); map.put(&quot;杨过&quot;, &quot;小龙女&quot;); //V get(Object key):根据键获取值// System.out.println(map.get(&quot;张无忌&quot;));// System.out.println(map.get(&quot;张三丰&quot;)); //Set&lt;K&gt; keySet():获取所有键的集合// Set&lt;String&gt; keySet = map.keySet();// for(String key : keySet) &#123;// System.out.println(key);// &#125; //Collection&lt;V&gt; values():获取所有值的集合 Collection&lt;String&gt; values = map.values(); for(String value : values) &#123; System.out.println(value); &#125; &#125;&#125; 3.4Map集合的遍历(方式1)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 把所有的丈夫给集中起来 遍历丈夫的集合，获取到每一个丈夫 根据丈夫去找对应的妻子 步骤分析 获取所有键的集合。用keySet()方法实现 遍历键的集合，获取到每一个键。用增强for实现 根据键去找值。用get(Object key)方法实现 代码实现 1234567891011121314151617181920public class MapDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素 map.put(&quot;张无忌&quot;, &quot;赵敏&quot;); map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;); map.put(&quot;杨过&quot;, &quot;小龙女&quot;); //获取所有键的集合。用keySet()方法实现 Set&lt;String&gt; keySet = map.keySet(); //遍历键的集合，获取到每一个键。用增强for实现 for (String key : keySet) &#123; //根据键去找值。用get(Object key)方法实现 String value = map.get(key); System.out.println(key + &quot;,&quot; + value); &#125; &#125;&#125; 3.5Map集合的遍历(方式2)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 获取所有结婚证的集合 遍历结婚证的集合，得到每一个结婚证 根据结婚证获取丈夫和妻子 步骤分析 获取所有键值对对象的集合 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：获取所有键值对对象的集合 遍历键值对对象的集合，得到每一个键值对对象 用增强for实现，得到每一个Map.Entry 根据键值对对象获取键和值 用getKey()得到键 用getValue()得到值 代码实现 123456789101112131415161718192021public class MapDemo02 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素 map.put(&quot;张无忌&quot;, &quot;赵敏&quot;); map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;); map.put(&quot;杨过&quot;, &quot;小龙女&quot;); //获取所有键值对对象的集合 Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); //遍历键值对对象的集合，得到每一个键值对对象 for (Map.Entry&lt;String, String&gt; me : entrySet) &#123; //根据键值对对象获取键和值 String key = me.getKey(); String value = me.getValue(); System.out.println(key + &quot;,&quot; + value); &#125; &#125;&#125; 4.HashMap集合 4.1HashMap集合概述和特点【理解】 HashMap底层是哈希表结构的 依赖hashCode方法和equals方法保证键的唯一 如果键要存储的是自定义对象，需要重写hashCode和equals方法 4.2HashMap集合应用案例【应用】 案例需求 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125;&#125; 测试类 12345678910111213141516171819202122232425public class HashMapDemo &#123; public static void main(String[] args) &#123; //创建HashMap集合对象 HashMap&lt;Student, String&gt; hm = new HashMap&lt;Student, String&gt;(); //创建学生对象 Student s1 = new Student(&quot;林青霞&quot;, 30); Student s2 = new Student(&quot;张曼玉&quot;, 35); Student s3 = new Student(&quot;王祖贤&quot;, 33); Student s4 = new Student(&quot;王祖贤&quot;, 33); //把学生添加到集合 hm.put(s1, &quot;西安&quot;); hm.put(s2, &quot;武汉&quot;); hm.put(s3, &quot;郑州&quot;); hm.put(s4, &quot;北京&quot;); //遍历集合 Set&lt;Student&gt; keySet = hm.keySet(); for (Student key : keySet) &#123; String value = hm.get(key); System.out.println(key.getName() + &quot;,&quot; + key.getAge() + &quot;,&quot; + value); &#125; &#125;&#125; 5.TreeMap集合 5.1TreeMap集合概述和特点【理解】 TreeMap底层是红黑树结构 依赖自然排序或者比较器排序,对键进行排序 如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则 5.2TreeMap集合应用案例【应用】 案例需求 创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历 要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序 代码实现 学生类 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public int compareTo(Student o) &#123; //按照年龄进行排序 int result = o.getAge() - this.getAge(); //次要条件，按照姓名排序。 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; &#125;&#125; 测试类 1234567891011121314151617181920212223public class Test1 &#123; public static void main(String[] args) &#123; // 创建TreeMap集合对象 TreeMap&lt;Student,String&gt; tm = new TreeMap&lt;&gt;(); // 创建学生对象 Student s1 = new Student(&quot;xiaohei&quot;,23); Student s2 = new Student(&quot;dapang&quot;,22); Student s3 = new Student(&quot;xiaomei&quot;,22); // 将学生对象添加到TreeMap集合中 tm.put(s1,&quot;江苏&quot;); tm.put(s2,&quot;北京&quot;); tm.put(s3,&quot;天津&quot;); // 遍历TreeMap集合,打印每个学生的信息 tm.forEach( (Student key, String value)-&gt;&#123; System.out.println(key + &quot;---&quot; + value); &#125; ); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"集合02","slug":"集合02","date":"2021-09-16T11:59:00.000Z","updated":"2021-09-16T11:59:00.000Z","comments":true,"path":"2021/09/16/集合02/","link":"","permalink":"https://hujiahao.top/2021/09/16/%E9%9B%86%E5%90%8802/","excerpt":"","text":"1.Set集合1.1Set集合概述和特点【应用】 不可以存储重复元素 没有索引,不能使用普通for循环遍历 1.2Set集合的使用【应用】存储字符串并遍历 1234567891011121314151617181920212223242526public class MySet1 &#123; public static void main(String[] args) &#123; //创建集合对象 Set&lt;String&gt; set = new TreeSet&lt;&gt;(); //添加元素 set.add(&quot;ccc&quot;); set.add(&quot;aaa&quot;); set.add(&quot;aaa&quot;); set.add(&quot;bbb&quot;);// for (int i = 0; i &lt; set.size(); i++) &#123;// //Set集合是没有索引的，所以不能使用通过索引获取元素的方法// &#125; //遍历集合 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; System.out.println(&quot;-----------------------------------&quot;); for (String s : set) &#123; System.out.println(s); &#125; &#125;&#125; 2.TreeSet集合2.1TreeSet集合概述和特点【应用】 不可以存储重复元素 没有索引 可以将元素按照规则进行排序 TreeSet()：根据其元素的自然排序进行排序 TreeSet(Comparator comparator) ：根据指定的比较器进行排序 2.2TreeSet集合基本使用【应用】存储Integer类型的整数并遍历 1234567891011121314151617181920public class TreeSetDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Integer&gt; ts = new TreeSet&lt;Integer&gt;(); //添加元素 ts.add(10); ts.add(40); ts.add(30); ts.add(50); ts.add(20); ts.add(30); //遍历集合 for(Integer i : ts) &#123; System.out.println(i); &#125; &#125;&#125; 2.3自然排序Comparable的使用【应用】 案例需求 存储学生对象并遍历，创建TreeSet集合使用无参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 使用空参构造创建TreeSet集合 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的 自定义的Student类实现Comparable接口 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法 重写接口中的compareTo方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public int compareTo(Student o) &#123; //按照对象的年龄进行排序 //主要判断条件: 按照年龄从小到大排序 int result = this.age - o.age; //次要判断条件: 年龄相同时，按照姓名的字母顺序排序 result = result == 0 ? this.name.compareTo(o.getName()) : result; return result; &#125;&#125; 测试类 12345678910111213141516171819202122public class MyTreeSet2 &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(); //创建学生对象 Student s1 = new Student(&quot;zhangsan&quot;,28); Student s2 = new Student(&quot;lisi&quot;,27); Student s3 = new Student(&quot;wangwu&quot;,29); Student s4 = new Student(&quot;zhaoliu&quot;,28); Student s5 = new Student(&quot;qianqi&quot;,30); //把学生添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); //遍历集合 for (Student student : ts) &#123; System.out.println(student); &#125; &#125;&#125; 2.4比较器排序Comparator的使用【应用】 案例需求 存储老师对象并遍历，创建TreeSet集合使用带参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 老师类 123456789101112131415161718192021222324252627282930313233343536public class Teacher &#123; private String name; private int age; public Teacher() &#123; &#125; public Teacher(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Teacher&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132public class MyTreeSet4 &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Teacher&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Teacher&gt;() &#123; @Override public int compare(Teacher o1, Teacher o2) &#123; //o1表示现在要存入的那个元素 //o2表示已经存入到集合中的元素 //主要条件 int result = o1.getAge() - o2.getAge(); //次要条件 result = result == 0 ? o1.getName().compareTo(o2.getName()) : result; return result; &#125; &#125;); //创建老师对象 Teacher t1 = new Teacher(&quot;zhangsan&quot;,23); Teacher t2 = new Teacher(&quot;lisi&quot;,22); Teacher t3 = new Teacher(&quot;wangwu&quot;,24); Teacher t4 = new Teacher(&quot;zhaoliu&quot;,24); //把老师添加到集合 ts.add(t1); ts.add(t2); ts.add(t3); ts.add(t4); //遍历集合 for (Teacher teacher : ts) &#123; System.out.println(teacher); &#125; &#125;&#125; 2.4两种比较方式总结【理解】 两种比较方式小结 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序 两种方式中关于返回值的规则 如果返回值为负数，表示当前存入的元素是较小值，存左边 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存 如果返回值为正数，表示当前存入的元素是较大值，存右边 3.数据结构3.1二叉树【理解】 二叉树的特点 二叉树中,任意一个节点的度要小于等于2 节点: 在树结构中,每一个元素称之为节点 度: 每一个节点的子节点数量称之为度 二叉树结构图 3.2二叉查找树【理解】 二叉查找树的特点 二叉查找树,又称二叉排序树或者二叉搜索树 每一个节点上最多有两个子节点 左子树上所有节点的值都小于根节点的值 右子树上所有节点的值都大于根节点的值 二叉查找树结构图 二叉查找树和二叉树对比结构图 二叉查找树添加节点规则 小的存左边 大的存右边 一样的不存 3.3平衡二叉树【理解】 平衡二叉树的特点 二叉树左右两个子树的高度差不超过1 任意节点的左右两个子树都是一颗平衡二叉树 平衡二叉树旋转 旋转触发时机 当添加一个节点之后,该树不再是一颗平衡二叉树 左旋 就是将根节点的右侧往左拉,原先的右子节点变成新的父节点,并把多余的左子节点出让,给已经降级的根节点当右子节点 右旋 就是将根节点的左侧往右拉,左子节点变成了新的父节点,并把多余的右子节点出让,给已经降级根节点当左子节点 平衡二叉树和二叉查找树对比结构图 平衡二叉树旋转的四种情况 左左 左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行右旋即可 左右 左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋 右右 右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行左旋即可 右左 右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋 3.4红黑树【理解】 红黑树的特点 平衡二叉B树 每一个节点可以是红或者黑 红黑树不是高度平衡的,它的平衡是通过”自己的红黑规则”进行实现的 红黑树的红黑规则有哪些 每一个节点或是红色的,或者是黑色的 根节点必须是黑色 如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况) 对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点 红黑树添加节点的默认颜色 添加节点时,默认为红色,效率高 红黑树添加节点后如何保持红黑规则 根节点位置 直接变为黑色 非根节点位置 父节点为黑色 不需要任何操作,默认红色即可 父节点为红色 叔叔节点为红色 将”父节点”设为黑色,将”叔叔节点”设为黑色 将”祖父节点”设为红色 如果”祖父节点”为根节点,则将根节点再次变成黑色 叔叔节点为黑色 将”父节点”设为黑色 将”祖父节点”设为红色 以”祖父节点”为支点进行旋转 3.5成绩排序案例【应用】 案例需求 用TreeSet集合存储多个学生信息(姓名,语文成绩,数学成绩,英语成绩),并遍历该集合 要求: 按照总分从高到低出现 代码实现 学生类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Student implements Comparable&lt;Student&gt; &#123; private String name; private int chinese; private int math; private int english; public Student() &#123; &#125; public Student(String name, int chinese, int math, int english) &#123; this.name = name; this.chinese = chinese; this.math = math; this.english = english; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getChinese() &#123; return chinese; &#125; public void setChinese(int chinese) &#123; this.chinese = chinese; &#125; public int getMath() &#123; return math; &#125; public void setMath(int math) &#123; this.math = math; &#125; public int getEnglish() &#123; return english; &#125; public void setEnglish(int english) &#123; this.english = english; &#125; public int getSum() &#123; return this.chinese + this.math + this.english; &#125; @Override public int compareTo(Student o) &#123; // 主要条件: 按照总分进行排序 int result = o.getSum() - this.getSum(); // 次要条件: 如果总分一样,就按照语文成绩排序 result = result == 0 ? o.getChinese() - this.getChinese() : result; // 如果语文成绩也一样,就按照数学成绩排序 result = result == 0 ? o.getMath() - this.getMath() : result; // 如果总分一样,各科成绩也都一样,就按照姓名排序 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; &#125;&#125; 测试类 12345678910111213141516171819public class TreeSetDemo &#123; public static void main(String[] args) &#123; //创建TreeSet集合对象，通过比较器排序进行排序 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(); //创建学生对象 Student s1 = new Student(&quot;jack&quot;, 98, 100, 95); Student s2 = new Student(&quot;rose&quot;, 95, 95, 95); Student s3 = new Student(&quot;sam&quot;, 100, 93, 98); //把学生对象添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); //遍历集合 for (Student s : ts) &#123; System.out.println(s.getName() + &quot;,&quot; + s.getChinese() + &quot;,&quot; + s.getMath() + &quot;,&quot; + s.getEnglish() + &quot;,&quot; + s.getSum()); &#125; &#125;&#125; 4.HashSet集合 4.1HashSet集合概述和特点【应用】 底层数据结构是哈希表 存取无序 不可以存储重复元素 没有索引,不能使用普通for循环遍历 4.2HashSet集合的基本应用【应用】存储字符串并遍历 123456789101112131415161718public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建集合对象 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add(&quot;hello&quot;); set.add(&quot;world&quot;); set.add(&quot;java&quot;); //不包含重复元素的集合 set.add(&quot;world&quot;); //遍历 for(String s : set) &#123; System.out.println(s); &#125; &#125;&#125; 4.3哈希值【理解】 哈希值简介 ​ 是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值 如何获取哈希值 ​ Object类中的public int hashCode()：返回对象的哈希码值 哈希值的特点 同一个对象多次调用hashCode()方法返回的哈希值是相同的 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同 4.4哈希表结构【理解】 JDK1.8以前 ​ 数组 + 链表 JDK1.8以后 节点个数少于等于8个 ​ 数组 + 链表 节点个数多于8个 ​ 数组 + 红黑树 4.5HashSet集合存储学生对象并遍历【应用】 案例需求 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合 要求：学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125;&#125; 测试类 123456789101112131415161718192021222324public class HashSetDemo02 &#123; public static void main(String[] args) &#123; //创建HashSet集合对象 HashSet&lt;Student&gt; hs = new HashSet&lt;Student&gt;(); //创建学生对象 Student s1 = new Student(&quot;林青霞&quot;, 30); Student s2 = new Student(&quot;张曼玉&quot;, 35); Student s3 = new Student(&quot;王祖贤&quot;, 33); Student s4 = new Student(&quot;王祖贤&quot;, 33); //把学生添加到集合 hs.add(s1); hs.add(s2); hs.add(s3); hs.add(s4); //遍历集合(增强for) for (Student s : hs) &#123; System.out.println(s.getName() + &quot;,&quot; + s.getAge()); &#125; &#125;&#125; 总结 ​ HashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"集合01","slug":"集合01","date":"2021-09-15T11:59:00.000Z","updated":"2021-09-15T11:59:00.000Z","comments":true,"path":"2021/09/15/集合01/","link":"","permalink":"https://hujiahao.top/2021/09/15/%E9%9B%86%E5%90%8801/","excerpt":"","text":"1.Collection集合1.1数组和集合的区别【理解】 相同点 都是容器,可以存储多个数据 不同点 数组的长度是不可变的,集合的长度是可变的 数组可以存基本数据类型和引用数据类型 集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类 1.2集合类体系结构【理解】 1.3Collection 集合概述和使用【应用】 Collection集合概述 是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素 JDK 不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现 创建Collection集合的对象 多态的方式 具体的实现类ArrayList Collection集合常用方法 方法名 说明 boolean add(E e) 添加元素 boolean remove(Object o) 从集合中移除指定的元素 boolean removeIf(Object o) 根据条件进行移除 void clear() 清空集合中的元素 boolean contains(Object o) 判断集合中是否存在指定的元素 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中元素的个数 1.4Collection集合的遍历【应用】 迭代器介绍 迭代器,集合的专用遍历方式 Iterator iterator(): 返回此集合中元素的迭代器,通过集合对象的iterator()方法得到 Iterator中的常用方法 ​ boolean hasNext(): 判断当前位置是否有元素可以被取出​ E next(): 获取当前位置的元素,将迭代器对象移向下一个索引位置 Collection集合的遍历 123456789101112131415161718192021public class IteratorDemo1 &#123; public static void main(String[] args) &#123; //创建集合对象 Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); //添加元素 c.add(&quot;hello&quot;); c.add(&quot;world&quot;); c.add(&quot;java&quot;); c.add(&quot;javaee&quot;); //Iterator&lt;E&gt; iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到 Iterator&lt;String&gt; it = c.iterator(); //用while循环改进元素的判断和获取 while (it.hasNext()) &#123; String s = it.next(); System.out.println(s); &#125; &#125;&#125; 迭代器中删除的方法 ​ void remove(): 删除迭代器对象当前指向的元素 1234567891011121314151617181920public class IteratorDemo2 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); if(&quot;b&quot;.equals(s))&#123; //指向谁,那么此时就删除谁. it.remove(); &#125; &#125; System.out.println(list); &#125;&#125; 1.5增强for循环【应用】 介绍 它是JDK5之后出现的,其内部原理是一个Iterator迭代器 实现Iterable接口的类才可以使用迭代器和增强for 简化数组和Collection集合的遍历 格式 ​ for(集合/数组中元素的数据类型 变量名 : 集合/数组名) { ​ // 已经将当前遍历到的元素封装到变量中了,直接使用变量即可 ​ } 代码 123456789101112131415161718public class MyCollectonDemo1 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); list.add(&quot;e&quot;); list.add(&quot;f&quot;); //1,数据类型一定是集合或者数组中元素的类型 //2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素 //3,list就是要遍历的集合或者数组 for(String str : list)&#123; System.out.println(str); &#125; &#125;&#125; 2.List集合 2.1List集合的概述和特点【记忆】 List集合的概述 有序集合,这里的有序指的是存取顺序 用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素 与Set集合不同,列表通常允许重复的元素 List集合的特点 存取有序 可以重复 有索引 2.2List集合的特有方法【应用】 方法名 描述 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 3.数据结构3.1数据结构之栈和队列【记忆】 栈结构 ​ 先进后出 队列结构 ​ 先进先出 3.2数据结构之数组和链表【记忆】 数组结构 ​ 查询快、增删慢 队列结构 ​ 查询慢、增删快 4.List集合的实现类4.1List集合子类的特点【记忆】 ArrayList集合 ​ 底层是数组结构实现，查询快、增删慢 LinkedList集合 ​ 底层是链表结构实现，查询慢、增删快 4.2LinkedList集合的特有功能【应用】 特有方法 方法名 说明 public void addFirst(E e) 在该列表开头插入指定的元素 public void addLast(E e) 将指定的元素追加到此列表的末尾 public E getFirst() 返回此列表中的第一个元素 public E getLast() 返回此列表中的最后一个元素 public E removeFirst() 从此列表中删除并返回第一个元素 public E removeLast() 从此列表中删除并返回最后一个元素 5.泛型5.1泛型概述【理解】 泛型的介绍 ​ 泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制 泛型的好处 把运行时期的问题提前到了编译期间 避免了强制类型转换 泛型的定义格式 &lt;类型&gt;: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: &lt;类型1,类型2…&gt;: 指定多种类型的格式,多种类型之间用逗号隔开.例如: &lt;E,T&gt; &lt;K,V&gt; 5.2泛型类【应用】 定义格式 1修饰符 class 类名&lt;类型&gt; &#123; &#125; 示例代码 泛型类 1234567891011public class Generic&lt;T&gt; &#123; private T t; public T getT() &#123; return t; &#125; public void setT(T t) &#123; this.t = t; &#125;&#125; 测试类 123456789101112131415public class GenericDemo1 &#123; public static void main(String[] args) &#123; Generic&lt;String&gt; g1 = new Generic&lt;String&gt;(); g1.setT(&quot;杨幂&quot;); System.out.println(g1.getT()); Generic&lt;Integer&gt; g2 = new Generic&lt;Integer&gt;(); g2.setT(30); System.out.println(g2.getT()); Generic&lt;Boolean&gt; g3 = new Generic&lt;Boolean&gt;(); g3.setT(true); System.out.println(g3.getT()); &#125;&#125; 5.3泛型方法【应用】 定义格式 1修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名) &#123; &#125; 示例代码 带有泛型方法的类 12345public class Generic &#123; public &lt;T&gt; void show(T t) &#123; System.out.println(t); &#125;&#125; 测试类 123456789public class GenericDemo2 &#123; public static void main(String[] args) &#123; Generic g = new Generic(); g.show(&quot;柳岩&quot;); g.show(30); g.show(true); g.show(12.34); &#125;&#125; 5.4泛型接口【应用】 定义格式 1修饰符 interface 接口名&lt;类型&gt; &#123; &#125; 示例代码 泛型接口 123public interface Generic&lt;T&gt; &#123; void show(T t);&#125; 泛型接口实现类1 ​ 定义实现类时,定义和接口相同泛型,创建实现类对象时明确泛型的具体类型 123456public class GenericImpl1&lt;T&gt; implements Generic&lt;T&gt; &#123; @Override public void show(T t) &#123; System.out.println(t); &#125;&#125; 泛型接口实现类2 ​ 定义实现类时,直接明确泛型的具体类型 123456public class GenericImpl2 implements Generic&lt;Integer&gt;&#123; @Override public void show(Integer t) &#123; System.out.println(t); &#125;&#125; 测试类 123456789101112public class GenericDemo3 &#123; public static void main(String[] args) &#123; GenericImpl1&lt;String&gt; g1 = new GenericImpl&lt;String&gt;(); g1.show(&quot;林青霞&quot;); GenericImpl1&lt;Integer&gt; g2 = new GenericImpl&lt;Integer&gt;(); g2.show(30); GenericImpl2 g3 = new GenericImpl2(); g3.show(10); &#125;&#125; 5.5类型通配符 类型通配符: &lt;?&gt; ArrayList&lt;?&gt;: 表示元素类型未知的ArrayList,它的元素可以匹配任何的类型 但是并不能把元素添加到ArrayList中了,获取出来的也是父类类型 类型通配符上限: &lt;? extends 类型&gt; ArrayListList &lt;? extends Number&gt;: 它表示的类型是Number或者其子类型 类型通配符下限: &lt;? super 类型&gt; ArrayListList &lt;? super Number&gt;: 它表示的类型是Number或者其父类型 泛型通配符的使用 12345678910111213141516171819202122232425262728293031public class GenericDemo4 &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); ArrayList&lt;Number&gt; list3 = new ArrayList&lt;&gt;(); ArrayList&lt;Object&gt; list4 = new ArrayList&lt;&gt;(); method(list1); method(list2); method(list3); method(list4); getElement1(list1); getElement1(list2);//报错 getElement1(list3); getElement1(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125; // 泛型通配符: 此时的泛型?,可以是任意类型 public static void method(ArrayList&lt;?&gt; list)&#123;&#125; // 泛型的上限: 此时的泛型?,必须是Number类型或者Number类型的子类 public static void getElement1(ArrayList&lt;? extends Number&gt; list)&#123;&#125; // 泛型的下限: 此时的泛型?,必须是Number类型或者Number类型的父类 public static void getElement2(ArrayList&lt;? super Number&gt; list)&#123;&#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"常用API02","slug":"常用API02","date":"2021-09-11T11:59:00.000Z","updated":"2021-09-11T11:59:00.000Z","comments":true,"path":"2021/09/11/常用API02/","link":"","permalink":"https://hujiahao.top/2021/09/11/%E5%B8%B8%E7%94%A8API02/","excerpt":"","text":"1.时间日期类1.1 Date类（应用） 计算机中时间原点 1970年1月1日 00:00:00 时间换算单位 1秒 = 1000毫秒 Date类概述 Date 代表了一个特定的时间，精确到毫秒 Date类构造方法 方法名 说明 public Date() 分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 public Date(long date) 分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 示例代码 123456789101112public class DateDemo01 &#123; public static void main(String[] args) &#123; //public Date()：分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 Date d1 = new Date(); System.out.println(d1); //public Date(long date)：分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 long date = 1000*60*60; Date d2 = new Date(date); System.out.println(d2); &#125;&#125; 1.2 Date类常用方法（应用） 常用方法 方法名 说明 public long getTime() 获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 public void setTime(long time) 设置时间，给的是毫秒值 示例代码 1234567891011121314151617public class DateDemo02 &#123; public static void main(String[] args) &#123; //创建日期对象 Date d = new Date(); //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值// System.out.println(d.getTime());// System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + &quot;年&quot;); //public void setTime(long time):设置时间，给的是毫秒值// long time = 1000*60*60; long time = System.currentTimeMillis(); d.setTime(time); System.out.println(d); &#125;&#125; 1.3 SimpleDateFormat类（应用） SimpleDateFormat类概述 ​ SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。 ​ 我们重点学习日期格式化和解析 SimpleDateFormat类构造方法 方法名 说明 public SimpleDateFormat() 构造一个SimpleDateFormat，使用默认模式和日期格式 public SimpleDateFormat(String pattern) 构造一个SimpleDateFormat使用给定的模式和默认的日期格式 SimpleDateFormat类的常用方法 格式化(从Date到String) public final String format(Date date)：将日期格式化成日期/时间字符串 解析(从String到Date) public Date parse(String source)：从给定字符串的开始解析文本以生成日期 示例代码 123456789101112131415161718public class SimpleDateFormatDemo &#123; public static void main(String[] args) throws ParseException &#123; //格式化：从 Date 到 String Date d = new Date();// SimpleDateFormat sdf = new SimpleDateFormat(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String s = sdf.format(d); System.out.println(s); System.out.println(&quot;--------&quot;); //从 String 到 Date String ss = &quot;2048-08-09 11:11:11&quot;; //ParseException SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date dd = sdf2.parse(ss); System.out.println(dd); &#125;&#125; 1.4 时间日期类练习 (应用) 需求 秒杀开始时间是2020年11月11日 00:00:00,结束时间是2020年11月11日 00:10:00,用户小贾下单时间是2020年11月11日 00:03:47,用户小皮下单时间是2020年11月11日 00:10:11,判断用户有没有成功参与秒杀活动 实现步骤 判断下单时间是否在开始到结束的范围内 把字符串形式的时间变成毫秒值 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class DateDemo5 &#123; public static void main(String[] args) throws ParseException &#123; //开始时间：2020年11月11日 0:0:0 //结束时间：2020年11月11日 0:10:0 //小贾2020年11月11日 0:03:47 //小皮2020年11月11日 0:10:11 //1.判断两位同学的下单时间是否在范围之内就可以了。 //2.要把每一个时间都换算成毫秒值。 String start = &quot;2020年11月11日 0:0:0&quot;; String end = &quot;2020年11月11日 0:10:0&quot;; String jia = &quot;2020年11月11日 0:03:47&quot;; String pi = &quot;2020年11月11日 0:10:11&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); long startTime = sdf.parse(start).getTime(); long endTime = sdf.parse(end).getTime();// System.out.println(startTime);// System.out.println(endTime); long jiaTime = sdf.parse(jia).getTime(); long piTime = sdf.parse(pi).getTime(); if(jiaTime &gt;= startTime &amp;&amp; jiaTime &lt;= endTime)&#123; System.out.println(&quot;小贾同学参加上了秒杀活动&quot;); &#125;else&#123; System.out.println(&quot;小贾同学没有参加上秒杀活动&quot;); &#125; System.out.println(&quot;------------------------&quot;); if(piTime &gt;= startTime &amp;&amp; piTime &lt;= endTime)&#123; System.out.println(&quot;小皮同学参加上了秒杀活动&quot;); &#125;else&#123; System.out.println(&quot;小皮同学没有参加上秒杀活动&quot;); &#125; &#125; &#125; 2.JDK8时间日期类 2.1 JDK8新增日期类 (理解) LocalDate 表示日期（年月日） LocalTime 表示时间（时分秒） LocalDateTime 表示时间+ 日期 （年月日时分秒） 2.2 LocalDateTime创建方法 (应用) 方法说明 方法名 说明 public static LocalDateTime now() 获取当前系统时间 public static LocalDateTime of (年, 月 , 日, 时, 分, 秒) 使用指定年月日和时分秒初始化一个LocalDateTime对象 示例代码 123456789public class JDK8DateDemo2 &#123; public static void main(String[] args) &#123; LocalDateTime now = LocalDateTime.now(); System.out.println(now); LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 11); System.out.println(localDateTime); &#125;&#125; 2.3 LocalDateTime获取方法 (应用) 方法说明 方法名 说明 public int getYear() 获取年 public int getMonthValue() 获取月份（1-12） public int getDayOfMonth() 获取月份中的第几天（1-31） public int getDayOfYear() 获取一年中的第几天（1-366） public DayOfWeek getDayOfWeek() 获取星期 public int getMinute() 获取分钟 public int getHour() 获取小时 示例代码 12345678910111213141516171819202122232425262728293031323334public class JDK8DateDemo3 &#123; public static void main(String[] args) &#123; LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 11, 11, 20); //public int getYear() 获取年 int year = localDateTime.getYear(); System.out.println(&quot;年为&quot; +year); //public int getMonthValue() 获取月份（1-12） int month = localDateTime.getMonthValue(); System.out.println(&quot;月份为&quot; + month); Month month1 = localDateTime.getMonth();// System.out.println(month1); //public int getDayOfMonth() 获取月份中的第几天（1-31） int day = localDateTime.getDayOfMonth(); System.out.println(&quot;日期为&quot; + day); //public int getDayOfYear() 获取一年中的第几天（1-366） int dayOfYear = localDateTime.getDayOfYear(); System.out.println(&quot;这是一年中的第&quot; + dayOfYear + &quot;天&quot;); //public DayOfWeek getDayOfWeek()获取星期 DayOfWeek dayOfWeek = localDateTime.getDayOfWeek(); System.out.println(&quot;星期为&quot; + dayOfWeek); //public int getMinute() 获取分钟 int minute = localDateTime.getMinute(); System.out.println(&quot;分钟为&quot; + minute); //public int getHour() 获取小时 int hour = localDateTime.getHour(); System.out.println(&quot;小时为&quot; + hour); &#125;&#125; 2.4 LocalDateTime转换方法 (应用) 方法说明 方法名 说明 public LocalDate toLocalDate () 转换成为一个LocalDate对象 public LocalTime toLocalTime () 转换成为一个LocalTime对象 示例代码 123456789101112public class JDK8DateDemo4 &#123; public static void main(String[] args) &#123; LocalDateTime localDateTime = LocalDateTime.of(2020, 12, 12, 8, 10, 12); //public LocalDate toLocalDate () 转换成为一个LocalDate对象 LocalDate localDate = localDateTime.toLocalDate(); System.out.println(localDate); //public LocalTime toLocalTime () 转换成为一个LocalTime对象 LocalTime localTime = localDateTime.toLocalTime(); System.out.println(localTime); &#125;&#125; 2.5 LocalDateTime格式化和解析 (应用) 方法说明 方法名 说明 public String format (指定格式) 把一个LocalDateTime格式化成为一个字符串 public LocalDateTime parse (准备解析的字符串, 解析格式) 把一个日期字符串解析成为一个LocalDateTime对象 public static DateTimeFormatter ofPattern(String pattern) 使用指定的日期模板获取一个日期格式化器DateTimeFormatter对象 示例代码 1234567891011121314151617181920212223public class JDK8DateDemo5 &#123; public static void main(String[] args) &#123; //method1(); //method2(); &#125; private static void method2() &#123; //public static LocalDateTime parse (准备解析的字符串, 解析格式) 把一个日期字符串解析成为一个LocalDateTime对象 String s = &quot;2020年11月12日 13:14:15&quot;; DateTimeFormatter pattern = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); LocalDateTime parse = LocalDateTime.parse(s, pattern); System.out.println(parse); &#125; private static void method1() &#123; LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 12, 13, 14, 15); System.out.println(localDateTime); //public String format (指定格式) 把一个LocalDateTime格式化成为一个字符串 DateTimeFormatter pattern = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String s = localDateTime.format(pattern); System.out.println(s); &#125;&#125; 2.6 LocalDateTime增加或者减少时间的方法 (应用) 方法说明 方法名 说明 public LocalDateTime plusYears (long years) 添加或者减去年 public LocalDateTime plusMonths(long months) 添加或者减去月 public LocalDateTime plusDays(long days) 添加或者减去日 public LocalDateTime plusHours(long hours) 添加或者减去时 public LocalDateTime plusMinutes(long minutes) 添加或者减去分 public LocalDateTime plusSeconds(long seconds) 添加或者减去秒 public LocalDateTime plusWeeks(long weeks) 添加或者减去周 示例代码 123456789101112131415/** * JDK8 时间类添加或者减去时间的方法 */public class JDK8DateDemo6 &#123; public static void main(String[] args) &#123; //public LocalDateTime plusYears (long years) 添加或者减去年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); //LocalDateTime newLocalDateTime = localDateTime.plusYears(1); //System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.plusYears(-1); System.out.println(newLocalDateTime); &#125;&#125; 2.7 LocalDateTime减少或者增加时间的方法 (应用) 方法说明 方法名 说明 public LocalDateTime minusYears (long years) 减去或者添加年 public LocalDateTime minusMonths(long months) 减去或者添加月 public LocalDateTime minusDays(long days) 减去或者添加日 public LocalDateTime minusHours(long hours) 减去或者添加时 public LocalDateTime minusMinutes(long minutes) 减去或者添加分 public LocalDateTime minusSeconds(long seconds) 减去或者添加秒 public LocalDateTime minusWeeks(long weeks) 减去或者添加周 示例代码 123456789101112131415/** * JDK8 时间类减少或者添加时间的方法 */public class JDK8DateDemo7 &#123; public static void main(String[] args) &#123; //public LocalDateTime minusYears (long years) 减去或者添加年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); //LocalDateTime newLocalDateTime = localDateTime.minusYears(1); //System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.minusYears(-1); System.out.println(newLocalDateTime); &#125;&#125; 2.8 LocalDateTime修改方法 (应用) 方法说明 方法名 说明 public LocalDateTime withYear(int year) 直接修改年 public LocalDateTime withMonth(int month) 直接修改月 public LocalDateTime withDayOfMonth(int dayofmonth) 直接修改日期(一个月中的第几天) public LocalDateTime withDayOfYear(int dayOfYear) 直接修改日期(一年中的第几天) public LocalDateTime withHour(int hour) 直接修改小时 public LocalDateTime withMinute(int minute) 直接修改分钟 public LocalDateTime withSecond(int second) 直接修改秒 示例代码 123456789101112131415/** * JDK8 时间类修改时间 */public class JDK8DateDemo8 &#123; public static void main(String[] args) &#123; //public LocalDateTime withYear(int year) 修改年 LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 11, 13, 14, 15); // LocalDateTime newLocalDateTime = localDateTime.withYear(2048); // System.out.println(newLocalDateTime); LocalDateTime newLocalDateTime = localDateTime.withMonth(20); System.out.println(newLocalDateTime); &#125;&#125; 2.9 Period (应用) 方法说明 方法名 说明 public static Period between(开始时间,结束时间) 计算两个“时间”的间隔 public int getYears() 获得这段时间的年数 public int getMonths() 获得此期间的总月数 public int getDays() 获得此期间的天数 public long toTotalMonths() 获取此期间的总月数 示例代码 1234567891011121314151617181920212223/** * 计算两个时间的间隔 */public class JDK8DateDemo9 &#123; public static void main(String[] args) &#123; //public static Period between(开始时间,结束时间) 计算两个&quot;时间&quot;的间隔 LocalDate localDate1 = LocalDate.of(2020, 1, 1); LocalDate localDate2 = LocalDate.of(2048, 12, 12); Period period = Period.between(localDate1, localDate2); System.out.println(period);//P28Y11M11D //public int getYears() 获得这段时间的年数 System.out.println(period.getYears());//28 //public int getMonths() 获得此期间的月数 System.out.println(period.getMonths());//11 //public int getDays() 获得此期间的天数 System.out.println(period.getDays());//11 //public long toTotalMonths() 获取此期间的总月数 System.out.println(period.toTotalMonths());//347 &#125;&#125; 2.10 Duration (应用) 方法说明 方法名 说明 public static Durationbetween(开始时间,结束时间) 计算两个“时间”的间隔 public long toSeconds() 获得此时间间隔的秒 public int toMillis() 获得此时间间隔的毫秒 public int toNanos() 获得此时间间隔的纳秒 示例代码 12345678910111213141516171819/** * 计算两个时间的间隔 */public class JDK8DateDemo10 &#123; public static void main(String[] args) &#123; //public static Duration between(开始时间,结束时间) 计算两个“时间&quot;的间隔 LocalDateTime localDateTime1 = LocalDateTime.of(2020, 1, 1, 13, 14, 15); LocalDateTime localDateTime2 = LocalDateTime.of(2020, 1, 2, 11, 12, 13); Duration duration = Duration.between(localDateTime1, localDateTime2); System.out.println(duration);//PT21H57M58S //public long toSeconds() 获得此时间间隔的秒 System.out.println(duration.toSeconds());//79078 //public int toMillis() 获得此时间间隔的毫秒 System.out.println(duration.toMillis());//79078000 //public int toNanos() 获得此时间间隔的纳秒 System.out.println(duration.toNanos());//79078000000000 &#125;&#125; 3.异常 3.1 异常（记忆） 异常的概述 ​ 异常就是程序出现了不正常的情况 异常的体系结构 3.2 编译时异常和运行时异常的区别（记忆） 编译时异常 都是Exception类及其子类 必须显示处理，否则程序就会发生错误，无法通过编译 运行时异常 都是RuntimeException类及其子类 无需显示处理，也可以和编译时异常一样处理 图示 3.3 JVM默认处理异常的方式（理解） 如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，处理方式有如下两个步骤： 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台 程序停止执行 3.4 查看异常信息 (理解)控制台在打印异常信息时,会打印异常类名,异常出现的原因,异常出现的位置 我们调bug时,可以根据提示,找到异常出现的位置,分析原因,修改异常代码 3.5 throws方式处理异常（应用） 定义格式 123public void 方法() throws 异常类名 &#123; &#125; 示例代码 1234567891011121314151617181920212223public class ExceptionDemo &#123; public static void main(String[] args) throws ParseException&#123; System.out.println(&quot;开始&quot;);// method(); method2(); System.out.println(&quot;结束&quot;); &#125; //编译时异常 public static void method2() throws ParseException &#123; String s = &quot;2048-08-09&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date d = sdf.parse(s); System.out.println(d); &#125; //运行时异常 public static void method() throws ArrayIndexOutOfBoundsException &#123; int[] arr = &#123;1, 2, 3&#125;; System.out.println(arr[3]); &#125;&#125; 注意事项 这个throws格式是跟在方法的括号后面的 编译时异常必须要进行处理，两种处理方案：try…catch …或者 throws，如果采用 throws 这种方案，在方法上进行显示声明,将来谁调用这个方法谁处理 运行时异常因为在运行时才会发生,所以在方法后面可以不写,运行时出现异常默认交给jvm处理 3.6 throw抛出异常 (应用) 格式 throw new 异常(); 注意 这个格式是在方法内的，表示当前代码手动抛出一个异常，下面的代码不用再执行了 throws和throw的区别 throws throw 用在方法声明后面，跟的是异常类名 用在方法体内，跟的是异常对象名 表示声明异常，调用该方法有可能会出现这样的异常 表示手动抛出异常对象，由方法体内的语句处理 示例代码 12345678910111213141516171819202122public class ExceptionDemo8 &#123; public static void main(String[] args) &#123; //int [] arr = &#123;1,2,3,4,5&#125;; int [] arr = null; printArr(arr);//就会 接收到一个异常. //我们还需要自己处理一下异常. &#125; private static void printArr(int[] arr) &#123; if(arr == null)&#123; //调用者知道成功打印了吗? //System.out.println(&quot;参数不能为null&quot;); throw new NullPointerException(); //当参数为null的时候 //手动创建了一个异常对象,抛给了调用者,产生了一个异常 &#125;else&#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; &#125;&#125; 3.7 try-catch方式处理异常（应用） 定义格式 12345try &#123; 可能出现异常的代码;&#125; catch(异常类名 变量名) &#123; 异常的处理代码;&#125; 执行流程 程序从 try 里面的代码开始执行 出现异常，就会跳转到对应的 catch 里面去执行 执行完毕之后，程序还可以继续往下执行 示例代码 1234567891011121314151617public class ExceptionDemo01 &#123; public static void main(String[] args) &#123; System.out.println(&quot;开始&quot;); method(); System.out.println(&quot;结束&quot;); &#125; public static void method() &#123; try &#123; int[] arr = &#123;1, 2, 3&#125;; System.out.println(arr[3]); System.out.println(&quot;这里能够访问到吗&quot;); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println(&quot;你访问的数组索引不存在，请回去修改为正确的索引&quot;); &#125; &#125;&#125; 注意 如果 try 中没有遇到问题，怎么执行？ 会把try中所有的代码全部执行完毕,不会执行catch里面的代码 如果 try 中遇到了问题，那么 try 下面的代码还会执行吗？ 那么直接跳转到对应的catch语句中,try下面的代码就不会再执行了当catch里面的语句全部执行完毕,表示整个体系全部执行完全,继续执行下面的代码 如果出现的问题没有被捕获，那么程序如何运行？ 那么try…catch就相当于没有写.那么也就是自己没有处理.默认交给虚拟机处理. 同时有可能出现多个异常怎么处理？ 出现多个异常,那么就写多个catch就可以了.注意点:如果多个异常之间存在子父类关系.那么父类一定要写在下面 3.8 Throwable成员方法（应用） 常用方法 方法名 说明 public String getMessage() 返回此 throwable 的详细消息字符串 public String toString() 返回此可抛出的简短描述 public void printStackTrace() 把异常的错误信息输出在控制台 示例代码 1234567891011121314151617181920212223242526272829303132public class ExceptionDemo02 &#123; public static void main(String[] args) &#123; System.out.println(&quot;开始&quot;); method(); System.out.println(&quot;结束&quot;); &#125; public static void method() &#123; try &#123; int[] arr = &#123;1, 2, 3&#125;; System.out.println(arr[3]); //new ArrayIndexOutOfBoundsException(); System.out.println(&quot;这里能够访问到吗&quot;); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; //new ArrayIndexOutOfBoundsException();// e.printStackTrace(); //public String getMessage():返回此 throwable 的详细消息字符串// System.out.println(e.getMessage()); //Index 3 out of bounds for length 3 //public String toString():返回此可抛出的简短描述// System.out.println(e.toString()); //java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 //public void printStackTrace():把异常的错误信息输出在控制台 e.printStackTrace();// java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3// at com.itheima_02.ExceptionDemo02.method(ExceptionDemo02.java:18)// at com.itheima_02.ExceptionDemo02.main(ExceptionDemo02.java:11) &#125; &#125;&#125; 3.9 异常的练习 (应用) 需求 键盘录入学生的姓名和年龄,其中年龄为18 - 25岁,超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止 实现步骤 创建学生对象 键盘录入姓名和年龄，并赋值给学生对象 如果是非法数据就再次录入 代码实现 学生类 1234567891011121314151617181920212223242526272829303132333435363738394041public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if(age &gt;= 18 &amp;&amp; age &lt;= 25)&#123; this.age = age; &#125;else&#123; //当年龄不合法时,产生一个异常 throw new RuntimeException(&quot;年龄超出了范围&quot;); &#125; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738public class ExceptionDemo12 &#123; public static void main(String[] args) &#123; // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁, // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。 Student s = new Student(); Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入姓名&quot;); String name = sc.nextLine(); s.setName(name); while(true)&#123; System.out.println(&quot;请输入年龄&quot;); String ageStr = sc.nextLine(); try &#123; int age = Integer.parseInt(ageStr); s.setAge(age); break; &#125; catch (NumberFormatException e) &#123; System.out.println(&quot;请输入一个整数&quot;); continue; &#125; catch (AgeOutOfBoundsException e) &#123; System.out.println(e.toString()); System.out.println(&quot;请输入一个符合范围的年龄&quot;); continue; &#125; /*if(age &gt;= 18 &amp;&amp; age &lt;=25)&#123; s.setAge(age); break; &#125;else&#123; System.out.println(&quot;请输入符合要求的年龄&quot;); continue; &#125;*/ &#125; System.out.println(s); &#125;&#125; 3.10 自定义异常（应用） 自定义异常概述 当Java中提供的异常不能满足我们的需求时,我们可以自定义异常 实现步骤 定义异常类 写继承关系 提供空参构造 提供带参构造 代码实现 异常类 12345678public class AgeOutOfBoundsException extends RuntimeException &#123; public AgeOutOfBoundsException() &#123; &#125; public AgeOutOfBoundsException(String message) &#123; super(message); &#125;&#125; 学生类 1234567891011121314151617181920212223242526272829303132333435363738394041public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if(age &gt;= 18 &amp;&amp; age &lt;= 25)&#123; this.age = age; &#125;else&#123; //如果Java中提供的异常不能满足我们的需求,我们可以使用自定义的异常 throw new AgeOutOfBoundsException(&quot;年龄超出了范围&quot;); &#125; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738public class ExceptionDemo12 &#123; public static void main(String[] args) &#123; // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁, // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。 Student s = new Student(); Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入姓名&quot;); String name = sc.nextLine(); s.setName(name); while(true)&#123; System.out.println(&quot;请输入年龄&quot;); String ageStr = sc.nextLine(); try &#123; int age = Integer.parseInt(ageStr); s.setAge(age); break; &#125; catch (NumberFormatException e) &#123; System.out.println(&quot;请输入一个整数&quot;); continue; &#125; catch (AgeOutOfBoundsException e) &#123; System.out.println(e.toString()); System.out.println(&quot;请输入一个符合范围的年龄&quot;); continue; &#125; /*if(age &gt;= 18 &amp;&amp; age &lt;=25)&#123; s.setAge(age); break; &#125;else&#123; System.out.println(&quot;请输入符合要求的年龄&quot;); continue; &#125;*/ &#125; System.out.println(s); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"常用API01","slug":"常用API01","date":"2021-09-10T11:59:00.000Z","updated":"2021-09-10T11:59:00.000Z","comments":true,"path":"2021/09/10/常用API01/","link":"","permalink":"https://hujiahao.top/2021/09/10/%E5%B8%B8%E7%94%A8API01/","excerpt":"","text":"1.API1.1 API概述【理解】 什么是API ​ API (Application Programming Interface) ：应用程序编程接口 java中的API ​ 指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。 1.2 如何使用API帮助文档【应用】 打开帮助文档 找到索引选项卡中的输入框 在输入框中输入Random 看类在哪个包下 看类的描述 看构造方法 看成员方法 2.常用API2.1 Math（应用） 1、Math类概述 Math 包含执行基本数字运算的方法 2、Math中方法的调用方式 Math类中无构造方法，但内部的方法都是静态的，则可以通过 类名.进行调用 3、Math类的常用方法 方法名 方法名 说明 public static int abs(int a) 返回参数的绝对值 public static double ceil(double a) 返回大于或等于参数的最小double值，等于一个整数 public static double floor(double a) 返回小于或等于参数的最大double值，等于一个整数 public static int round(float a) 按照四舍五入返回最接近参数的int public static int max(int a,int b) 返回两个int值中的较大值 public static int min(int a,int b) 返回两个int值中的较小值 public static double pow (double a,double b) 返回a的b次幂的值 public static double random() 返回值为double的正值，[0.0,1.0) 2.2 System（应用） System类的常用方法 方法名 说明 public static void exit(int status) 终止当前运行的 Java 虚拟机，非零表示异常终止 public static long currentTimeMillis() 返回当前时间(以毫秒为单位) void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 数组拷贝 示例代码 需求：在控制台输出1-10000，计算这段代码执行了多少毫秒 123456789101112public class SystemDemo &#123; public static void main(String[] args) &#123; // 获取开始的时间节点 long start = System.currentTimeMillis(); for (int i = 1; i &lt;= 10000; i++) &#123; System.out.println(i); &#125; // 获取代码运行结束后的时间节点 long end = System.currentTimeMillis(); System.out.println(&quot;共耗时：&quot; + (end - start) + &quot;毫秒&quot;); &#125;&#125; 2.3 Object类的toString方法（应用） Object类概述 Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类，换句话说，该类所具备的方法，所有类都会有一份 查看方法源码的方式 选中方法，按下Ctrl + B 重写toString方法的方式 Alt + Insert 选择toString 在类的空白区域，右键 -&gt; Generate -&gt; 选择toString toString方法的作用： 以良好的格式，更方便的展示对象中的属性值 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Student extends Object &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125;public class ObjectDemo &#123; public static void main(String[] args) &#123; Student s = new Student(); s.setName(&quot;林青霞&quot;); s.setAge(30); System.out.println(s); System.out.println(s.toString()); &#125;&#125; 运行结果： 12Student&#123;name=&#x27;林青霞&#x27;, age=30&#125;Student&#123;name=&#x27;林青霞&#x27;, age=30&#125; 2.4 Object类的equals方法（应用） equals方法的作用 用于对象之间的比较，返回true和false的结果 举例：s1.equals(s2); s1和s2是两个对象 重写equals方法的场景 不希望比较对象的地址值，想要结合对象属性进行比较的时候。 重写equals方法的方式 alt + insert 选择equals() and hashCode()，IntelliJ Default，一路next，finish即可 在类的空白区域，右键 -&gt; Generate -&gt; 选择equals() and hashCode()，后面的同上。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; //this -- s1 //o -- s2 if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; //student -- s2 if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125;&#125;public class ObjectDemo &#123; public static void main(String[] args) &#123; Student s1 = new Student(); s1.setName(&quot;林青霞&quot;); s1.setAge(30); Student s2 = new Student(); s2.setName(&quot;林青霞&quot;); s2.setAge(30); //需求：比较两个对象的内容是否相同 System.out.println(s1.equals(s2)); &#125;&#125; 面试题 123456789101112131415161718// 看程序,分析结果String s = “abc”;StringBuilder sb = new StringBuilder(“abc”);s.equals(sb); sb.equals(s); public class InterviewTest &#123; public static void main(String[] args) &#123; String s1 = &quot;abc&quot;; StringBuilder sb = new StringBuilder(&quot;abc&quot;); //1.此时调用的是String类中的equals方法. //保证参数也是字符串,否则不会比较属性值而直接返回false //System.out.println(s1.equals(sb)); // false //StringBuilder类中是没有重写equals方法,用的就是Object类中的. System.out.println(sb.equals(s1)); // false &#125;&#125; 2.5 Objects (应用) 常用方法 方法名 说明 public static String toString(对象) 返回参数中对象的字符串表示形式。 public static String toString(对象, 默认字符串) 返回对象的字符串表示形式。 public static Boolean isNull(对象) 判断对象是否为空 public static Boolean nonNull(对象) 判断对象是否不为空 示例代码 学生类 123456789101112131415161718192021222324252627282930313233343536class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; &#125; 测试类 123456789101112131415161718192021222324252627public class MyObjectsDemo &#123; public static void main(String[] args) &#123; // public static String toString(对象): 返回参数中对象的字符串表示形式。 // Student s = new Student(&quot;小罗同学&quot;,50); // String result = Objects.toString(s); // System.out.println(result); // System.out.println(s); // public static String toString(对象, 默认字符串): 返回对象的字符串表示形式。如果对象为空,那么返回第二个参数. //Student s = new Student(&quot;小花同学&quot;,23); // Student s = null; // String result = Objects.toString(s, &quot;随便写一个&quot;); // System.out.println(result); // public static Boolean isNull(对象): 判断对象是否为空 //Student s = null; // Student s = new Student(); // boolean result = Objects.isNull(s); // System.out.println(result); // public static Boolean nonNull(对象): 判断对象是否不为空 //Student s = new Student(); Student s = null; boolean result = Objects.nonNull(s); System.out.println(result); &#125; &#125; 2.6 BigDecimal (应用) 作用 可以用来进行精确计算 构造方法 方法名 说明 BigDecimal(double val) 参数为double BigDecimal(String val) 参数为String 常用方法 方法名 说明 public BigDecimal add(另一个BigDecimal对象) 加法 public BigDecimal subtract (另一个BigDecimal对象) 减法 public BigDecimal multiply (另一个BigDecimal对象) 乘法 public BigDecimal divide (另一个BigDecimal对象) 除法 public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式) 除法 总结 BigDecimal是用来进行精确计算的 创建BigDecimal的对象，构造方法使用参数类型为字符串的。 四则运算中的除法，如果除不尽请使用divide的三个参数的方法。 代码示例： 1234567BigDecimal divide = bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);参数1 ，表示参与运算的BigDecimal 对象。参数2 ，表示小数点后面精确到多少位参数3 ，舍入模式 BigDecimal.ROUND_UP 进一法 BigDecimal.ROUND_FLOOR 去尾法 BigDecimal.ROUND_HALF_UP 四舍五入 3.包装类 3.1 基本类型包装类（记忆） 基本类型包装类的作用 将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据 常用的操作之一：用于基本数据类型与字符串之间的转换 基本类型对应的包装类 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 3.2 Integer类（应用） Integer类概述 包装一个对象中的原始类型 int 的值 Integer类构造方法 方法名 说明 public Integer(int value) 根据 int 值创建 Integer 对象(过时) public Integer(String s) 根据 String 值创建 Integer 对象(过时) public static Integer valueOf(int i) 返回表示指定的 int 值的 Integer 实例 public static Integer valueOf(String s) 返回一个保存指定值的 Integer 对象 String 示例代码 123456789101112131415161718192021public class IntegerDemo &#123; public static void main(String[] args) &#123; //public Integer(int value)：根据 int 值创建 Integer 对象(过时) Integer i1 = new Integer(100); System.out.println(i1); //public Integer(String s)：根据 String 值创建 Integer 对象(过时) Integer i2 = new Integer(&quot;100&quot;);// Integer i2 = new Integer(&quot;abc&quot;); //NumberFormatException System.out.println(i2); System.out.println(&quot;--------&quot;); //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例 Integer i3 = Integer.valueOf(100); System.out.println(i3); //public static Integer valueOf(String s)：返回一个保存指定值的Integer对象 String Integer i4 = Integer.valueOf(&quot;100&quot;); System.out.println(i4); &#125;&#125; 3.3 自动拆箱和自动装箱（理解） 自动装箱 ​ 把基本数据类型转换为对应的包装类类型 自动拆箱 ​ 把包装类类型转换为对应的基本数据类型 示例代码 12Integer i = 100; // 自动装箱i += 200; // i = i + 200; i + 200 自动拆箱；i = i + 200; 是自动装箱 3.4 int和String类型的相互转换（记忆） int转换为String 转换方式 方式一：直接在数字后加一个空字符串 方式二：通过String类静态方法valueOf() 示例代码 1234567891011121314public class IntegerDemo &#123; public static void main(String[] args) &#123; //int --- String int number = 100; //方式1 String s1 = number + &quot;&quot;; System.out.println(s1); //方式2 //public static String valueOf(int i) String s2 = String.valueOf(number); System.out.println(s2); System.out.println(&quot;--------&quot;); &#125;&#125; String转换为int 转换方式 方式一：先将字符串数字转成Integer，再调用valueOf()方法 方式二：通过Integer静态方法parseInt()进行转换 示例代码 123456789101112131415public class IntegerDemo &#123; public static void main(String[] args) &#123; //String --- int String s = &quot;100&quot;; //方式1：String --- Integer --- int Integer i = Integer.valueOf(s); //public int intValue() int x = i.intValue(); System.out.println(x); //方式2 //public static int parseInt(String s) int y = Integer.parseInt(s); System.out.println(y); &#125;&#125; 3.5 字符串数据排序案例（应用） 案例需求 ​ 有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：27 38 46 50 91 代码实现 123456789101112131415161718192021222324public class IntegerTest &#123; public static void main(String[] args) &#123; //定义一个字符串 String s = &quot;91 27 46 38 50&quot;; //把字符串中的数字数据存储到一个int类型的数组中 String[] strArray = s.split(&quot; &quot;);// for(int i=0; i&lt;strArray.length; i++) &#123;// System.out.println(strArray[i]);// &#125; //定义一个int数组，把 String[] 数组中的每一个元素存储到 int 数组中 int[] arr = new int[strArray.length]; for(int i=0; i&lt;arr.length; i++) &#123; arr[i] = Integer.parseInt(strArray[i]); &#125; //对 int 数组进行排序 Arrays.sort(arr); for(int i=0; i&lt;arr.length; i++)&#123; System.out.print(arr[i] + &quot; &quot;); &#125;&#125; 4.递归 4.1 递归【应用】 递归的介绍 以编程的角度来看，递归指的是方法定义中调用方法本身的现象 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算 递归的基本使用 1234567891011121314151617181920public class MyFactorialDemo2 &#123; public static void main(String[] args) &#123; int sum = getSum(100); System.out.println(sum); &#125; private static int getSum(int i) &#123; //1- 100之间的和 //100 + (1-99之间的和) // 99 + (1- 98之间的和) //.... //1 //方法的作用: 求 1- i 之间和 if(i == 1)&#123; return 1; &#125;else&#123; return i + getSum(i -1); &#125; &#125;&#125; 递归的注意事项 递归一定要有出口。否则内存溢出 递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出 4.2 递归求阶乘【应用】 案例需求 ​ 用递归求5的阶乘，并把结果在控制台输出 代码实现 1234567891011121314151617181920public class DiGuiDemo01 &#123; public static void main(String[] args) &#123; //调用方法 int result = jc(5); //输出结果 System.out.println(&quot;5的阶乘是：&quot; + result); &#125; //定义一个方法，用于递归求阶乘，参数为一个int类型的变量 public static int jc(int n) &#123; //在方法内部判断该变量的值是否是1 if(n == 1) &#123; //是：返回1 return 1; &#125; else &#123; //不是：返回n*(n-1)! return n*jc(n-1); &#125; &#125;&#125; 内存图 5.数组的高级操作5.1 二分查找 (理解) 二分查找概述 查找指定元素在数组中的位置时,以前的方式是通过遍历,逐个获取每个元素,看是否是要查找的元素,这种方式当数组元素较多时,查找的效率很低 二分查找也叫折半查找,每次可以去掉一半的查找范围,从而提高查找的效率 需求 在数组{1,2,3,4,5,6,7,8,9,10}中,查找某个元素的位置 实现步骤 定义两个变量，表示要查找的范围。默认min = 0 ，max = 最大索引 循环查找，但是min &lt;= max 计算出mid的值 判断mid位置的元素是否为要查找的元素，如果是直接返回对应索引 如果要查找的值在mid的左半边，那么min值不变，max = mid -1.继续下次循环查找 如果要查找的值在mid的右半边，那么max值不变，min = mid + 1.继续下次循环查找 当min &gt; max 时，表示要查找的元素在数组中不存在，返回-1. 代码实现 1234567891011121314151617181920212223242526272829303132333435363738public class MyBinarySearchDemo &#123; public static void main(String[] args) &#123; int [] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;; int number = 11; //1,我现在要干嘛? --- 二分查找 //2.我干这件事情需要什么? --- 数组 元素 //3,我干完了,要不要把结果返回调用者 --- 把索引返回给调用者 int index = binarySearchForIndex(arr,number); System.out.println(index); &#125; private static int binarySearchForIndex(int[] arr, int number) &#123; //1,定义查找的范围 int min = 0; int max = arr.length - 1; //2.循环查找 min &lt;= max while(min &lt;= max)&#123; //3.计算出中间位置 mid int mid = (min + max) &gt;&gt; 1; //mid指向的元素 &gt; number if(arr[mid] &gt; number)&#123; //表示要查找的元素在左边. max = mid -1; &#125;else if(arr[mid] &lt; number)&#123; //mid指向的元素 &lt; number //表示要查找的元素在右边. min = mid + 1; &#125;else&#123; //mid指向的元素 == number return mid; &#125; &#125; //如果min大于了max就表示元素不存在,返回-1. return -1; &#125; &#125; 注意事项 有一个前提条件，数组内的元素一定要按照大小顺序排列，如果没有大小顺序，是不能使用二分查找法的 5.2 冒泡排序 (理解) 冒泡排序概述 一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序 如果有n个数据进行排序，总共需要比较n-1次 每一次比较完毕，下一次的比较就会少一个数据参与 代码实现 123456789101112131415161718192021222324252627282930313233public class MyBubbleSortDemo2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3, 5, 2, 1, 4&#125;; //1 2 3 4 5 bubbleSort(arr); &#125; private static void bubbleSort(int[] arr) &#123; //外层循环控制的是次数 比数组的长度少一次. for (int i = 0; i &lt; arr.length -1; i++) &#123; //内存循环就是实际循环比较的 //-1 是为了让数组不要越界 //-i 每一轮结束之后,我们就会少比一个数字. for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; printArr(arr); &#125; private static void printArr(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println(); &#125; &#125; 5.3 快速排序 (理解) 快速排序概述 冒泡排序算法中,一次循环结束,就相当于确定了当前的最大值,也能确定最大值在数组中应存入的位置 快速排序算法中,每一次递归时以第一个数为基准数,找到数组中所有比基准数小的.再找到所有比基准数大的.小的全部放左边,大的全部放右边,确定基准数的正确位置 核心步骤 从右开始找比基准数小的 从左开始找比基准数大的 交换两个值的位置 红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止 基准数归位 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MyQuiteSortDemo2 &#123; public static void main(String[] args) &#123;// 1，从右开始找比基准数小的// 2，从左开始找比基准数大的// 3，交换两个值的位置// 4，红色继续往左找，蓝色继续往右找，直到两个箭头指向同一个索引为止// 5，基准数归位 int[] arr = &#123;6, 1, 2, 7, 9, 3, 4, 5, 10, 8&#125;; quiteSort(arr,0,arr.length-1); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; &#125; private static void quiteSort(int[] arr, int left, int right) &#123; // 递归结束的条件 if(right &lt; left)&#123; return; &#125; int left0 = left; int right0 = right; //计算出基准数 int baseNumber = arr[left0]; while(left != right)&#123;// 1，从右开始找比基准数小的 while(arr[right] &gt;= baseNumber &amp;&amp; right &gt; left)&#123; right--; &#125;// 2，从左开始找比基准数大的 while(arr[left] &lt;= baseNumber &amp;&amp; right &gt; left)&#123; left++; &#125;// 3，交换两个值的位置 int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; &#125; //基准数归位 int temp = arr[left]; arr[left] = arr[left0]; arr[left0] = temp; // 递归调用自己,将左半部分排好序 quiteSort(arr,left0,left-1); // 递归调用自己,将右半部分排好序 quiteSort(arr,left +1,right0); &#125;&#125; 5.4 Arrays (应用) Arrays的常用方法 方法名 说明 public static String toString(int[] a) 返回指定数组的内容的字符串表示形式 public static void sort(int[] a) 按照数字顺序排列指定的数组 public static int binarySearch(int[] a, int key) 利用二分查找返回指定元素的索引 示例代码 123456789101112131415161718192021public class MyArraysDemo &#123; public static void main(String[] args) &#123; // public static String toString(int[] a) 返回指定数组的内容的字符串表示形式 // int [] arr = &#123;3,2,4,6,7&#125;; // System.out.println(Arrays.toString(arr)); // public static void sort(int[] a) 按照数字顺序排列指定的数组 // int [] arr = &#123;3,2,4,6,7&#125;; // Arrays.sort(arr); // System.out.println(Arrays.toString(arr)); // public static int binarySearch(int[] a, int key) 利用二分查找返回指定元素的索引 int [] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;; int index = Arrays.binarySearch(arr, 0); System.out.println(index); //1,数组必须有序 //2.如果要查找的元素存在,那么返回的是这个元素实际的索引 //3.如果要查找的元素不存在,那么返回的是 (-插入点-1) //插入点:如果这个元素在数组中,他应该在哪个索引上. &#125; &#125; 工具类设计思想 构造方法用 private 修饰 成员用 public static 修饰","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"内部类和Lambda表达式","slug":"内部类和Lambda表达式","date":"2021-09-08T11:59:00.000Z","updated":"2021-09-08T11:59:00.000Z","comments":true,"path":"2021/09/08/内部类和Lambda表达式/","link":"","permalink":"https://hujiahao.top/2021/09/08/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8CLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"1.内部类1.1 内部类的基本使用（理解） 内部类概念 在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类 内部类定义格式 格式&amp;举例： 1234567891011121314/* 格式： class 外部类名&#123; 修饰符 class 内部类名&#123; &#125; &#125;*/class Outer &#123; public class Inner &#123; &#125;&#125; 内部类的访问特点 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象 示例代码： 1234567891011121314151617/* 内部类访问特点： 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象 */public class Outer &#123; private int num = 10; public class Inner &#123; public void show() &#123; System.out.println(num); &#125; &#125; public void method() &#123; Inner i = new Inner(); i.show(); &#125;&#125; 1.2 成员内部类（理解） 成员内部类的定义位置 在类中方法，跟成员变量是一个位置 外界创建成员内部类格式 格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象; 举例：Outer.Inner oi = new Outer().new Inner(); 私有成员内部类 将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。 示例代码： 1234567891011121314151617181920class Outer &#123; private int num = 10; private class Inner &#123; public void show() &#123; System.out.println(num); &#125; &#125; public void method() &#123; Inner i = new Inner(); i.show(); &#125;&#125;public class InnerDemo &#123; public static void main(String[] args) &#123; //Outer.Inner oi = new Outer().new Inner(); //oi.show(); Outer o = new Outer(); o.method(); &#125;&#125; 静态成员内部类 静态成员内部类访问格式：外部类名.内部类名 对象名 = new 外部类名.内部类名(); 静态成员内部类中的静态方法：外部类名.内部类名.方法名(); 示例代码 123456789101112131415161718192021222324class Outer &#123; static class Inner &#123; public void show()&#123; System.out.println(&quot;inner..show&quot;); &#125; public static void method()&#123; System.out.println(&quot;inner..method&quot;); &#125; &#125;&#125;public class Test3Innerclass &#123; /* 静态成员内部类演示 */ public static void main(String[] args) &#123; // 外部类名.内部类名 对象名 = new 外部类名.内部类名(); Outer.Inner oi = new Outer.Inner(); oi.show(); Outer.Inner.method(); &#125;&#125; 1.3 局部内部类（理解） 局部内部类定义位置 局部内部类是在方法中定义的类 局部内部类方式方式 局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用 该类可以直接访问外部类的成员，也可以访问方法内的局部变量 示例代码 123456789101112131415161718192021class Outer &#123; private int num = 10; public void method() &#123; int num2 = 20; class Inner &#123; public void show() &#123; System.out.println(num); System.out.println(num2); &#125; &#125; Inner i = new Inner(); i.show(); &#125;&#125;public class OuterDemo &#123; public static void main(String[] args) &#123; Outer o = new Outer(); o.method(); &#125;&#125; 1.4 匿名内部类（应用） 匿名内部类的前提 存在一个类或者接口，这里的类可以是具体类也可以是抽象类 匿名内部类的格式 格式：new 类名 ( ) { 重写方法 } new 接口名 ( ) { 重写方法 } 举例： 1234new Inter()&#123; @Override public void method()&#123;&#125;&#125; 匿名内部类的本质 本质：是一个继承了该类或者实现了该接口的子类匿名对象 匿名内部类的细节 匿名内部类可以通过多态的形式接受 123456Inter i = new Inter()&#123; @Override public void method()&#123; &#125;&#125; 匿名内部类直接调用方法 1234567891011121314interface Inter&#123; void method();&#125;class Test&#123; public static void main(String[] args)&#123; new Inter()&#123; @Override public void method()&#123; System.out.println(&quot;我是匿名内部类&quot;); &#125; &#125;.method(); // 直接调用方法 &#125;&#125; 1.5 匿名内部类在开发中的使用（应用） 匿名内部类在开发中的使用 当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码 示例代码： 1234567891011121314151617181920212223242526272829303132/* 游泳接口 */interface Swimming &#123; void swim();&#125;public class TestSwimming &#123; public static void main(String[] args) &#123; goSwimming(new Swimming() &#123; @Override public void swim() &#123; System.out.println(&quot;铁汁, 我们去游泳吧&quot;); &#125; &#125;); &#125; /** * 使用接口的方法 */ public static void goSwimming(Swimming swimming)&#123; /* Swimming swim = new Swimming() &#123; @Override public void swim() &#123; System.out.println(&quot;铁汁, 我们去游泳吧&quot;); &#125; &#125; */ swimming.swim(); &#125;&#125; 2.Lambda表达式 2.1体验Lambda表达式【理解】 代码演示 123456789101112131415161718192021222324252627282930/* 游泳接口 */interface Swimming &#123; void swim();&#125;public class TestSwimming &#123; public static void main(String[] args) &#123; // 通过匿名内部类实现 goSwimming(new Swimming() &#123; @Override public void swim() &#123; System.out.println(&quot;铁汁, 我们去游泳吧&quot;); &#125; &#125;); /* 通过Lambda表达式实现 理解: 对于Lambda表达式, 对匿名内部类进行了优化 */ goSwimming(() -&gt; System.out.println(&quot;铁汁, 我们去游泳吧&quot;)); &#125; /** * 使用接口的方法 */ public static void goSwimming(Swimming swimming) &#123; swimming.swim(); &#125;&#125; 函数式编程思想概述 在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿数据做操作” 面向对象思想强调“必须通过对象的形式来做事情” 函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做” 而我们要学习的Lambda表达式就是函数式思想的体现 2.2Lambda表达式的标准格式【理解】 格式： ​ (形式参数) -&gt; {代码块} 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可 -&gt;：由英文中画线和大于符号组成，固定写法。代表指向动作 代码块：是我们具体要做的事情，也就是以前我们写的方法体内容 组成Lambda表达式的三要素： 形式参数，箭头，代码块 2.3Lambda表达式练习1【应用】 Lambda表达式的使用前提 有一个接口 接口中有且仅有一个抽象方法 练习描述 ​ 无参无返回值抽象方法的练习 操作步骤 定义一个接口(Eatable)，里面定义一个抽象方法：void eat(); 定义一个测试类(EatableDemo)，在测试类中提供两个方法 一个方法是：useEatable(Eatable e) 一个方法是主方法，在主方法中调用useEatable方法 示例代码 123456789101112131415161718192021222324252627282930313233343536//接口public interface Eatable &#123; void eat();&#125;//实现类public class EatableImpl implements Eatable &#123; @Override public void eat() &#123; System.out.println(&quot;一天一苹果，医生远离我&quot;); &#125;&#125;//测试类public class EatableDemo &#123; public static void main(String[] args) &#123; //在主方法中调用useEatable方法 Eatable e = new EatableImpl(); useEatable(e); //匿名内部类 useEatable(new Eatable() &#123; @Override public void eat() &#123; System.out.println(&quot;一天一苹果，医生远离我&quot;); &#125; &#125;); //Lambda表达式 useEatable(() -&gt; &#123; System.out.println(&quot;一天一苹果，医生远离我&quot;); &#125;); &#125; private static void useEatable(Eatable e) &#123; e.eat(); &#125;&#125; 2.4Lambda表达式练习2【应用】 练习描述 有参无返回值抽象方法的练习 操作步骤 定义一个接口(Flyable)，里面定义一个抽象方法：void fly(String s); 定义一个测试类(FlyableDemo)，在测试类中提供两个方法 一个方法是：useFlyable(Flyable f) 一个方法是主方法，在主方法中调用useFlyable方法 示例代码 1234567891011121314151617181920212223242526272829public interface Flyable &#123; void fly(String s);&#125;public class FlyableDemo &#123; public static void main(String[] args) &#123; //在主方法中调用useFlyable方法 //匿名内部类 useFlyable(new Flyable() &#123; @Override public void fly(String s) &#123; System.out.println(s); System.out.println(&quot;飞机自驾游&quot;); &#125; &#125;); System.out.println(&quot;--------&quot;); //Lambda useFlyable((String s) -&gt; &#123; System.out.println(s); System.out.println(&quot;飞机自驾游&quot;); &#125;); &#125; private static void useFlyable(Flyable f) &#123; f.fly(&quot;风和日丽，晴空万里&quot;); &#125;&#125; 2.5Lambda表达式练习3【应用】 练习描述 有参有返回值抽象方法的练习 操作步骤 定义一个接口(Addable)，里面定义一个抽象方法：int add(int x,int y); 定义一个测试类(AddableDemo)，在测试类中提供两个方法 一个方法是：useAddable(Addable a) 一个方法是主方法，在主方法中调用useAddable方法 示例代码 123456789101112131415161718public interface Addable &#123; int add(int x,int y);&#125;public class AddableDemo &#123; public static void main(String[] args) &#123; //在主方法中调用useAddable方法 useAddable((int x,int y) -&gt; &#123; return x + y; &#125;); &#125; private static void useAddable(Addable a) &#123; int sum = a.add(10, 20); System.out.println(sum); &#125;&#125; 2.6Lambda表达式的省略模式【应用】 省略的规则 参数类型可以省略。但是有多个参数的情况下，不能只省略一个 如果参数有且仅有一个，那么小括号可以省略 如果代码块的语句只有一条，可以省略大括号和分号，和return关键字 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142public interface Addable &#123; int add(int x, int y);&#125;public interface Flyable &#123; void fly(String s);&#125;public class LambdaDemo &#123; public static void main(String[] args) &#123;// useAddable((int x,int y) -&gt; &#123;// return x + y;// &#125;); //参数的类型可以省略 useAddable((x, y) -&gt; &#123; return x + y; &#125;);// useFlyable((String s) -&gt; &#123;// System.out.println(s);// &#125;); //如果参数有且仅有一个，那么小括号可以省略// useFlyable(s -&gt; &#123;// System.out.println(s);// &#125;); //如果代码块的语句只有一条，可以省略大括号和分号 useFlyable(s -&gt; System.out.println(s)); //如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉 useAddable((x, y) -&gt; x + y); &#125; private static void useFlyable(Flyable f) &#123; f.fly(&quot;风和日丽，晴空万里&quot;); &#125; private static void useAddable(Addable a) &#123; int sum = a.add(10, 20); System.out.println(sum); &#125;&#125; 2.7Lambda表达式的使用前提【理解】 使用Lambda必须要有接口 并且要求接口中有且仅有一个抽象方法 2.8Lambda表达式和匿名内部类的区别【理解】 所需类型不同 匿名内部类：可以是接口，也可以是抽象类，还可以是具体类 Lambda表达式：只能是接口 使用限制不同 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类 如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式 实现原理不同 匿名内部类：编译之后，产生一个单独的.class字节码文件 Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"接口和多态","slug":"接口和多态","date":"2021-09-06T11:59:00.000Z","updated":"2021-09-06T11:59:00.000Z","comments":true,"path":"2021/09/06/接口和多态/","link":"","permalink":"https://hujiahao.top/2021/09/06/%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%80%81/","excerpt":"","text":"1.接口1.1黑马信息管理系统集合改进 (应用) 使用数组容器的弊端 容器长度是固定的，不能根据添加功能自动增长 没有提供用于赠删改查的方法 优化步骤 创建新的StudentDao类，OtherStudentDao 创建ArrayList集合容器对象 OtherStudentDao中的方法声明，需要跟StudentDao保持一致 注意：如果不一致，StudentService中的代码就需要进行修改 完善方法（添加、删除、修改、查看） 替换StudentService中的Dao对象 代码实现 OtherStudentDao类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class OtherStudentDao &#123; // 集合容器 private static ArrayList&lt;Student&gt; stus = new ArrayList&lt;&gt;(); static &#123; Student stu1 = new Student(&quot;heima001&quot;,&quot;张三&quot;,&quot;23&quot;,&quot;1999-11-11&quot;); Student stu2 = new Student(&quot;heima002&quot;,&quot;李四&quot;,&quot;24&quot;,&quot;2000-11-11&quot;); stus.add(stu1); stus.add(stu2); &#125; // 添加学生方法 public boolean addStudent(Student stu) &#123; stus.add(stu); return true; &#125; // 查看学生方法 public Student[] findAllStudent() &#123; Student[] students = new Student[stus.size()]; for (int i = 0; i &lt; students.length; i++) &#123; students[i] = stus.get(i); &#125; return students; &#125; public void deleteStudentById(String delId) &#123; // 1. 查找id在容器中所在的索引位置 int index = getIndex(delId); stus.remove(index); &#125; public int getIndex(String id)&#123; int index = -1; for (int i = 0; i &lt; stus.size(); i++) &#123; Student stu = stus.get(i); if(stu != null &amp;&amp; stu.getId().equals(id))&#123; index = i; break; &#125; &#125; return index; &#125; public void updateStudent(String updateId, Student newStu) &#123; // 1. 查找updateId, 在容器中的索引位置 int index = getIndex(updateId); stus.set(index, newStu); &#125;&#125; StudentService类 12345public class StudentService &#123; // 创建StudentDao (库管) private OtherStudentDao studentDao = new OtherStudentDao(); // 其他方法没有变化,此处省略...&#125; 1.2黑马信息管理系统抽取Dao (应用) 优化步骤 将方法向上抽取，抽取出一个父类 （ BaseStudentDao ） 方法的功能实现在父类中无法给出具体明确，定义为抽象方法 让两个类分别继承 BaseStudentDao ，重写内部抽象方法 代码实现 BaseStudentDao类 123456789101112public abstract class BaseStudentDao &#123; // 添加学生方法 public abstract boolean addStudent(Student stu); // 查看学生方法 public abstract Student[] findAllStudent(); // 删除学生方法 public abstract void deleteStudentById(String delId); // 根据id找索引方法 public abstract int getIndex(String id); // 修改学生方法 public abstract void updateStudent(String updateId, Student newStu);&#125; StudentDao类 123public class StudentDao extends BaseStudentDao &#123; // 其他内容不变,此处省略&#125; OtherStudentDao类 123public class OtherStudentDao extends BaseStudentDao &#123; // 其他内容不变,此处省略&#125; 1.3接口的概述（理解） 接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用。 Java中接口存在的两个意义 用来定义规范 用来做功能的拓展 1.4接口的特点（记忆） 接口用关键字interface修饰 1public interface 接口名 &#123;&#125; 类实现接口用implements表示 1public class 类名 implements 接口名 &#123;&#125; 接口不能实例化 ​ 我们可以创建接口的实现类对象使用 接口的子类 ​ 要么重写接口中的所有抽象方法 ​ 要么子类也是抽象类 1.5接口的成员特点（记忆） 成员特点 成员变量 ​ 只能是常量​ 默认修饰符：public static final 构造方法 ​ 没有，因为接口主要是扩展功能的，而没有具体存在 成员方法 ​ 只能是抽象方法 ​ 默认修饰符：public abstract ​ 关于接口中的方法，JDK8和JDK9中有一些新特性，后面再讲解 代码演示 接口 12345public interface Inter &#123; public static final int NUM = 10; public abstract void show();&#125; 实现类 1234567891011class InterImpl implements Inter&#123; public void method()&#123; // NUM = 20; System.out.println(NUM); &#125; public void show()&#123; &#125;&#125; 测试类 12345678910111213public class TestInterface &#123; /* 成员变量: 只能是常量 系统会默认加入三个关键字 public static final 构造方法: 没有 成员方法: 只能是抽象方法, 系统会默认加入两个关键字 public abstract */ public static void main(String[] args) &#123; System.out.println(Inter.NUM); &#125; &#125; 1.6类和接口的关系（记忆） 类与类的关系 ​ 继承关系，只能单继承，但是可以多层继承 类与接口的关系 ​ 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口 接口与接口的关系 ​ 继承关系，可以单继承，也可以多继承 1.7黑马信息管理系统使用接口改进 (应用) 实现步骤 将 BaseStudentDao 改进为一个接口 让 StudentDao 和 OtherStudentDao 去实现这个接口 代码实现 BaseStudentDao接口 123456789101112public interface BaseStudentDao &#123; // 添加学生方法 public abstract boolean addStudent(Student stu); // 查看学生方法 public abstract Student[] findAllStudent(); // 删除学生方法 public abstract void deleteStudentById(String delId); // 根据id找索引方法 public abstract int getIndex(String id); // 修改学生方法 public abstract void updateStudent(String updateId, Student newStu);&#125; StudentDao类 123public class StudentDao implements BaseStudentDao &#123; // 其他内容不变,此处省略&#125; OtherStudentDao类 123public class OtherStudentDao implements BaseStudentDao &#123; // 其他内容不变,此处省略&#125; 1.8黑马信息管理系统解耦合改进 (应用) 实现步骤 创建factory包，创建 StudentDaoFactory（工厂类） 提供 static 修改的 getStudentDao 方法，该方法用于创建StudentDao对象并返回 代码实现 StudentDaoFactory类 12345public class StudentDaoFactory &#123; public static OtherStudentDao getStudentDao()&#123; return new OtherStudentDao(); &#125;&#125; StudentService类 1234567public class StudentService &#123; // 创建StudentDao (库管) // private OtherStudentDao studentDao = new OtherStudentDao(); // 通过学生库管工厂类, 获取库管对象 private OtherStudentDao studentDao = StudentDaoFactory.getStudentDao();&#125; 2.接口组成更新 2.1接口组成更新概述【理解】 常量 public static final 抽象方法 public abstract 默认方法(Java 8) 静态方法(Java 8) 私有方法(Java 9) 2.2接口中默认方法【应用】 格式 public default 返回值类型 方法名(参数列表) { } 作用 解决接口升级的问题 范例 12public default void show3() &#123; &#125; 注意事项 默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字 public可以省略，default不能省略 如果实现了多个接口，多个接口中存在相同的方法声明，子类就必须对该方法进行重写 2.3接口中静态方法【应用】 格式 public static 返回值类型 方法名(参数列表) { } 范例 12public static void show() &#123;&#125; 注意事项 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用 public可以省略，static不能省略 2.4接口中私有方法【应用】 私有方法产生原因 Java 9中新增了带方法体的私有方法，这其实在Java 8中就埋下了伏笔：Java 8允许在接口中定义带方法体的默认方法和静态方法。这样可能就会引发一个问题：当两个默认方法或者静态方法中包含一段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要让别人使用的，因此用私有给隐藏起来，这就是Java 9增加私有方法的必然性 定义格式 格式1 private 返回值类型 方法名(参数列表) { } 范例1 12private void show() &#123; &#125; 格式2 private static 返回值类型 方法名(参数列表) { } 范例2 12private static void method() &#123; &#125; 注意事项 默认方法可以调用私有的静态方法和非静态方法 静态方法只能调用私有的静态方法 3.多态3.1多态的概述（记忆） 什么是多态 ​ 同一个对象，在不同时刻表现出来的不同形态 多态的前提 要有继承或实现关系 要有方法的重写 要有父类引用指向子类对象 代码演示 123456789101112131415161718192021222324252627282930class Animal &#123; public void eat()&#123; System.out.println(&quot;动物吃饭&quot;); &#125;&#125;class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(&quot;猫吃鱼&quot;); &#125;&#125;public class Test1Polymorphic &#123; /* 多态的前提: 1. 要有(继承 \\ 实现)关系 2. 要有方法重写 3. 要有父类引用, 指向子类对象 */ public static void main(String[] args) &#123; // 当前事物, 是一只猫 Cat c = new Cat(); // 当前事物, 是一只动物 Animal a = new Cat(); a.eat(); &#125;&#125; 3.2多态中的成员访问特点（记忆） 成员访问特点 成员变量 ​ 编译看父类，运行看父类 成员方法 ​ 编译看父类，运行看子类 代码演示 123456789101112131415161718192021222324252627282930class Fu &#123; int num = 10; public void method()&#123; System.out.println(&quot;Fu.. method&quot;); &#125;&#125;class Zi extends Fu &#123; int num = 20; public void method()&#123; System.out.println(&quot;Zi.. method&quot;); &#125;&#125;public class Test2Polymorpic &#123; /* 多态的成员访问特点: 成员变量: 编译看左边 (父类), 运行看左边 (父类) 成员方法: 编译看左边 (父类), 运行看右边 (子类) */ public static void main(String[] args) &#123; Fu f = new Zi(); System.out.println(f.num); f.method(); &#125;&#125; 3.3多态的好处和弊端（记忆） 好处 ​ 提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作 弊端 ​ 不能使用子类的特有成员 3.4多态中的转型（应用） 向上转型 ​ 父类引用指向子类对象就是向上转型 向下转型 ​ 格式：子类型 对象名 = (子类型)父类引用; 代码演示 123456789101112131415161718192021222324252627282930313233class Fu &#123; public void show()&#123; System.out.println(&quot;Fu..show...&quot;); &#125;&#125;class Zi extends Fu &#123; @Override public void show() &#123; System.out.println(&quot;Zi..show...&quot;); &#125; public void method()&#123; System.out.println(&quot;我是子类特有的方法, method&quot;); &#125;&#125;public class Test3Polymorpic &#123; public static void main(String[] args) &#123; // 1. 向上转型 : 父类引用指向子类对象 Fu f = new Zi(); f.show(); // 多态的弊端: 不能调用子类特有的成员 // f.method(); // A: 直接创建子类对象 // B: 向下转型 // 2. 向下转型 : 从父类类型, 转换回子类类型 Zi z = (Zi) f; z.method(); &#125;&#125; 3.5多态中转型存在的风险和解决方案 (应用) 风险 如果被转的引用类型变量,对应的实际类型和目标类型不是同一种类型,那么在转换的时候就会出现ClassCastException 解决方案 关键字 instanceof 使用格式 变量名 instanceof 类型 通俗的理解：判断关键字左边的变量，是否是右边的类型，返回boolean类型结果 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142abstract class Animal &#123; public abstract void eat();&#125;class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;狗吃肉&quot;); &#125; public void watchHome()&#123; System.out.println(&quot;看家&quot;); &#125;&#125;class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;猫吃鱼&quot;); &#125;&#125;public class Test4Polymorpic &#123; public static void main(String[] args) &#123; useAnimal(new Dog()); useAnimal(new Cat()); &#125; public static void useAnimal(Animal a)&#123; // Animal a = new Dog(); // Animal a = new Cat(); a.eat(); //a.watchHome();// Dog dog = (Dog) a;// dog.watchHome(); // ClassCastException 类型转换异常 // 判断a变量记录的类型, 是否是Dog if(a instanceof Dog)&#123; Dog dog = (Dog) a; dog.watchHome(); &#125; &#125;&#125; 3.6黑马信息管理系统多态改进 (应用) 实现步骤 StudentDaoFactory类中方法的返回值定义成父类类型BaseStudentDao StudentService中接收方法返回值的类型定义成父类类型BaseStudentDao 代码实现 StudentDaoFactory类 12345public class StudentDaoFactory &#123; public static BaseStudentDao getStudentDao()&#123; return new OtherStudentDao(); &#125;&#125; StudentService类 1234567public class StudentService &#123; // 创建StudentDao (库管) // private OtherStudentDao studentDao = new OtherStudentDao(); // 通过学生库管工厂类, 获取库管对象 private BaseStudentDao studentDao = StudentDaoFactory.getStudentDao();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"继承","slug":"继承","date":"2021-09-05T11:59:00.000Z","updated":"2021-09-05T11:59:00.000Z","comments":true,"path":"2021/09/05/继承/","link":"","permalink":"https://hujiahao.top/2021/09/05/%E7%BB%A7%E6%89%BF/","excerpt":"","text":"1. 继承1.1 继承的实现（掌握） 继承的概念 继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，以及追加属性和方法 实现继承的格式 继承通过extends实现 格式：class 子类 extends 父类 { } 举例：class Dog extends Animal { } 继承带来的好处 继承可以让类与类之间产生关系，子父类关系，产生子父类后，子类则可以使用父类中非私有的成员。 示例代码 123456789101112131415161718192021public class Fu &#123; public void show() &#123; System.out.println(&quot;show方法被调用&quot;); &#125;&#125;public class Zi extends Fu &#123; public void method() &#123; System.out.println(&quot;method方法被调用&quot;); &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; //创建对象，调用方法 Fu f = new Fu(); f.show(); Zi z = new Zi(); z.method(); z.show(); &#125;&#125; 1.2 继承的好处和弊端（理解） 继承好处 提高了代码的复用性(多个类相同的成员可以放到同一个类中) 提高了代码的维护性(如果方法的代码需要修改，修改一处即可) 继承弊端 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性 继承的应用场景： 使用继承，需要考虑类与类之间是否存在is..a的关系，不能盲目使用继承 is..a的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类 1.3. Java中继承的特点（掌握） Java中继承的特点 Java中类只支持单继承，不支持多继承 错误范例：class A extends B, C { } Java中类支持多层继承 多层继承示例代码： 1234567891011121314151617181920212223242526public class Granddad &#123; public void drink() &#123; System.out.println(&quot;爷爷爱喝酒&quot;); &#125;&#125;public class Father extends Granddad &#123; public void smoke() &#123; System.out.println(&quot;爸爸爱抽烟&quot;); &#125;&#125;public class Mother &#123; public void dance() &#123; System.out.println(&quot;妈妈爱跳舞&quot;); &#125;&#125;public class Son extends Father &#123; // 此时，Son类中就同时拥有drink方法以及smoke方法&#125; 2. 继承中的成员访问特点 2.1 继承中变量的访问特点（掌握）在子类方法中访问一个变量，采用的是就近原则。 子类局部范围找 子类成员范围找 父类成员范围找 如果都没有就报错(不考虑父亲的父亲…) 示例代码 12345678910111213141516class Fu &#123; int num = 10;&#125;class Zi &#123; int num = 20; public void show()&#123; int num = 30; System.out.println(num); &#125;&#125;public class Demo1 &#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); // 输出show方法中的局部变量30 &#125;&#125; 2.2 super（掌握） this&amp;super关键字： this：代表本类对象的引用 super：代表父类存储空间的标识(可以理解为父类对象引用) this和super的使用分别 成员变量： this.成员变量 - 访问本类成员变量 super.成员变量 - 访问父类成员变量 成员方法： this.成员方法 - 访问本类成员方法 super.成员方法 - 访问父类成员方法 构造方法： this(…) - 访问本类构造方法 super(…) - 访问父类构造方法 2.3 继承中构造方法的访问特点（理解）注意：子类中所有的构造方法默认都会访问父类中无参的构造方法 ​ 子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于，每一个子类构造方法的第一条语句默认都是：super() 问题：如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？ 12341. 通过使用super关键字去显示的调用父类的带参构造方法2. 子类通过this去调用本类的其他构造方法,本类其他构造方法再通过super去手动调用父类的带参的构造方法注意: this(…)super(…) 必须放在构造方法的第一行有效语句，并且二者不能共存 2.4 继承中成员方法的访问特点（掌握）通过子类对象访问一个方法 子类成员范围找 父类成员范围找 如果都没有就报错(不考虑父亲的父亲…) 2.5 super内存图（理解） 对象在堆内存中，会单独存在一块super区域，用来存放父类的数据 2.6 方法重写（掌握） 1、方法重写概念 子类出现了和父类中一模一样的方法声明（方法名一样，参数列表也必须一样） 2、方法重写的应用场景 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容 3、@Override注解 用来检测当前的方法，是否是重写的方法，起到【校验】的作用 2.7 方法重写的注意事项（掌握） 方法重写的注意事项 私有方法不能被重写(父类私有成员子类是不能继承的) 子类方法访问权限不能更低(public &gt; 默认 &gt; 私有) 静态方法不能被重写,如果子类也有相同的方法,并不是重写的父类的方法 示例代码 123456789101112131415161718192021222324252627282930public class Fu &#123; private void show() &#123; System.out.println(&quot;Fu中show()方法被调用&quot;); &#125; void method() &#123; System.out.println(&quot;Fu中method()方法被调用&quot;); &#125;&#125;public class Zi extends Fu &#123; /* 编译【出错】，子类不能重写父类私有的方法*/ @Override private void show() &#123; System.out.println(&quot;Zi中show()方法被调用&quot;); &#125; /* 编译【出错】，子类重写父类方法的时候，访问权限需要大于等于父类 */ @Override private void method() &#123; System.out.println(&quot;Zi中method()方法被调用&quot;); &#125; /* 编译【通过】，子类重写父类方法的时候，访问权限需要大于等于父类 */ @Override public void method() &#123; System.out.println(&quot;Zi中method()方法被调用&quot;); &#125;&#125; 2.8 权限修饰符 (理解) 2.9 黑马信息管理系统使用继承改进 (掌握) 需求 把学生类和老师类共性的内容向上抽取,抽取到出一个 Person 父类,让学生类和老师类继承 Person 类 实现步骤 抽取Person类 优化StudentController类中，inputStudentInfo方法，将setXxx赋值方式，改进为构造方法初始化 注意：直接修改这种操作方式，不符合我们开发中的一个原则 ​ 开闭原则 ( 对扩展开放对修改关闭 ) : 尽量在不更改原有代码的前提下以完成需求 解决：重新创建一个OtherStudentController类 编写新的inputStudentInfo方法 根据StudentController类、OtherStudentController类，向上抽取出BaseStudentController类再让StudentController类、OtherStudentController类，继承BaseStudentController类 代码实现 Person类及学生类和老师类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Person &#123; private String id; private String name; private String age; private String birthday; public Person() &#123; &#125; public Person(String id, String name, String age, String birthday) &#123; this.id = id; this.name = name; this.age = age; this.birthday = birthday; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125;&#125;// Student类public class Student extends Person &#123; public Student() &#123; &#125; public Student(String id, String name, String age, String birthday) &#123; super(id, name, age, birthday); &#125;&#125;// Teacher类public class Teacher extends Person &#123; public Teacher() &#123; &#125; public Teacher(String id, String name, String age, String birthday) &#123; super(id, name, age, birthday); &#125;&#125; BaseStudentController类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public abstract class BaseStudentController &#123; // 业务员对象 private StudentService studentService = new StudentService(); private Scanner sc = new Scanner(System.in); // 开启学生管理系统, 并展示学生管理系统菜单 public void start() &#123; //Scanner sc = new Scanner(System.in); studentLoop: while (true) &#123; System.out.println(&quot;--------欢迎来到 &lt;学生&gt; 管理系统--------&quot;); System.out.println(&quot;请输入您的选择: 1.添加学生 2.删除学生 3.修改学生 4.查看学生 5.退出&quot;); String choice = sc.next(); switch (choice) &#123; case &quot;1&quot;: // System.out.println(&quot;添加&quot;); addStudent(); break; case &quot;2&quot;: // System.out.println(&quot;删除&quot;); deleteStudentById(); break; case &quot;3&quot;: // System.out.println(&quot;修改&quot;); updateStudent(); break; case &quot;4&quot;: // System.out.println(&quot;查询&quot;); findAllStudent(); break; case &quot;5&quot;: System.out.println(&quot;感谢您使用学生管理系统, 再见!&quot;); break studentLoop; default: System.out.println(&quot;您的输入有误, 请重新输入&quot;); break; &#125; &#125; &#125; // 修改学生方法 public void updateStudent() &#123; String updateId = inputStudentId(); Student newStu = inputStudentInfo(updateId); studentService.updateStudent(updateId, newStu); System.out.println(&quot;修改成功!&quot;); &#125; // 删除学生方法 public void deleteStudentById() &#123; String delId = inputStudentId(); // 3. 调用业务员中的deleteStudentById根据id, 删除学生 studentService.deleteStudentById(delId); // 4. 提示删除成功 System.out.println(&quot;删除成功!&quot;); &#125; // 查看学生方法 public void findAllStudent() &#123; // 1. 调用业务员中的获取方法, 得到学生的对象数组 Student[] stus = studentService.findAllStudent(); // 2. 判断数组的内存地址, 是否为null if (stus == null) &#123; System.out.println(&quot;查无信息, 请添加后重试&quot;); return; &#125; // 3. 遍历数组, 获取学生信息并打印在控制台 System.out.println(&quot;学号\\t\\t姓名\\t年龄\\t生日&quot;); for (int i = 0; i &lt; stus.length; i++) &#123; Student stu = stus[i]; if (stu != null) &#123; System.out.println(stu.getId() + &quot;\\t&quot; + stu.getName() + &quot;\\t&quot; + stu.getAge() + &quot;\\t\\t&quot; + stu.getBirthday()); &#125; &#125; &#125; // 添加学生方法 public void addStudent() &#123; // StudentService studentService = new StudentService(); // 1. 键盘接收学生信息 String id; while (true) &#123; System.out.println(&quot;请输入学生id:&quot;); id = sc.next(); boolean flag = studentService.isExists(id); if (flag) &#123; System.out.println(&quot;学号已被占用, 请重新输入&quot;); &#125; else &#123; break; &#125; &#125; Student stu = inputStudentInfo(id); // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法 boolean result = studentService.addStudent(stu); // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败 if (result) &#123; System.out.println(&quot;添加成功&quot;); &#125; else &#123; System.out.println(&quot;添加失败&quot;); &#125; &#125; // 键盘录入学生id public String inputStudentId() &#123; String id; while (true) &#123; System.out.println(&quot;请输入学生id:&quot;); id = sc.next(); boolean exists = studentService.isExists(id); if (!exists) &#123; System.out.println(&quot;您输入的id不存在, 请重新输入:&quot;); &#125; else &#123; break; &#125; &#125; return id; &#125; // 键盘录入学生信息 // 开闭原则: 对扩展内容开放, 对修改内容关闭 public Student inputStudentInfo(String id)&#123; return null; &#125;&#125; StudentController类 12345678910111213141516171819202122public class StudentController extends BaseStudentController &#123; private Scanner sc = new Scanner(System.in); // 键盘录入学生信息 // 开闭原则: 对扩展内容开放, 对修改内容关闭 @Override public Student inputStudentInfo(String id) &#123; System.out.println(&quot;请输入学生姓名:&quot;); String name = sc.next(); System.out.println(&quot;请输入学生年龄:&quot;); String age = sc.next(); System.out.println(&quot;请输入学生生日:&quot;); String birthday = sc.next(); Student stu = new Student(); stu.setId(id); stu.setName(name); stu.setAge(age); stu.setBirthday(birthday); return stu; &#125;&#125; OtherStudentController类 123456789101112131415161718public class OtherStudentController extends BaseStudentController &#123; private Scanner sc = new Scanner(System.in); // 键盘录入学生信息 // 开闭原则: 对扩展内容开放, 对修改内容关闭 @Override public Student inputStudentInfo(String id) &#123; System.out.println(&quot;请输入学生姓名:&quot;); String name = sc.next(); System.out.println(&quot;请输入学生年龄:&quot;); String age = sc.next(); System.out.println(&quot;请输入学生生日:&quot;); String birthday = sc.next(); Student stu = new Student(id,name,age,birthday); return stu; &#125;&#125; 3.抽象类 3.1抽象类的概述（理解）​ 当我们在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了！ ​ 在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！ 3.2抽象类的特点（记忆） 抽象类和抽象方法必须使用 abstract 关键字修饰 12345//抽象类的定义public abstract class 类名 &#123;&#125;//抽象方法的定义public abstract void eat(); 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类 抽象类不能实例化 抽象类可以有构造方法 抽象类的子类 ​ 要么重写抽象类中的所有抽象方法 ​ 要么是抽象类 3.3抽象类的案例（应用） 案例需求 ​ 定义猫类(Cat)和狗类(Dog) ​ 猫类成员方法：eat（猫吃鱼）drink（喝水…） ​ 狗类成员方法：eat（狗吃肉）drink（喝水…） 实现步骤 猫类和狗类中存在共性内容，应向上抽取出一个动物类（Animal） 父类Animal中，无法将 eat 方法具体实现描述清楚，所以定义为抽象方法 抽象方法需要存活在抽象类中，将Animal定义为抽象类 让 Cat 和 Dog 分别继承 Animal，重写eat方法 测试类中创建 Cat 和 Dog 对象，调用方法测试 代码实现 动物类 1234567891011public abstract class Animal &#123; public void drink()&#123; System.out.println(&quot;喝水&quot;); &#125; public Animal()&#123; &#125; public abstract void eat();&#125; 猫类 123456public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(&quot;猫吃鱼&quot;); &#125;&#125; 狗类 123456public class Dog extends Animal &#123; @Override public void eat() &#123; System.out.println(&quot;狗吃肉&quot;); &#125;&#125; 测试类 123456789101112public static void main(String[] args) &#123; Dog d = new Dog(); d.eat(); d.drink(); Cat c = new Cat(); c.drink(); c.eat(); //Animal a = new Animal(); //a.eat(); &#125; 3.4模板设计模式 设计模式 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。 模板设计模式 把抽象类整体就可以看做成一个模板，模板中不能决定的东西定义成抽象方法让使用模板的类（继承抽象类的类）去重写抽象方法实现需求 模板设计模式的优势 模板已经定义了通用结构，使用者只需要关心自己需要实现的功能即可 示例代码 模板类 12345678910111213141516/* 作文模板类 */public abstract class CompositionTemplate &#123; public final void write()&#123; System.out.println(&quot;&lt;&lt;我的爸爸&gt;&gt;&quot;); body(); System.out.println(&quot;啊~ 这就是我的爸爸&quot;); &#125; public abstract void body();&#125; 实现类A 12345678public class Tom extends CompositionTemplate &#123; @Override public void body() &#123; System.out.println(&quot;那是一个秋天, 风儿那么缠绵,记忆中, &quot; + &quot;那天爸爸骑车接我放学回家,我的脚卡在了自行车链当中, 爸爸蹬不动,他就站起来蹬...&quot;); &#125;&#125; 实现类B 12345678910public class Tony extends CompositionTemplate &#123; @Override public void body() &#123; &#125; /*public void write()&#123; &#125;*/&#125; 测试类 123456public class Test &#123; public static void main(String[] args) &#123; Tom t = new Tom(); t.write(); &#125;&#125; 3.5final（应用） fianl关键字的作用 final代表最终的意思，可以修饰成员方法，成员变量，类 final修饰类、方法、变量的效果 fianl修饰类：该类不能被继承（不能有子类，但是可以有父类） final修饰方法：该方法不能被重写 final修饰变量：表明该变量是一个常量，不能再次赋值 变量是基本类型,不能改变的是值 变量是引用类型,不能改变的是地址值,但地址里面的内容是可以改变的 举例 12345public static void main(String[] args)&#123; final Student s = new Student(23); s = new Student(24); // 错误 s.setAge(24); // 正确&#125; 3.6黑马信息管理系统使用抽象类改进 (应用) 需求 使用抽象类的思想，将BaseStudentController 中的 inputStudentInfo 方法，定义为抽象方法 将不希望子类重写的方法，使用 final 进行修饰 代码实现 BaseStudentController类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public abstract class BaseStudentController &#123; // 业务员对象 private StudentService studentService = new StudentService(); private Scanner sc = new Scanner(System.in); // 开启学生管理系统, 并展示学生管理系统菜单 public final void start() &#123; //Scanner sc = new Scanner(System.in); studentLoop: while (true) &#123; System.out.println(&quot;--------欢迎来到 &lt;学生&gt; 管理系统--------&quot;); System.out.println(&quot;请输入您的选择: 1.添加学生 2.删除学生 3.修改学生 4.查看学生 5.退出&quot;); String choice = sc.next(); switch (choice) &#123; case &quot;1&quot;: // System.out.println(&quot;添加&quot;); addStudent(); break; case &quot;2&quot;: // System.out.println(&quot;删除&quot;); deleteStudentById(); break; case &quot;3&quot;: // System.out.println(&quot;修改&quot;); updateStudent(); break; case &quot;4&quot;: // System.out.println(&quot;查询&quot;); findAllStudent(); break; case &quot;5&quot;: System.out.println(&quot;感谢您使用学生管理系统, 再见!&quot;); break studentLoop; default: System.out.println(&quot;您的输入有误, 请重新输入&quot;); break; &#125; &#125; &#125; // 修改学生方法 public final void updateStudent() &#123; String updateId = inputStudentId(); Student newStu = inputStudentInfo(updateId); studentService.updateStudent(updateId, newStu); System.out.println(&quot;修改成功!&quot;); &#125; // 删除学生方法 public final void deleteStudentById() &#123; String delId = inputStudentId(); // 3. 调用业务员中的deleteStudentById根据id, 删除学生 studentService.deleteStudentById(delId); // 4. 提示删除成功 System.out.println(&quot;删除成功!&quot;); &#125; // 查看学生方法 public final void findAllStudent() &#123; // 1. 调用业务员中的获取方法, 得到学生的对象数组 Student[] stus = studentService.findAllStudent(); // 2. 判断数组的内存地址, 是否为null if (stus == null) &#123; System.out.println(&quot;查无信息, 请添加后重试&quot;); return; &#125; // 3. 遍历数组, 获取学生信息并打印在控制台 System.out.println(&quot;学号\\t\\t姓名\\t年龄\\t生日&quot;); for (int i = 0; i &lt; stus.length; i++) &#123; Student stu = stus[i]; if (stu != null) &#123; System.out.println(stu.getId() + &quot;\\t&quot; + stu.getName() + &quot;\\t&quot; + stu.getAge() + &quot;\\t\\t&quot; + stu.getBirthday()); &#125; &#125; &#125; // 添加学生方法 public final void addStudent() &#123; // StudentService studentService = new StudentService(); // 1. 键盘接收学生信息 String id; while (true) &#123; System.out.println(&quot;请输入学生id:&quot;); id = sc.next(); boolean flag = studentService.isExists(id); if (flag) &#123; System.out.println(&quot;学号已被占用, 请重新输入&quot;); &#125; else &#123; break; &#125; &#125; Student stu = inputStudentInfo(id); // 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法 boolean result = studentService.addStudent(stu); // 4. 根据返回的boolean类型结果, 在控制台打印成功\\失败 if (result) &#123; System.out.println(&quot;添加成功&quot;); &#125; else &#123; System.out.println(&quot;添加失败&quot;); &#125; &#125; // 键盘录入学生id public String inputStudentId() &#123; String id; while (true) &#123; System.out.println(&quot;请输入学生id:&quot;); id = sc.next(); boolean exists = studentService.isExists(id); if (!exists) &#123; System.out.println(&quot;您输入的id不存在, 请重新输入:&quot;); &#125; else &#123; break; &#125; &#125; return id; &#125; // 键盘录入学生信息 // 开闭原则: 对扩展内容开放, 对修改内容关闭 public abstract Student inputStudentInfo(String id);&#125; 4.代码块 4.1代码块概述 (理解)在Java中，使用 { } 括起来的代码被称为代码块 4.2代码块分类 (理解) 局部代码块 位置: 方法中定义 作用: 限定变量的生命周期，及早释放，提高内存利用率 示例代码 123456789101112131415public class Test &#123; /* 局部代码块 位置：方法中定义 作用：限定变量的生命周期，及早释放，提高内存利用率 */ public static void main(String[] args) &#123; &#123; int a = 10; System.out.println(a); &#125; // System.out.println(a); &#125;&#125; 构造代码块 位置: 类中方法外定义 特点: 每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行 作用: 将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性 示例代码 123456789101112131415161718192021222324252627public class Test &#123; /* 构造代码块: 位置：类中方法外定义 特点：每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行 作用：将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性 */ public static void main(String[] args) &#123; Student stu1 = new Student(); Student stu2 = new Student(10); &#125;&#125;class Student &#123; &#123; System.out.println(&quot;好好学习&quot;); &#125; public Student()&#123; System.out.println(&quot;空参数构造方法&quot;); &#125; public Student(int a)&#123; System.out.println(&quot;带参数构造方法...........&quot;); &#125;&#125; 静态代码块 位置: 类中方法外定义 特点: 需要通过static关键字修饰，随着类的加载而加载，并且只执行一次 作用: 在类加载的时候做一些数据初始化的操作 示例代码 1234567891011121314151617181920212223242526public class Test &#123; /* 静态代码块: 位置：类中方法外定义 特点：需要通过static关键字修饰，随着类的加载而加载，并且只执行一次 作用：在类加载的时候做一些数据初始化的操作 */ public static void main(String[] args) &#123; Person p1 = new Person(); Person p2 = new Person(10); &#125;&#125;class Person &#123; static &#123; System.out.println(&quot;我是静态代码块, 我执行了&quot;); &#125; public Person()&#123; System.out.println(&quot;我是Person类的空参数构造方法&quot;); &#125; public Person(int a)&#123; System.out.println(&quot;我是Person类的带...........参数构造方法&quot;); &#125;&#125; 4.3黑马信息管理系统使用代码块改进 (应用) 需求 使用静态代码块，初始化一些学生数据 实现步骤 在StudentDao类中定义一个静态代码块，用来初始化一些学生数据 将初始化好的学生数据存储到学生数组中 示例代码 StudentDao类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class StudentDao &#123; // 创建学生对象数组 private static Student[] stus = new Student[5]; static &#123; Student stu1 = new Student(&quot;heima001&quot;,&quot;张三&quot;,&quot;23&quot;,&quot;1999-11-11&quot;); Student stu2 = new Student(&quot;heima002&quot;,&quot;李四&quot;,&quot;24&quot;,&quot;2000-11-11&quot;); stus[0] = stu1; stus[1] = stu2; &#125; // 添加学生方法 public boolean addStudent(Student stu) &#123; // 2. 添加学生到数组 //2.1 定义变量index为-1，假设数组已经全部存满，没有null的元素 int index = -1; //2.2 遍历数组取出每一个元素，判断是否是null for (int i = 0; i &lt; stus.length; i++) &#123; Student student = stus[i]; if(student == null)&#123; index = i; //2.3 如果为null，让index变量记录当前索引位置，并使用break结束循环遍历 break; &#125; &#125; // 3. 返回是否添加成功的boolean类型状态 if(index == -1)&#123; // 装满了 return false; &#125;else&#123; // 没有装满, 正常添加, 返回true stus[index] = stu; return true; &#125; &#125; // 查看学生方法 public Student[] findAllStudent() &#123; return stus; &#125; public void deleteStudentById(String delId) &#123; // 1. 查找id在容器中所在的索引位置 int index = getIndex(delId); // 2. 将该索引位置,使用null元素进行覆盖 stus[index] = null; &#125; public int getIndex(String id)&#123; int index = -1; for (int i = 0; i &lt; stus.length; i++) &#123; Student stu = stus[i]; if(stu != null &amp;&amp; stu.getId().equals(id))&#123; index = i; break; &#125; &#125; return index; &#125; public void updateStudent(String updateId, Student newStu) &#123; // 1. 查找updateId, 在容器中的索引位置 int index = getIndex(updateId); // 2. 将该索引位置, 使用新的学生对象替换 stus[index] = newStu; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"Spring框架","slug":"Spring","date":"2021-03-19T15:10:06.000Z","updated":"2021-03-19T15:10:06.000Z","comments":true,"path":"2021/03/19/Spring/","link":"","permalink":"https://hujiahao.top/2021/03/19/Spring/","excerpt":"","text":"Why Spring? Spring makes programming Java quicker,easier, and safer for everybody. Spring’s focus on speed, simplicity, and productivity has made it the world’s most popular Java framework. Spring概述1、什么是Spring? Spring 是轻量级的开源的 JavaEE 框架，Spring框架的核心功能可以应用在任何Java应用程序中，但对Java EE平台上的Web应用程序有更好的扩展性。 Spring框架的目标是使得Java EE应用程序的开发更加简捷，通过使用POJO为基础的编程模型促进良好的编程风格。 注：POJO和JavaBean的区别 （1）POJO 和JavaBean是我们常见的两个关键字，一般容易混淆，POJO全称是Plain Ordinary Java Object / Pure Old Java Object，中文可以翻译成：普通Java类，具有一部分getter/setter方法的那种类就可以称作POJO，但是JavaBean则比 POJO复杂很多， Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java 类都可以是一个 Bean 。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat) 的，所以 Java Bean 应具有一个无参的构造器。 （2）通常 Java Bean 还要实现 Serializable 接口用于实现 Bean 的持久性。 Java Bean 是不能被跨进程访问的。JavaBean是一种组件技术，就好像你做了一个扳子，而这个扳子会在很多地方被拿去用，这个扳子也提供多种功能(你可以拿这个扳子扳、锤、撬等等)，而这个扳子就是一个组件。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为POJO。POJO(Plain Old Java Object)这个名字用来强调它是一个普通java对象，而不是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定或框架（如EJB）的Java对象。理想地讲，一个POJO是一个不受任何限制的Java对象（除了Java语言规范）。 2、Spring有哪些优点？ 轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。 控制反转(IoC)： Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。 面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。 容器：Spring包含并管理应用程序对象的配置及生命周期。 MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。 事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。 异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。 3、Spring 有两个核心部分：IOC 和 AOP（1）IOC：控制反转，把创建对象过程交给 Spring 进行管理 （2）AOP：面向切面，不修改源代码进行功能增强 4、Spring的特点（1）方便解耦，简化开发 （2）Aop 编程支持 （3）方便程序测试 （4）方便和其他框架进行整合 （5）方便进行事务操作 （6）降低 API 开发难度 5、Spring架构图，Spring由哪些模块组成？Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 以下是 Spring 5 的模块结构图： 图来源于官网，以下各个模块的介绍。 第一个Spring项目1、下载Spring，目前版本5.3.4下载地址：https://repo.spring.io/release/org/springframework/spring/ 2、打开Idea创建一个普通的Java工程，导入Spring5的相关jar包 commons-logging-1.2.jar，下载链接：http://commons.apache.org/proper/commons-logging/download_logging.cgi 3、创建一个User.java类123456public class User &#123; public void add()&#123; System.out.println(&quot;add......&quot;); &#125;&#125; 4、在src目录下创建Spring配置文件，bean1.xml bean1.xml 1234567&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.jiahao.spring5.User&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 5、创建测试类Test.java 1234567891011@Testpublic void TestAdd()&#123; //加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); //获取配置创建的文件 User user = context.getBean(&quot;user&quot;,User.class); System.out.println(user); user.add();&#125; 6、输出结果 123com.jiahao.spring5.User@612fc6ebadd...... IOC(概念和原理)1、什么是IOC? Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。 使用目的：降低解耦。 2、IOC底层 xml解析、工厂模式、反射 画图讲解 IOC 底层原理: 3、IOC（BeanFactory 接口） 1、IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂 2、Spring 提供 IOC 容器实现两种方式：（两个接口） （1）BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 ​ 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象 （2）ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人 员进行使用 ​ 加载配置文件时候就会把在配置文件对象进行创建 推荐使用 3、ApplicationContext通常的实现是什么? FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean配置文件的全路径名必须提供给它的构造函数。 ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。 4、IOC的优点是什么？ IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。 5、Bean 工厂和 Application contexts 有什么区别？ Application contexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Application contexts中以声明的方式处理。Application contexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。 IOC操作Bean管理1、概念1.1、什么是 Bean 管理 ​ （0）Bean 管理指的是两个操作 ​ （1）Spring 创建对象 ​ （2）Spirng 注入属性 2.2、Bean 管理操作有两种方式 ​ （1）基于 xml 配置文件方式实现 ​ （2）基于注解方式实现 2、基于 xml 方式2.1、基于 xml 方式创建对象 12 &lt;!--配置User对象创建--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.jiahao.spring5.User&quot;&gt;&lt;/bean&gt; （1）在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建 （2）在 bean 标签有很多属性，介绍常用的属性 * id 属性：唯一标识 * class 属性：类全路径（包类路径） （3）创建对象时候，默认也是执行无参数构造方法完成对象创建 2.2、基于 xml 方式注入属性 ​ DI：依赖注入，就是注入属性 (1) 什么是Spring的依赖注入? 依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。 (2)有哪些不同类型的IOC（依赖注入）方式？ 构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。 (3)哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？ 两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。 2.3、第一种注入方式：使用 set 方法进行注入 （1）创建类，定义属性和对应的 set 方法 12345678910111213141516public class Book &#123; private String name; private String author; public void setName(String name) &#123; this.name = name; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public void testbook()&#123; System.out.println(name+&quot;::&quot;+author); &#125;&#125; （2）在 spring 配置文件配置对象创建，配置属性注入 12345678&lt;!-- set 方法注入属性 --&gt;&lt;bean id=&quot;book&quot; class=&quot;com.jiahao.spring5.Book&quot;&gt; &lt;!--使用 property 完成属性注入 name：类里面属性名称 value：向属性注入的值--&gt; &lt;property name=&quot;name&quot; value=&quot;易筋经&quot;&gt;&lt;/property&gt; &lt;property name=&quot;author&quot; value=&quot;达摩老祖&quot;&gt;&lt;/property&gt; &lt;/bean&gt; (3)测试 123456789@Testpublic void TestBook()&#123; //加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); //获取配置创建的文件 Book book = context.getBean(&quot;book&quot;,Book.class); System.out.println(book); book.testbook();&#125; (4)输出结果 12com.jiahao.spring5.Book@5204062d易筋经::达摩老祖 2.4、第二种注入方式：使用有参数构造进行注入 （1）创建类，定义属性，创建属性对应有参数构造方法 123456789101112131415//使用有参数构造注入public class Orders &#123; private String oname; private String address; public Orders(String oname, String address) &#123; this.oname = oname; this.address = address; &#125; public void orderTest()&#123; System.out.println(oname+&quot;::&quot;+address); &#125;&#125; （2）在 spring 配置文件中进行配置 12345&lt;!-- 有参数构造注入属性 --&gt;&lt;bean id=&quot;orders&quot; class=&quot;com.jiahao.spring5.Orders&quot;&gt; &lt;constructor-arg name=&quot;oname&quot; value=&quot;宁静致远&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;address&quot; value=&quot;郑州&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; (3）测试 123456789@Testpublic void TestOrders()&#123; //加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); //获取配置创建的文件 Orders orders = context.getBean(&quot;orders&quot;,Orders.class); System.out.println(orders); orders.orderTest();&#125; (4)输出结果 12com.jiahao.spring5.Orders@5204062d宁静致远::郑州 2.5、p 名称空间注入（了解） （1）使用 p 名称空间注入，可以简化基于 xml 配置方式 ​ 第一步 添加 p 名称空间在配置文件中 1234&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; ​ 第二步 进行属性注入，在 bean 标签里面进行操作 123&lt;!--2 set 方法注入属性--&gt;&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot; p:bname=&quot;九阳神功&quot; p:bauthor=&quot;无名氏&quot;&gt;&lt;/bean&gt; 2.6、xml注入其它类型属性1、字面量（1）null 值 123&lt;property name=&quot;adress&quot;&gt; &lt;null/&gt;&lt;/property&gt; （2）属性值包含特殊符号 12345678&lt;!--属性值包含特殊符号 1 把&lt;&gt;进行转义 &amp;lt; &amp;gt; 2 把带特殊符号内容写到 CDATA--&gt;&lt;property name=&quot;address&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt;&lt;/property&gt; 2、注入外部bean（1）创建两个类 service 类和 dao 类 （2）在 service 调用 dao 里面的方法 （3）在 spring 配置文件中进行配置 1234//创建UserDao接口public interface UserDao &#123; public void Update();&#125; 12345678//创建UserDao实现类public class UserDaoImpl implements UserDao&#123; @Override public void Update() &#123; System.out.println(&quot;dao update...&quot;); &#125;&#125; 1234567891011121314151617181920public class UserService &#123; //创建 UserDao 类型属性，生成 set 方 private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void add()&#123; System.out.println(&quot;UserService.....&quot;); userDao.Update(); /* 原始方法创建对象： UserDao userDao = new UserDaoImpl(); userDao.Update(); */ &#125;&#125; 123456789 &lt;!--1 service 和 dao 对象创建--&gt;&lt;bean id=&quot;UserService&quot; class=&quot;com.jiahao.spring5.Service.UserService&quot;&gt; &lt;!--注入 userDao 对象 name 属性：类里面属性名称 ref 属性：创建 userDao 对象 bean 标签 id 值 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.jiahao.spring5.Dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; 测试： 1234567@Testpublic void test1() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); UserService userService = context.getBean(&quot;UserService&quot;, UserService.class); System.out.println(userService); userService.add();&#125; 输出结果： 123com.jiahao.spring5.Service.UserService@a74868dUserService.....dao update... 3、注入内部bean（1）一对多关系：部门和员工 一个部门有多个员工，一个员工属于一个部门 部门是一，员工是多 （2）在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示 123456789101112131415//部门类public class Dept &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Dept&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 123456789101112131415161718192021222324//员工类public class Emp &#123; private String name; private String gender; //员工属于某个部门 private Dept dept; public void setDept(Dept dept) &#123; this.dept = dept; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public void add()&#123; System.out.println(name+&quot;::&quot;+gender+&quot;::&quot;+dept); &#125;&#125; (3) 在spring配置文件中进行配置 123456789&lt;bean id=&quot;emp&quot; class=&quot;com.jiahao.spring5.bean.Emp&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Lucy&quot; &gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dept&quot; &gt; &lt;bean id=&quot;dept&quot; class=&quot;com.jiahao.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;安保部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; (4) 测试 12345678910public class Testbean &#123; @Test public void testbean1()&#123; ApplicationContext context =new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;); Emp emp = context.getBean(&quot;emp&quot;, Emp.class); System.out.println(emp); emp.add(); &#125;&#125; (5)结果 12com.jiahao.spring5.bean.Emp@4fb64261Lucy::女::Dept&#123;name=&#x27;安保部&#x27;&#125; 4、级联赋值（1）第一种写法 部门类和员工类代码不动，新建bean4.xml 12345678&lt;bean id=&quot;emp&quot; class=&quot;com.jiahao.spring5.bean.Emp&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;dept&quot; class=&quot;com.jiahao.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 测试 1234567@Testpublic void testbean2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;); Emp emp = context.getBean(&quot;emp&quot;,Emp.class); System.out.println(emp); emp.add();&#125; 结果 12com.jiahao.spring5.bean.Emp@25bbf683Lucy::女::Dept&#123;name=&#x27;技术部&#x27;&#125; (2)第二种写法 修改Emp类中的代码，添加dept的get方法 123public Dept getDept() &#123; return dept;&#125; 修改bean中代码 123456&lt;bean id=&quot;emp&quot; class=&quot;com.jiahao.spring5.bean.Emp&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dept.name&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 测试结果 12com.jiahao.spring5.bean.Emp@7276c8cdLucy::女::Dept&#123;name=&#x27;财务部&#x27;&#125; 2.7、xml 注入集合属性1、注入数组类型属性 2、注入 List 集合类型属性 3、注入 Map 集合类型属性 （1）创建类，定义数组、list、map、set 类型属性，生成对应 set 方法 123456789101112131415161718192021222324252627282930public class stu &#123; private String[] courses; private List&lt;String&gt; list; private Map&lt;String,String&gt; map; private Set&lt;String&gt; set; public void setCourses(String[] courses) &#123; this.courses = courses; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; public void setSet(Set&lt;String&gt; set) &#123; this.set = set; &#125; public void test()&#123; System.out.println(Arrays.toString(courses)); System.out.println(list); System.out.println(map); System.out.println(set); &#125;&#125; （2）在 spring 配置文件进行配置 1234567891011121314151617181920212223242526&lt;bean id=&quot;stu&quot; class=&quot;com.jiahao.spring5.bean.stu&quot;&gt; &lt;property name=&quot;courses&quot; &gt; &lt;array&gt; &lt;value&gt;java课程&lt;/value&gt; &lt;value&gt;python课程&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;李四&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;PYTHON&quot; value=&quot;python&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;mysql&lt;/value&gt; &lt;value&gt;redis&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; (3) 测试 1234567@Testpublic void teststu()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean5.xml&quot;); stu s = context.getBean(&quot;stu&quot;, stu.class); s.test();&#125; 结果： 1234[java课程, python课程][张三, 李四]&#123;JAVA=java, PYTHON=python&#125;[mysql, redis] 2.8、在集合里面设置对象类型值(1) 创建stu类 1234567891011121314151617181920212223242526272829303132public class stu &#123; private String[] courses; private List&lt;String&gt; list; private Map&lt;String,String&gt; map; private Set&lt;String&gt; set; private List&lt;Courses&gt; coursesList; public void setCoursesList(List&lt;Courses&gt; coursesList) &#123; this.coursesList = coursesList; &#125; public void setCourses(String[] courses) &#123; this.courses = courses; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; public void setSet(Set&lt;String&gt; set) &#123; this.set = set; &#125; public void test()&#123; System.out.println(coursesList); &#125;&#125; (2) 创建Courses类 123456789101112131415public class Courses &#123; private String cname; public void setCname(String cname) &#123; this.cname = cname; &#125; @Override public String toString() &#123; return &quot;Courses&#123;&quot; + &quot;cname=&#x27;&quot; + cname + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; (3) 配置bean.xml 1234567891011121314151617&lt;!--注入 list 集合类型，值是对象--&gt;&lt;bean id=&quot;stu&quot; class=&quot;com.jiahao.spring5.bean.stu&quot;&gt; &lt;property name=&quot;coursesList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--创建多个 course 对象--&gt; &lt;bean id=&quot;course1&quot; class=&quot;com.jiahao.spring5.bean.Courses&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;Spring5框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;course2&quot; class=&quot;com.jiahao.spring5.bean.Courses&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;Mybatis框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt; (4) 测试 123456@Testpublic void teststu()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean6.xml&quot;); stu s = context.getBean(&quot;stu&quot;, stu.class); s.test();&#125; (5) 结果 1[Courses&#123;cname=&#x27;Spring5框架&#x27;&#125;, Courses&#123;cname=&#x27;Mybatis框架&#x27;&#125;] 2.9、把集合注入部分提取出来(1) 创建book类 123456789101112public class book &#123; private List&lt;String&gt; list; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void test()&#123; System.out.println(list); &#125;&#125; (2) 配置bean.xml 12345678910111213141516171819&lt;!--在 spring 配置文件中引入名称空间 util--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;&lt;!-- 使用 util 标签完成 list 集合注入提取--&gt; &lt;util:list id=&quot;booklist&quot;&gt; &lt;value&gt;易筋经&lt;/value&gt; &lt;value&gt;曾国潘家书&lt;/value&gt; &lt;value&gt;道德经&lt;/value&gt; &lt;/util:list&gt; &lt;bean id=&quot;book&quot; class=&quot;com.jiahao.spring5.bean.book&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;booklist&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; (3) 测试 123456@Testpublic void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean7.xml&quot;); book b = context.getBean(&quot;book&quot;, book.class); b.test();&#125; (4)结果 1[易筋经, 曾国潘家书, 道德经] 2.10、FactoryBean1、Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean） 2、普通 bean：在配置文件中定义 bean 类型就是返回类型 3、工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样 第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean 第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型 123456789101112131415161718192021public class Mybean implements FactoryBean&lt;Courses&gt; &#123; @Nullable @Override public Courses getObject() throws Exception &#123; Courses courses = new Courses(); courses.setCname(&quot;abc&quot;); return courses; &#125; @Nullable @Override public Class&lt;?&gt; getObjectType() &#123; return null; &#125; @Override public boolean isSingleton() &#123; return false; &#125;&#125; 123456789101112131415public class Courses &#123; private String cname; public void setCname(String cname) &#123; this.cname = cname; &#125; @Override public String toString() &#123; return &quot;Courses&#123;&quot; + &quot;cname=&#x27;&quot; + cname + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 1&lt;bean id=&quot;mybean&quot; class=&quot;com.jiahao.spring5.factorybean.Mybean&quot;&gt; 123456789public class testMybean &#123; @Test public void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean8.xml&quot;); Courses courses = context.getBean(&quot;mybean&quot;, Courses.class); System.out.println(courses); &#125;&#125; 2.11、bean 作用域1、在 Spring 里面，设置创建 bean 实例是单实例还是多实例 2、在 Spring 里面，默认情况下，bean 是单实例对象 (1)创建demo类 123456public class demo &#123; private String dname; public void setDname(String dname) &#123; this.dname = dname; &#125;&#125; (2)配置bean.xml 1&lt;bean id=&quot;demo1&quot; class=&quot;com.jiahao.spring5.bean.demo&quot;&gt; (3)测试 12345678@Testpublic void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean9.xml&quot;); demo d1 = context.getBean(&quot;demo1&quot;, demo.class); demo d2 = context.getBean(&quot;demo1&quot;, demo.class); System.out.println(d1); System.out.println(d2);&#125; (4)结果 123com.jiahao.spring5.bean.demo@612fc6ebcom.jiahao.spring5.bean.demo@612fc6eb//两个地址相同,默认是单实例对象 3、如何设置单实例还是多实例 （1）在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例 （2）scope 属性值 第一个值 默认值，singleton，表示是单实例对象 第二个值 prototype，表示是多实例对象 1&lt;bean id=&quot;demo1&quot; class=&quot;com.jiahao.spring5.bean.demo&quot; scope=&quot;prototype&quot;&gt; 123com.jiahao.spring5.bean.demo@3aeaafa6com.jiahao.spring5.bean.demo@76a3e297//地址不同，为多实例对象 （3）singleton 和 prototype 区别 第一 singleton 单实例，prototype 多实例 第二 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用 getBean 方法时候创建多实例对象 2.12、bean 生命周期1、生命周期 （1）从对象创建到对象销毁的过程 2、bean 生命周期 （1）通过构造器创建 bean 实例（无参数构造） （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） （3）调用 bean 的初始化的方法（需要进行配置初始化的方法） （4）bean 可以使用了（对象获取到了） （5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法） 3、演示 bean 生命周期： 1234567891011121314151617181920public class Order &#123; private String oname; public Order() &#123; System.out.println(&quot;第一步，执行无参数构造创建bean实例&quot;); &#125; public void setOname(String oname) &#123; System.out.println(&quot;第二部，调用set方法设置属性值&quot;); this.oname = oname; &#125; //创建执行的初始化方法 public void initMethod()&#123; System.out.println(&quot;第三步，执行初始化的方法&quot;); &#125; //创建执行的销毁的方法 public void destroyMethod()&#123; System.out.println(&quot;第五步，执行销毁的方法&quot;); &#125;&#125; 123&lt;bean id=&quot;order&quot; class=&quot;com.jiahao.spring5.bean.Order&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt; &lt;property name=&quot;oname&quot; value=&quot;手机&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 123456789@Testpublic void testOrder()&#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean10.xml&quot;); Order order = context.getBean(&quot;order&quot;, Order.class); System.out.println(&quot;第四步，获取创建bean实例对象&quot;); System.out.println(order); //手动让bean实例销毁 context.close();&#125; 结果： 123456第一步，执行无参数构造创建bean实例第二部，调用set方法设置属性值第三步，执行初始化的方法第四步，获取创建bean实例对象com.jiahao.spring5.bean.Order@1990a65e第五步，执行销毁的方法 4、bean 的后置处理器，bean 生命周期有七步 （1）通过构造器创建 bean 实例（无参数构造） （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） （3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization （4）调用 bean 的初始化的方法（需要进行配置初始化的方法）（5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization （6）bean 可以使用了（对象获取到了） （7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法） 5、演示添加后置处理器效果 （1）创建类，实现接口 BeanPostProcessor，创建后置处理器 123456789101112131415public class MyBeanPost implements BeanPostProcessor&#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之前执行的方法&quot;); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之后执行的方法&quot;); return bean; &#125;&#125; 1&lt;bean id=&quot;myBeanPost&quot; class=&quot;com.jiahao.spring5.bean.MyBeanPost&quot;&gt;&lt;/bean&gt; 结果： 12345678第一步，执行无参数构造创建bean实例第二部，调用set方法设置属性值在初始化之前执行的方法第三步，执行初始化的方法在初始化之后执行的方法第四步，获取创建bean实例对象com.jiahao.spring5.bean.Order@7276c8cd第五步，执行销毁的方法 2.13、自动装配（很少用）1、什么是自动装配 （1）根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入 演示： 123456public class Dept &#123; @Override public String toString() &#123; return &quot;Dept&#123;&#125;&quot;; &#125;&#125; 1234567891011121314151617public class Empl &#123; private Dept dept; public void setDept(Dept dept) &#123; this.dept = dept; &#125; @Override public String toString() &#123; return &quot;Empl&#123;&quot; + &quot;dept=&quot; + dept + &#x27;&#125;&#x27;; &#125; public void test()&#123; System.out.println(dept); &#125;&#125; 配置bean.xml （1）根据属性名称自动注入 123456789&lt;!--实现自动装配 bean 标签属性 autowire，配置自动装配 autowire 属性常用两个值： byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样 byType 根据属性类型注入--&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.jiahao.spring5.autowire.Empl&quot; autowire=&quot;byName&quot;&gt;&lt;bean id=&quot;dept&quot; class=&quot;com.jiahao.spring5.autowire.Dept&quot;&gt;&lt;/bean&gt; &lt;!-- 这个dept要和 Empl类里面的dept名称相同 --&gt; （2）根据属性类型自动注入 1234&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.autowire.Emp&quot; autowire=&quot;byType&quot;&gt; &lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.autowire.Dept&quot;&gt;&lt;/bean&gt; 输出结果： 1Empl&#123;dept&#x3D;Dept&#123;&#125;&#125; 2.14 外部属性文件1、直接配置数据库信息 （1）配置德鲁伊连接池 （2）引入德鲁伊连接池依赖 jar 包（druid-1.1.9.jar） 12345678&lt;!--直接配置连接池--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/userDb&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2、引入外部属性文件配置数据库连接池 （1）创建外部属性文件，properties 格式文件，写数据库信息 ​ 创建jdbc.properties : 1234prop.driverclass&#x3D;com.mysql.jdbc.Driverprop.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;userDbprop.userName&#x3D;rootprop.password&#x3D;root * 引入 context 名称空间 12345&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; 在 spring 配置文件使用标签引入外部属性文件 1234567&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverclass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 3、 基于注解方式3.1、什么是注解（1）注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..) （2）使用注解，注解作用在类上面，方法上面，属性上面 （3）使用注解目的：简化 xml 配置 3.2、Spring 针对 Bean 管理中创建对象提供注解（1）@Component （2）@Service （3）@Controller （4）@Repository 上面四个注解功能是一样的，都可以用来创建 bean 实例 3.3、基于注解方式实现对象创建 第一步 引入依赖 第二步 开启组件扫描 12345678910111213&lt;!--开启组件扫描 1 如果扫描多个包，多个包使用逗号隔开 2 扫描包上层目录--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.jiahao&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 第三步 创建类，在类上面添加创建对象注解 12345678910//在注解里面 value 属性值可以省略不写，//默认值是类名称，首字母小写//UserService -- userService@Component(value = &quot;userService&quot;) //&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt;public class UserService &#123; public void add()&#123; System.out.println(&quot;Service add() .....&quot;); &#125;&#125; 测试： 1234567@Test public void test1()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean13.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); &#125; 结果： 12com.jiahao.zhujie.UserService@527e5409Service add() ..... 3.4、开启组件扫描细节配置123456789101112131415161718192021&lt;!--示例 1 use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filter * context:include-filter ，设置扫描哪些内容--&gt;&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default\u0002filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;&lt;!--示例 2 下面配置扫描包所有内容 * context:exclude-filter： 设置哪些内容不进行扫描--&gt;&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 3.5、基于注解方式实现属性注入（1）@Autowired：根据属性类型进行自动装配 第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解 第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.jiahao&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 123public interface UserDao &#123; public void add();&#125; 123456789@Repositorypublic class UserDaoimpl implements UserDao &#123; @Override public void add() &#123; System.out.println(&quot;UserDao add.....&quot;); &#125;&#125; 123456789101112@Servicepublic class UserService1 &#123; @Autowired private UserDao userDao; public void add()&#123; System.out.println(&quot;service add.......&quot;); userDao.add(); &#125;&#125; 1234567@Testpublic void test1()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean13.xml&quot;); UserService1 userService1 = context.getBean(&quot;userService1&quot;, UserService1.class); System.out.println(userService1); userService1.add();&#125; 1234com.jiahao.testZhujie.Service.UserService1@ec756bdservice add.......UserDao add..... （2）@Qualifier：根据名称进行注入 这个@Qualifier 注解的使用，和上面@Autowired 一起使用 12345678910111213@Servicepublic class UserService1 &#123; //定义 dao 类型属性 //不需要添加 set 方法//添加注入属性注解 @Autowired //根据类型进行注入 @Qualifier(value = &quot;userDaoimpl&quot;) //根据名称进行注入 private UserDao userDao; public void add()&#123; System.out.println(&quot;service add.......&quot;); userDao.add(); &#125;&#125; （3）@Resource：可以根据类型注入，也可以根据名称注入 12345678// @Resource //根据类型进行注入 @Resource(name = &quot;userDaoimpl&quot;) //根据名称进行注入 private UserDao userDao; public void add()&#123; System.out.println(&quot;service add.......&quot;); userDao.add(); &#125; （4）@Value：注入普通类型属性 12@Value(value = &quot;abc&quot;) private String name; 3.6、完全注解开发（1）创建配置类，替代 xml 配置文件 1234@Configuration //作为配置类，替代 xml 配置文件@ComponentScan(basePackages = &#123;&quot;com.jiahao&quot;&#125;)public class SpringConfig &#123;&#125; （2）编写测试类 1234567891011@Testpublic void testService2() &#123; //加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService1 userService1 = context.getBean(&quot;userService1&quot;, UserService1.class); System.out.println(userService1); userService1.add();&#125; AOP（概念） 什么是 AOP ? （1）面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 （2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能 （3）使用登录例子说明 AOP AOP（底层原理）1、AOP 底层使用动态代理 （1）有两种情况动态代理 第一种 有接口情况，使用 JDK 动态代理 ​ * 创建接口实现类代理对象，增强类的方 第二种 没有接口情况，使用 CGLIB 动态代理 ​ * 创建子类的代理对象，增强类的方法 AOP(JDK动态代理)1、使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象 （1）调用 newProxyInstance 方法 方法有三个参数： 第一参数，类加载器 第二参数，增强方法所在的类，这个类实现的接口，支持多个接口 第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分 2、编写 JDK 动态代理代码 （1）创建接口，定义方法 12345public interface UserDao &#123; public int add(int a,int b); public String Update(String id);&#125; （2）创建接口实现类，实现方法 123456789101112public class UserDaoImpl implements UserDao &#123; @Override public int add(int a, int b) &#123; System.out.println(&quot;add...方法执行了&quot;); return a+b; &#125; @Override public String Update(String id) &#123; return id; &#125;&#125; （3）使用 Proxy 类创建接口代理对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class JDKProxy &#123; public static void main(String[] args) &#123; Class[] interfaces = &#123;UserDao.class&#125;; //数组里可以有多个接口 //第一种写法/* Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return null; &#125; &#125;);*/ // 第二种写法 UserDaoImpl userDao = new UserDaoImpl(); UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao)); int result = dao.add(1, 2); System.out.println(&quot;result：&quot;+result); &#125;&#125;//创建代理对象代码class UserDaoProxy implements InvocationHandler&#123; //1 把创建的是谁的代理对象，把谁传递过来 //有参数构造传递 private Object obj ; public UserDaoProxy(Object obj)&#123; this.obj = obj; &#125; //增强的逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //方法之前 System.out.println(&quot;方法之前执行&quot;+method.getName()+&quot;传递的参数&quot;+ Arrays.toString(args)); //被增强的方法执行 Object res = method.invoke(obj, args); //方法之后 System.out.println(&quot;方法之后执行&quot;+obj); return res; //相当于返回了a+b &#125;&#125; AOP（术语）1、连接点 类里面哪些方法可以被增强，这些方法称为连接点。 2、切入点 实际被真正增强的方法，称为切入点。 3、通知(增强) (1) 实际增强的逻辑部分称为通知(增强) (2) 通知有多种类型 前置通知 后置通知 环绕通知 异常通知 最终通知 4、切面 把通知应用到切入点过程 AOP 操作（准备工作）1、Spring 框架一般都是基于 AspectJ 实现 AOP 操作 （1）AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使 用，进行 AOP 操作 2、基于 AspectJ 实现 AOP 操作 （1）基于 xml 配置文件实现 （2）基于注解方式实现（使用） 3、在项目工程里面引入 AOP 相关依赖 4、切入点表达式 （1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强 （2）语法结构： execution([权限修饰符] [返回类型] [类全路径] 方法名称 ) 举例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 ​ execution(* com.atguigu.dao.BookDao.add(..)) 举例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强 ​ execution(* com.atguigu.dao.BookDao.* (..)) 举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 ​ execution(* com.atguigu.dao.. (..)) AOP 操作（AspectJ 注解）1、创建类，在类里面定义方法 12345public class User &#123; public void add()&#123; System.out.println(&quot;add...&quot;); &#125;&#125; 2、创建增强类（编写增强逻辑） （1）在增强类里面，创建方法，让不同方法代表不同通知类型 1234567//增强的类public class UserProxy &#123; public void before() &#123;//前置通知 System.out.println(&quot;before......&quot;); &#125;&#125; 3、进行通知的配置 （1）在 spring 配置文件中，开启注解扫描 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.jiahao.AOP&quot;&gt;&lt;/context:component-scan&gt; &lt;!--开启Aspect生成代理对象--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; （2）使用注解创建 User 和 UserProxy 对象 123456@Componentpublic class User &#123; public void add()&#123; System.out.println(&quot;add...&quot;); &#125;&#125; 123456@Componentpublic class UserProxy &#123; public void before() &#123;//前置通知 System.out.println(&quot;before......&quot;); &#125;&#125; (3）在增强类上面添加注解 @Aspect 123456@Componentpublic class UserProxy &#123; public void before() &#123;//前置通知 System.out.println(&quot;before......&quot;); &#125;&#125; （4）在 spring 配置文件中开启生成代理对象 12&lt;!--开启Aspect生成代理对象--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 4、配置不同类型的通知 （1）在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置 123456789101112131415161718192021222324252627282930313233@Component@Aspect //生成代理对象public class UserProxy &#123; //前置通知 @Before(value = &quot;execution(* com.jiahao.AOP.User.add(..))&quot;) public void before()&#123; System.out.println(&quot;before...&quot;); &#125; @AfterReturning(value = &quot;execution(* com.jiahao.AOP.User.add(..))&quot;) public void afterReturning()&#123; System.out.println(&quot;AfterReturning...&quot;); &#125; @After(value = &quot;execution(* com.jiahao.AOP.User.add(..))&quot;) public void after()&#123; System.out.println(&quot;after...&quot;); &#125; @AfterThrowing(value = &quot;execution(* com.jiahao.AOP.User.add(..))&quot;) public void afterThrowing()&#123; System.out.println(&quot;AfterThrowing...&quot;); &#125; @Around(value = &quot;execution(* com.jiahao.AOP.User.add(..))&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable&#123; System.out.println(&quot;环绕之前...&quot;); proceedingJoinPoint.proceed(); System.out.println(&quot;环绕之后...&quot;); &#125;&#125; 测试： 12345678910public class TestAop &#123; @Test public void TestAopAnno()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean14.xml&quot;); User user = context.getBean(&quot;user&quot;, User.class); user.add(); &#125;&#125; 结果 123456环绕之前...before...add...AfterReturning...after...环绕之后... 5、相同的切入点抽取 12345678910111213141516171819202122232425262728293031323334353637@Component@Aspect //生成代理对象public class UserProxy1 &#123; //相同切入点抽取 @Pointcut(value = &quot;execution(* com.jiahao.AOP.User.add(..))&quot;) public void pointdemo()&#123; &#125; //前置通知 @Before(value = &quot;pointdemo()&quot;) public void before()&#123; System.out.println(&quot;before...&quot;); &#125; @AfterReturning(value = &quot;pointdemo()&quot;) public void afterReturning()&#123; System.out.println(&quot;AfterReturning...&quot;); &#125; @After(value = &quot;pointdemo()&quot;) public void after()&#123; System.out.println(&quot;after...&quot;); &#125; @AfterThrowing(value = &quot;pointdemo()&quot;) public void afterThrowing()&#123; System.out.println(&quot;AfterThrowing...&quot;); &#125; @Around(value = &quot;pointdemo()&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable&#123; System.out.println(&quot;环绕之前...&quot;); proceedingJoinPoint.proceed(); System.out.println(&quot;环绕之后...&quot;); &#125;&#125; 6、有多个增强类多同一个方法进行增强，设置增强类优先级 （1）在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高 12345@Component@Aspect@Order(1)public class PersonProxy 7、完全使用注解开发 （1）创建配置类，不需要创建 xml 配置文件 123456@Configuration@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)@EnableAspectJAutoProxy(proxyTargetClass = true)public class ConfigAop &#123;&#125; JdbcTemplate(概念和准备)1、什么是 JdbcTemplate （1）Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 2、准备工作 （1）引入相关 jar 包 （2）在 spring 配置文件配置数据库连接池 12345678&lt;!-- 数据库连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///user_db&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;&lt;/bean&gt; （3）配置 JdbcTemplate 对象，注入 DataSource 123&lt;bean id&#x3D;&quot;jdbcTemplate&quot; class&#x3D;&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt; （4）创建 service 类，创建 dao 类，在 dao 注入 jdbcTemplate 对象 * 配置文件 12&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.jiahao.JdbcTemplate&quot;&gt;&lt;/context:component-scan&gt; 创建Service类 123456@Servicepublic class BookService &#123; //注入Dao @Autowired private BookDao bookDao;&#125; 创建BookDao 123public class BookDao &#123;&#125; 创建BookDao实现类 123456@Repositorypublic class BookDaoImpl &#123; //注入jdbcTemplate @Autowired private JdbcTemplate jdbcTemplate;&#125; JdbcTemplate 操作数据库一、添加1、对应数据库创建实体类 1234567891011121314151617181920212223242526272829public class Book &#123; private String bookId; private String bookname; private String ustatus; public String getBookId() &#123; return bookId; &#125; public void setBookId(String bookId) &#123; this.bookId = bookId; &#125; public String getBookname() &#123; return bookname; &#125; public void setBookname(String bookname) &#123; this.bookname = bookname; &#125; public String getUstatus() &#123; return ustatus; &#125; public void setUstatus(String ustatus) &#123; this.ustatus = ustatus; &#125;&#125; 2、编写 service 和 dao （1）在 dao 进行数据库添加操作 （2）调用 JdbcTemplate 对象里面 update 方法实现添加操作 ​ 有两个参数 第一个参数：sql 语句 第二个参数：可变参数，设置 sql 语句值 1234public interface BookDao &#123; void add(Book book);&#125; 123456789101112131415@Repositorypublic class BookDaoImpl implements BookDao&#123; //注入jdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; @Override public void add(Book book) &#123; String sql = &quot;insert into t_book values(?,?,?)&quot;; Object[] args = &#123;book.getBookId(),book.getBookname(),book.getUstatus()&#125;; int update = jdbcTemplate.update(sql, args); System.out.println(update); &#125;&#125; 测试： 1234567891011@Testpublic void test() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean15.xml&quot;); BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class); Book book = new Book(); book.setBookId(&quot;2&quot;); book.setBookname(&quot;java&quot;); book.setUstatus(&quot;a&quot;); bookService.addbook(book);&#125; 结果： 二、修改和删除在Dao里添加update和delete方法 12void update(Book book);void delete(String id); 在Dao实现类里添加 1234567891011121314151617//修改@Overridepublic void update(Book book) &#123; String sql = &quot;update t_book set user_name=?,ustatus=? where user_id=?&quot;; Object[] args = &#123;book.getBookname(),book.getUstatus(),book.getBookId()&#125;; int update = jdbcTemplate.update(sql, args); System.out.println(update);&#125;//删除@Overridepublic void delete(String id) &#123; String sql = &quot;delete from t_book where user_id=?&quot;; Object[] args = &#123;id&#125;; int update = jdbcTemplate.update(sql, args); System.out.println(update);&#125; 在Service里添加 123456public void updatebook(Book book)&#123; bookDao.update(book);&#125;public void deletebook(String id)&#123; bookDao.delete(id);&#125; 测试修改 12345Book book = new Book();book.setBookId(&quot;1&quot;);book.setBookname(&quot;python&quot;);book.setUstatus(&quot;b&quot;);bookService.updatebook(book); 测试删除 1bookService.deletebook(&quot;1&quot;); 三、查询返回某个值1、查询表里面有多少条记录，返回是某个值 2、使用 JdbcTemplate 实现查询返回某个值代码 ⚫ 有两个参数 ⚫ 第一个参数：sql 语句 ⚫ 第二个参数：返回类型 Class 演示： 在Dao中加入 12//查询表记录数int selectCount(); 实现Dao 123456@Overridepublic int selectCount() &#123; String sql = &quot;select count(*) from t_book&quot;; Integer count = jdbcTemplate.queryForObject(sql, Integer.class);//第一个参数是sql语句，第二个参数是返回类型class return count;&#125; 在Service中调dao中的方法 123public int findCount()&#123; return bookDao.selectCount();&#125; 测试 12int count = bookService.findCount();System.out.println(count); 四、查询返回对象1、场景：查询图书详情 2、JdbcTemplate 实现查询返回对象 ⚫ 有三个参数 ⚫ 第一个参数：sql 语句 ⚫ 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成 数据封装 ⚫ 第三个参数：sql 语句值 演示： (1)、dao层 12//查询返回对象Book findBookInfo(String id); (2)、dao实现类 1234567@Overridepublic Book findBookInfo(String id) &#123; String sql = &quot;select * from t_book where bookId = ?&quot;; Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Book.class), id); return book;&#125;","categories":[{"name":"SSM","slug":"SSM","permalink":"https://hujiahao.top/categories/SSM/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://hujiahao.top/tags/Spring/"},{"name":"SSM","slug":"SSM","permalink":"https://hujiahao.top/tags/SSM/"}],"author":"Hu"},{"title":"小文有话说","slug":"小文有话说","date":"2021-03-19T15:08:30.000Z","updated":"2021-03-19T15:08:30.000Z","comments":true,"path":"2021/03/19/小文有话说/","link":"","permalink":"https://hujiahao.top/2021/03/19/%E5%B0%8F%E6%96%87%E6%9C%89%E8%AF%9D%E8%AF%B4/","excerpt":"","text":"死刑是人类文明的产物，也是人类文明的悲哀。在我看来，它是法律处罚的极致，也是人性善恶的凝聚焦点。展现人性惊心动魄之处，同时也折射出我们法律的合理性。 之所以欣赏一个东西，其实和东西事物本身无关，只是自己的一种感情共鸣而已。 素衣闲坐，小楼听春雨。待晴窗初霁，门庭新绿。 无不成礼义，色无路静人稀，财无不成世界，气无反被人欺。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://hujiahao.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[],"author":"Dany"},{"title":"数据结构与算法之查找","slug":"查找","date":"2021-03-04T02:15:43.000Z","updated":"2021-03-04T02:15:43.000Z","comments":true,"path":"2021/03/04/查找/","link":"","permalink":"https://hujiahao.top/2021/03/04/%E6%9F%A5%E6%89%BE/","excerpt":"","text":"二叉排序树(1) 若其左子树非空，则左子树上所有结点的值均小于根节点的值。 (2) 若其右子树非空，则右子树上的所有结点的值均大于等于根结点的值。 (3) 其左子树本身又各是一棵二叉排序树。 散列表(hash 表)优点： 查找效率高； 缺点：空间效率低。 散列表的构造方法直接定址法:Hash(key) = a * key + b (a,b为常数) 优点: 以关键码key的某个线性函数值为散列地址，不会产生冲突。 缺点: 要占用连续的地址空间，空间效率低。 例： {100，300，500，700，800，900 } . 散列函数Hash(key) = key/100 (a=1/100 , b=0 ) 0 1 2 3 4 5 6 7 8 9 100 300 500 700 800 900 除留余数法:Hash(key) = key mod p (p是一个整数) 关键：如何选取合适的 p ? 技巧：设表长为m，取p&lt;= m且为质数 例: {15,23,27,38,53,61,70} . 散列函数Hash(key) = key mod 7 0 1 2 3 4 5 6 70 15 23 48 53 61 27 处理冲突的方法开放定址法基本思想： 有冲突就去寻找下一个空的散列地址，只要散列表空间足够大，空的散列表地址总能找到，并将数据元素存入。 H（key）=（H（key）+ d）MOD m（其中 m 为哈希表的表长，d 为一个增量）当得出的哈希地址产生冲突时，选取以下 3 种方法中的一种获取 d 的值，然后继续计算，直到计算出的哈希地址不在冲突为止，这 3 种方法为： 线性探测法: d=1,2,3, … ,m-1 二次探测法: d=1^2 , -1^2 , 2^2 , -2^2 , 3^2, … 伪随机探测法: d=伪随机数 例如，在长度为 11 的哈希表中已填写好 17、60 和 29 这 3 个数据（如图 2（a） 所示），其中采用的哈希函数为：H（key）=key MOD 11，现有第 4 个数据 38 ，当通过哈希函数求得的哈希地址为 5，与 60 冲突，则分别采用以上 3 种方式求得插入位置如图 2（b）所示：","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hujiahao.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hujiahao.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法之图","slug":"图","date":"2021-01-22T09:17:43.000Z","updated":"2021-01-22T09:17:43.000Z","comments":true,"path":"2021/01/22/图/","link":"","permalink":"https://hujiahao.top/2021/01/22/%E5%9B%BE/","excerpt":"","text":"图的基本概念图由结点的有穷集合V和边的集合E组合。为了与树形结构进行区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对。若两个顶点之间存在一条边，则表示这两个顶点具有相邻关系。 1.有向图和无向图 (有向图) (无向图) 2.入度和出度对于有向图中的一个顶点 V 来说，箭头指向 V 的弧的数量为 V 的入度（InDegree，记为 ID(V)）；箭头远离 V 的弧的数量为 V 的出度（OutDegree，记为OD(V)）。拿图 2 中的顶点 V1来说，该顶点的入度为 1，出度为 2（该顶点的度为 3）。 3.(V1,V2) 和 &lt;V1,V2&gt; 的区别无向图中描述两顶点（V1 和 V2）之间的关系可以用 (V1,V2) 来表示，而有向图中描述从 V1 到 V2 的”单向”关系用 &lt;V1,V2&gt; 来表示。由于图存储结构中顶点之间的关系是用线来表示的，因此 (V1,V2) 还可以用来表示无向图中连接 V1 和 V2 的线，又称为边；同样，&lt;V1,V2&gt; 也可用来表示有向图中从 V1 到 V2 带方向的线，又称为弧。 4.集合 VR 的含义并且，图中习惯用 VR 表示图中所有顶点之间关系的集合。例如，图 1 中无向图的集合 VR={(v1,v2),(v1,v4),(v1,v3),(v3,v4)}，图 2 中有向图的集合 VR={&lt;v1,v2&gt;,&lt;v1,v3&gt;,&lt;v3,v4&gt;,&lt;v4,v1&gt;}。 5.路径和回路无论是无向图还是有向图，从一个顶点到另一顶点途径的所有顶点组成的序列（包含这两个顶点），称为一条路径。如果路径中第一个顶点和最后一个顶点相同，则此路径称为”回路”（或”环”）。 6.简单路径序列中顶点不重复出现的路径称为简单路径。 7.权和网的含义在某些实际场景中，图中的每条边（或弧）会赋予一个实数来表示一定的含义，这种与边（或弧）相匹配的实数被称为”权”，而带权的图通常称为网。如图所示，就是一个网结构： (带权的图存储结构) 8.子图指的是由图中一部分顶点和边构成的图，称为原图的子图。 9.完全图若图中各个顶点都与除自身外的其他顶点有关系，这样的无向图称为完全图(如图 a)。同时，满足此条件的有向图则称为有向完全图(如图b) (完全图) 具有 n 个顶点的完全图，图中边的数量为 n(n-1)/2；而对于具有 n 个顶点的有向完全图，图中弧的数量为 n(n-1)。 连通图图中从一个顶点到达另一顶点，若存在至少一条路径，则称这两个顶点是连通着的。例如图 1 中，虽然 V1 和 V3 没有直接关联，但从 V1 到 V3 存在两条路径，分别是 V1-V2-V3 和 V1-V4-V3，因此称 V1 和 V3 之间是连通的。 (图 1 顶点之间的连通状态示意图) 无向图中，如果任意两个顶点之间都能够连通，则称此无向图为连通图。例如，图 2 中的无向图就是一个连通图，因为此图中任意两顶点之间都是连通的。 (图 2 连通图示意图) 若无向图不是连通图，但图中存储某个子图符合连通图的性质，则称该子图为连通分量。 强连通图有向图中，若任意两个顶点 Vi 和 Vj，满足从 Vi 到 Vj 以及从 Vj 到 Vi 都连通，也就是都含有至少一条通路，则称此有向图为强连通图。如图 4 所示就是一个强连通图。 (图 4 强连通图) 与此同时，若有向图本身不是强连通图，但其包含的最大连通子图具有强连通图的性质，则称该子图为强连通分量。 (图 5 强连通分量) 如图 5 所示，整个有向图虽不是强连通图，但其含有两个强连通分量。 可以这样说，连通图是在无向图的基础上对图中顶点之间的连通做了更高的要求，而强连通图是在有向图的基础上对图中顶点的连通做了更高的要求。 邻接矩阵邻接矩阵是图的顺序存储结构。由邻接矩阵的行数或列数可知图中的顶点数。 邻接表邻接表是图的一种链式存储结构。所谓邻接表就是对图中的每个顶点i建立一个单链表，每个单链表的第一个结点存放有关顶点的信息，把这一结点看作链表的表头，其余结点存放有关边的信息。因此，连接表由单链表的表头形成的顶点表和单链表其余结点形成的边表两部分组成。一般定点表存放顶点信息和指向由第一个边结点指针，边表结点存放与当前顶点相邻顶点的序号和指向下一个边结点的指针。 十字链表十字链表是有向图的另一种链式存储结构。我们也可以把它看成是有向图的邻接表和逆邻接表结合起来形成的一种链表。 有向图的每一条弧对应十字链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点结点。 邻接多重表 深度优先遍历 广度优先遍历 生成树所有顶点均有边连接起来，但不存在回路的图。对连通图进行遍历，过程中所经过的边和顶点的组合可看做是一棵普通树，通常称为生成树。 (连通图及其对应的生成树) 一个图可以有许多棵不同的生成树。 所有生成树具有以下共同特点 生成树的顶点个数与图的顶点个数相同； 生成树是图的极小连通图，去掉一条边则非连通； 一个有n个顶点的连通图的生成树有n-1条边； 在生成树中再添加一条边必须形成回路。 最小生成树：给定一个无向网络，在该网的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。 由于最小生成树本身是一棵生成树，所以需要时刻满足以下两点： 生成树中任意顶点之间有且仅有一条通路，也就是说，生成树中不能存在回路； 对于具有 n 个顶点的连通网，其生成树中只能有 n-1 条边，这 n-1 条边连通着 n 个顶点。 普里姆算法从顶点的角度为出发点，时间复杂度为O(n2)，更适合与解决边的绸密度更高的连通网。克鲁斯卡尔算法从边的角度求网的最小生成树，时间复杂度为O(eloge)。和普里姆算法恰恰相反，更适合于求边稀疏的网的最小生成树。 普里姆(Prim)算法从图中任意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短(权值最小)的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树。然后从与这棵树相连的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树。以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树。 克鲁斯卡尔(Kruskal)算法 (图一 连通图) 例如，使用克鲁斯卡尔算法找图 1 的最小生成树的过程为： 首先，在初始状态下，对各顶点赋予不同的标记（用颜色区别），如下图所示： (1) 对所有边按照权值的大小进行排序，按照从小到大的顺序进行判断，首先是（1，3），由于顶点 1 和顶点 3 标记不同，所以可以构成生成树的一部分，遍历所有顶点，将与顶点 3 标记相同的全部更改为顶点 1 的标记，如（2）所示： (2) 其次是（4，6）边，两顶点标记不同，所以可以构成生成树的一部分，更新所有顶点的标记为： (3) 其次是（2，5）边，两顶点标记不同，可以构成生成树的一部分，更新所有顶点的标记为： (4) 然后最小的是（3，6）边，两者标记不同，可以连接，遍历所有顶点，将与顶点 6 标记相同的所有顶点的标记更改为顶点 1 的标记： (5) 继续选择权值最小的边，此时会发现，权值为 5 的边有 3 个，其中（1，4）和（3，4）各自两顶点的标记一样，如果连接会产生回路，所以舍去，而（2，3）标记不一样，可以选择，将所有与顶点 2 标记相同的顶点的标记全部改为同顶点 3 相同的标记： (6) 当选取的边的数量相比与顶点的数量小 1 时，说明最小生成树已经生成。所以最终采用克鲁斯卡尔算法得到的最小生成树为（6）所示。 最短路径 两种常见的最短路径问题：一、单源最短路径——用Dijkstra(迪杰斯特拉)算法二、所有顶点间的最短路径——用Floyd(弗洛伊德)算法 Dijkstra(迪杰斯特拉)算法 Floyd(弗洛伊德)算法","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hujiahao.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hujiahao.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"栈和队列","slug":"栈和队列","date":"2021-01-18T09:07:06.000Z","updated":"2021-01-18T09:07:06.000Z","comments":true,"path":"2021/01/18/栈和队列/","link":"","permalink":"https://hujiahao.top/2021/01/18/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"给出一个中缀表达式求前缀表达式和后缀表达式：","text":"给出一个中缀表达式求前缀表达式和后缀表达式： a+bc-(d+e)第一步：按照运算符的优先级对所有的运算单位加括号， 式子变成了：((a+(bc))-(d+e))第二步：转换前缀与后缀表达式 前缀：把运算符号移动到对应的括号前面 则变成了：-( +(a (bc)) +(de)) 把括号去掉：-+abc+de 前缀式子出现 后缀：把运算符号移动到对应的括号后面 则变成了：((a(bc)* )+ (de)+ )- 把括号去掉：abc*+de+- 后缀式子出现 后缀表达式逆向求解中缀表达式 1 2 3 + 4 *5 - + 基本思路和上面的一样：递归，碰到操作符就进入递归。 从左往右扫描先碰到+号，取+号前面两个操作数：2，3 得到：2+3. 继续往下扫碰到号，取4 和2+3 得到：（2+3）4 -号，取（2+3）4和5得到：：（2+3）4-5 +号：取（2+3）4-5和1得到：：1+（2+3）4-5 后缀表达式逆向求解中缀表达式 基本思路和上面的一样,变成从右往左扫描","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hujiahao.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hujiahao.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构之树与二叉树","slug":"树与二叉树","date":"2021-01-16T10:43:16.000Z","updated":"2021-01-16T10:43:16.000Z","comments":true,"path":"2021/01/16/树与二叉树/","link":"","permalink":"https://hujiahao.top/2021/01/16/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"树的定义树是一种非线性的数据结构。它是若干结点(A,B,C等都是结点)的集合，是由唯一的根(结点A)和若干棵互不相交的子树(如B,E,F,K,L这5个结点组成的树就是一棵子树)组成的。树的结点数目可以为0，当为0时，这棵树称为空树。 树的基本术语节点的度：树中某个节点的子树的个数。 树的度：树中各节点的度的最大值。 分支节点：度不为零的节点。 叶子节点：度为零的节点。 路径：i-&gt;j；路径长度：路径经过节点数目减1。 孩子节点：某节点的后继节点；双亲节点：该节点为其孩子节点的双亲节点（父母节点）；兄弟节点：同一双亲的孩子节点；子孙节点：某节点所有子树中的节点；祖先节点：从树节点到该节点的路径上的节点。 节点的层次：根节点为第一层（以此类推）；树的高度：树中节点的最大层次。 有序树：树中节点子树按次序从左向右安排，次序不能改变；无序树：与之相反 森林：互不相交的树的集合。 二叉树的定义1.每个结点最多只有两颗子树，即二叉树中结点的度只能为0，1，2。2.子树有左右顺序之分，不能颠倒。 二叉树的主要性质非空二叉树上叶子结点数等于双分支结点数加1 所有结点的分支数等于单分支结点数加上双分支结点数的两倍。 总分支数=总结点数-1 度为m的树中第i层最多有m^(i-1)个节点； 二叉树的第i层上最多有2^(i-1)个结点。 高度(或深度)为k的二叉树最多有2^k -1(k&gt;=1)个结点.换句话说，满二叉树中前k层的结点个数为2^k -1。 几种特殊的二叉树斜树：所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。 满二叉树：在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 满二叉树的特点有： 1）叶子只能出现在最下一层。出现在其它层就不可能达成平衡。 2）非叶子结点的度一定是2。 3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。 完全二叉树：对一颗具有n个结点的二叉树按层编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 二叉树的遍历前序遍历：中序遍历：后序遍历： 树的遍历 二叉树的遍历算法 二叉树深度优先遍历的递归实现 先序遍历： 123456789101112void preorder(BTNode *p)&#123; if(p!=NULL) &#123; Visit(p) //假设访问函数Visit ()已经定义过， //其中包含了对结点p的各种访问操作， //如可以打印出p对应的数值。 preorder(p-&gt;lchild); preorder(p-&gt;rchild); &#125;&#125; 中序遍历： 123456789101112void inorder(BTNode *p)&#123; if(p!=NULL) &#123; preorder(p-&gt;lchild); Visit(p) //假设访问函数Visit ()已经定义过， //其中包含了对结点p的各种访问操作， //如可以打印出p对应的数值。 preorder(p-&gt;rchild); &#125;&#125; 后序遍历： 123456789101112void postorder(BTNode *p)&#123; if(p!=NULL) &#123; preorder(p-&gt;lchild); preorder(p-&gt;rchild); Visit(p) //假设访问函数Visit ()已经定义过， //其中包含了对结点p的各种访问操作， //如可以打印出p对应的数值。 &#125;&#125; 已知前序遍历序列为A,B,C,D,E,F,中序遍历序列为C,B,A,E,D,F,则后序遍历序列为： 前序：A,B,C,D,E,F中序：C,B,A,E,D,F先看前序遍历序列，则知道A为根结点，再看中序遍历序列，C,B,A,E,D,F ,A左边的为左子树，A右边的为右子树再看前序序列，B为根节点，又因为中序系列中C在B的左边，所以C为B的左子树，再看前序序列，D为根节点，再看中序序列(只需看A的右边)，E,D,F， 显然E为D的左子树，F为D的右子树。则后序遍历序列为CBEFDA 已知后序遍历序列为D,E,C,B,H,G,F,A,中序遍历序列为B,D,C,E,A,F,H,G,则前序遍历序列为： 后序：D,E,C,B,H,G,F,A中序：B,D,C,E,A,F,H,G先看后序遍历序列，则知道A为根结点，再看中序遍历序列，B,D,C,E为A的左子树部分，F,H,G为A的右子树部分,再看后序序列，F为根节点，因为H,G在F的右边，所以，H,G,为F的又子树，再看后序序列，G为根结点，再看中序序列，H在G的左边，所有，H为G的左子树，再看后序序列，B为根结点，再看中序序列，则知DCE为B的右子树部分，再看后序序列，C为根结点，再看中序序列(DCE)，知D为C的左子树，E为C的右子树。则前序遍历序列为：A,B,C,D,E,F,G,H 二叉树遍历算法的改进 二叉树深度优先遍历的非递归实现 …… 赫夫曼树和赫夫曼编码赫夫曼树又叫作最优二叉树，它的特点是带权路径最短。 关于几个路径的概念： 1.路径：路径是指从树中一个结点到另一个结点的分支所构成的路线。2.路径长度：路径长度是指路径上的分支数目。3.树的路径长度：树的路径长度是指从根到每个结点的路径长度之和。4.带权路径长度：结点具有权值，从结点到根之间的路径长度乘以结点的权值，就是该结点的带权路径长度。5.树的带权路径长度(WPL)：树的带权路径长度是指树中所有叶子结点的带权路径长度之和。 构造哈夫曼树 频率表(权值) A：60, B:45, C:13 D:69 E:14 F:5 G:3 第一步：找出字符中最小的两个，小的在左边，大的在右边，组成二叉树。在频率表中删除此次找到的两个数，并加入此次最小两个数的频率和。 F和G最小，因此如图，从字符串频率计数中删除F与G，并返回G与F的和 8给频率表 重复第一步： 频率表 A：60, B:45, C:13 D:69 E:14 FG:8 最小的是 FG：8与C：13，因此如图，并返回FGC的和：21给频率表。 重复第一步： 频率表 A：60 B: 45 D: 69 E: 14 FGC: 21 如图 重复第一步 频率表 A：60 B: 45 D: 69 FGCE: 35 重复第一步 频率表 A：60 D: 69 FGCEB: 80 重复第一步 频率表 AD：129 FGCEB: 80 添加 0 和 1，规则左0 右1 频率表 A：60, B:45, C:13 D:69 E:14 F:5 G:3 每个 字符 的 二进制编码 为（从根节点 数到对应的叶子节点，路径上的值拼接起来就是叶子节点字母的应该的编码） 字符 编码 A 10 B 01 C 0011 D 11 E 000 F 00101 G 00100 那么当我想传送 ABC时，编码为 10 01 0011","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hujiahao.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hujiahao.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"线性表","slug":"线性表","date":"2020-11-18T00:56:55.000Z","updated":"2020-11-18T00:56:55.000Z","comments":true,"path":"2020/11/18/线性表/","link":"","permalink":"https://hujiahao.top/2020/11/18/%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。","text":"线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。 前驱元素 若A元素在B元素的前面，则称A为B的前驱元素 后继元素 若B元素在A元素的后面，则称B为A的后继元素 线性表的特征：数据元素之间具有一种“一对一”的逻辑关系。 第一个数据元素没有前驱，这个数据元素被称为头结点； 最后一个数据元素没有后继，这个数据元素被称为尾结点； 除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。如果把线性表用数学语言来定义，则可以表示为(a1,…ai-1,ai,ai+1,…an)，ai-1领先于ai,ai领先于ai+1，称ai-1是ai的前驱元素，ai+1是ai的后继元素 线性表的分类： 线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为顺序表和链表。 顺序表 顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。 顺序表实现顺序表API设计 类名 SequenceList 构造方法 SequenceList(int capacity)：创建容量为capacity的SequenceList对象 成员方法 1.public void clear()：空置线性表 2.publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false 3.public int length():获取线性表中元素的个数 4.public T get(int i):读取并返回线性表中的第i个元素的值 5.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。 6.public void insert(T t):向线性表中添加一个元素t 7.public T remove(int i):删除并返回线性表中第i个数据元素。 8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返 回-1。 成员变 量 1.private T[] eles：存储元素的数组 2.private int N:当前线性表的长度 顺序表代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.jiahao.linear;/** * @author HuJiahao * @version 1.0 * @date 2020/11/16 20:12 */public class SequenceList&lt;T&gt; &#123; //存储元素的数组 private T[] eles; //记录当前顺序表中的元素个数 private int N; //构造方法 public SequenceList(int capacity) &#123; //初始化数组 this.eles = (T[]) new Object[capacity]; this.N = 0; &#125; //将一个线性表置为空表 public void clear() &#123; this.N = 0; &#125; //判断当前线性表是否为空 public boolean isEmpty() &#123; return N == 0; &#125; //获取线性表的元素 public int length() &#123; return N; &#125; //获取指定位置的元素 public T get(int i) &#123; return eles[i]; &#125; //向线性表中添加元素t public void insert(T t) &#123; eles[N++] = t; &#125; //在i元素处插入元素t public void insert(int i, T t) &#123; for (int index = N; index &gt; i; index--) &#123; eles[index] = eles[index - 1]; &#125; eles[i] = t; //表长度增一 N++; &#125; //删除指定位置i的元素，并返回该元素 public T remove(int i) &#123; //记录索引i处的值 T current = eles[i]; //索引i后面的元素依次向前移动一位 for(int index = i;index&lt;N-1;index++)&#123; eles[index]=eles[index+1]; &#125; N--; return current; &#125; //查找t元素第一次出现的位置 public int indexoOf(T t)&#123; for(int i=0;i&lt;N;i++)&#123; if(eles[i].equals(t))&#123; return i; &#125; &#125; return -1; &#125;&#125; 测试类： 1234567891011121314151617181920212223242526272829303132package com.jiahao.linear;/** * @author HuJiahao * @version 1.0 * @date 2020/11/18 16:48 */public class SequenceListTest &#123; public static void main(String[] args) &#123; //创建顺序表对象 SequenceList&lt;String&gt; s1 = new SequenceList&lt;&gt;(10); //测试插入 s1.insert(&quot;科比&quot;); s1.insert(&quot;詹姆斯&quot;); s1.insert(&quot;韦德&quot;); s1.insert(&quot;欧文&quot;); s1.insert(1,&quot;库里&quot;); //测试获取 String result = s1.get(4); System.out.println(&quot;获取索引1处的结果为：&quot;+result); String removeResult = s1.remove(0); System.out.println(&quot;删除的元素是：&quot;+removeResult); s1.clear(); System.out.println(&quot;清空后的线性表中的元素个数&quot;+s1.length()); &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hujiahao.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hujiahao.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"线程通信","slug":"ThreadCommunication","date":"2020-05-03T03:00:02.000Z","updated":"2020-05-03T03:00:02.000Z","comments":true,"path":"2020/05/03/ThreadCommunication/","link":"","permalink":"https://hujiahao.top/2020/05/03/ThreadCommunication/","excerpt":"","text":"涉及到的三个方法：1、 wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。2、 notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。 3、 notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 说明：1、wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。2、wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。 否则，会出现IllegalMonitorStateException异常3、wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 sleep() 和 wait()的异同？1、相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。2、不同点：1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 线程通信的例子：使用两个线程打印 1-100。线程1, 线程2 交替打印 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Number implements Runnable&#123; private int number = 1; private Object obj = new Object(); @Override public void run() &#123; while(true)&#123; synchronized (obj) &#123; obj.notify(); if(number &lt;= 100)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number); number++; try &#123; //使得调用如下wait()方法的线程进入阻塞状态 obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationTest &#123; public static void main(String[] args) &#123; Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"解决线程安全问题的方法","slug":"Thread","date":"2020-05-03T01:47:21.000Z","updated":"2020-05-03T01:47:21.000Z","comments":true,"path":"2020/05/03/Thread/","link":"","permalink":"https://hujiahao.top/2020/05/03/Thread/","excerpt":"","text":"一、同步代码块 synchronized(同步监视器){ //需要被同步的代码 } 说明: 1.操作共享数据的代码，即为需要被同步的代码。 –&gt;不能包含代码多了，也不能包含代码少了。 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。 要求：多个线程必须要共用同一把锁。 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 1、实现Runnable的方式：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Window1 implements Runnable&#123; private int ticket = 100;// Object obj = new Object();// Dog dog = new Dog(); @Override public void run() &#123;// Object obj = new Object(); while(true)&#123; synchronized (this)&#123;//此时的this:唯一的Window1的对象 //方式二：synchronized (dog) &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest1 &#123; public static void main(String[] args) &#123; Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125;class Dog&#123;&#125; 2、继承Thread的方式：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Window2 extends Thread&#123; private static int ticket = 100; private static Object obj = new Object(); @Override public void run() &#123; while(true)&#123; //正确的// synchronized (obj)&#123; synchronized (Window2.class)&#123;//Class clazz = Window2.class,Window2.class只会加载一次 //错误的方式：this代表着t1,t2,t3三个对象// synchronized (this)&#123; if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest2 &#123; public static void main(String[] args) &#123; Window2 t1 = new Window2(); Window2 t2 = new Window2(); Window2 t3 = new Window2(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 二、同步方法 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 非静态的同步方法，同步监视器是：this 静态的同步方法，同步监视器是：当前类本身 1、使用同步方法解决实现Runnable接口的线程安全问题:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Window3 implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private synchronized void show()&#123;//同步监视器：this //synchronized (this)&#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket); ticket--; &#125; //&#125; &#125;&#125;public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 w = new Window3(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 2、使用同步方法处理继承Thread类的方式中的线程安全问题:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Window4 extends Thread &#123; private static int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private static synchronized void show()&#123;//同步监视器：Window4.class //private synchronized void show()&#123; //同步监视器：t1,t2,t3。此种解决方式是错误的 if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125; &#125;&#125;public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 t1 = new Window4(); Window4 t2 = new Window4(); Window4 t3 = new Window4(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 三、Lock锁 — JDK5.0新增synchronized 与 Lock的异同？相同：二者都可以解决线程安全问题不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器 Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Window implements Runnable&#123; private int ticket = 100; //1.实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while(true)&#123; try&#123; //2.调用锁定方法lock() lock.lock(); if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;：售票，票号为：&quot; + ticket); ticket--; &#125;else&#123; break; &#125; &#125;finally &#123; //3.调用解锁方法：unlock() lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"单例设计模式","slug":"单例设计模式","date":"2020-04-15T15:37:48.000Z","updated":"2020-04-15T15:37:48.000Z","comments":true,"path":"2020/04/15/单例设计模式/","link":"","permalink":"https://hujiahao.top/2020/04/15/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。","text":"所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。 如何实现？饿汉式 和 懒汉式 区分饿汉式 和 懒汉式饿汉式：坏处：对象加载时间过长。好处：饿汉式是线程安全的 懒汉式：好处：延迟对象的创建。坏处：不加线程锁是不安全的 饿汉式：1234567891011121314151617181920212223242526272829public class SingletonTest1 &#123; public static void main(String[] args) &#123; // Bank bank1 = new Bank(); // Bank bank2 = new Bank(); Bank bank1 = Bank.getInstance(); Bank bank2 = Bank.getInstance(); System.out.println(bank1 == bank2);//true &#125;&#125;//饿汉式class Bank&#123; //1.私有化类的构造器 private Bank()&#123; &#125; //2.内部创建类的对象 //4.要求此对象也必须声明为静态的 private static Bank instance = new Bank(); //3.提供公共的静态的方法，返回类的对象 public static Bank getInstance()&#123; return instance; &#125;&#125; 懒汉式：第一种：线程不安全1234567891011121314151617181920212223242526272829303132333435public class SingletonTest2 &#123; public static void main(String[] args) &#123; Order order1 = Order.getInstance(); Order order2 = Order.getInstance(); System.out.println(order1 == order2); &#125;&#125;class Order&#123; //1.私有化类的构造器 private Order()&#123; &#125; //2.声明当前类对象，没有初始化 //4.此对象也必须声明为static的 private static Order instance = null; //3.声明public、static的返回当前类对象的方法 public static Order getInstance()&#123; if(instance == null)&#123; instance = new Order(); &#125; return instance; &#125; &#125; 第二种：线程安全123456789101112131415161718192021222324252627282930313233343536373839404142public class ThreadSingle &#123; public static void main(String[] args) &#123; Order order1 = Order.getInstance(); Order order2 = Order.getInstance(); System.out.println(order1 == order2); &#125;&#125;class Order&#123; //1.私有化类的构造器 private Order()&#123; &#125; //2.声明当前类对象，没有初始化 //4.此对象也必须声明为static的 private static Order instance = null; //3.声明public、static的返回当前类对象的方法 public static Order getInstance() &#123; if(instance==null) &#123; synchronized (Order.class) &#123; if (instance == null) &#123; instance = new Order(); &#125; &#125; &#125; return instance; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"Object类","slug":"Object类","date":"2020-04-14T14:25:43.000Z","updated":"2020-04-14T14:25:43.000Z","comments":true,"path":"2020/04/14/Object类/","link":"","permalink":"https://hujiahao.top/2020/04/14/Object%E7%B1%BB/","excerpt":"Object类是所有Java类的根父类 ,如果在类的声明中未使用extends关键字指明其父类，则默认父类 为java.lang.Object类","text":"Object类是所有Java类的根父类 ,如果在类的声明中未使用extends关键字指明其父类，则默认父类 为java.lang.Object类 Object类中的主要结构“==”和equals的区别 == 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型 就是比较内存地址 equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也 是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中 用的比较多，久而久之，形成了equals是比较值的错误观点。 具体要看自定义类里有没有重写Object的equals方法来判断。 通常情况下，重写equals方法，会比较类中的相应属性是否都相等 equal重写例子： 123456789101112131415 public boolean equals(Object o) &#123; System.out.println(&quot;equals重写&quot;); if(o==this) &#123; return true; &#125;if(o instanceof Customer) &#123; Customer cu = (Customer)o; if(cu.age==this.age&amp;&amp;cu.name.equals(this.name)) &#123; return true; &#125;else &#123; return false; &#125; &#125;else &#123; return false; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"java的三大特征","slug":"java的三大特征","date":"2020-04-14T03:02:51.000Z","updated":"2020-04-14T03:02:51.000Z","comments":true,"path":"2020/04/14/java的三大特征/","link":"","permalink":"https://hujiahao.top/2020/04/14/java%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/","excerpt":"封装性，继承性和多态性","text":"封装性，继承性和多态性 封装性 我们程序设计追求“高内聚，低耦合”。 高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉 低耦合 ：仅对外暴露少量的方法用于使用 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提 高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露 的暴露出来。这就是封装性的设计思想。 Java中通过将数据声明为私有的(private)，再提供公共的（public） 方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的： 隐藏一个类中不需要对外提供的实现细节； 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑， 限制对属性的不合理操作； 便于修改，增强代码的可维护性； 继承性 为什么要有继承？ 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中， 那么多个类无需再定义这些属性和行为，只要继承那个类即可。 此处的多个类称为子类(派生类)，单独的这个类称为父类(基类 或超类)。 类继承语法规则: class Subclass extends SuperClass{ } 继承的作用： 继承的出现减少了代码冗余，提高了代码的复用性。 继承的出现，更有利于功能的扩展。 继承的出现让类与类之间产生了关系，提供了多态的前提。 子类继承了父类，就继承了父类的方法和属性。 在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和 方法。 在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集， 而是对父类的“扩展”。 注意： 不要仅为了获取其他类中某个功能而去继承 。 子类不能直接访问父类中私有的(private)的成员变量和方法。 Java只支持单继承和多层继承，不允许多重继承 , 一个子类只能有一个父类 ， 一个父类可以派生出多个子类 12class SubDemo extends Demo&#123; &#125; //ok class SubDemo extends Demo1,Demo2...//error 继承举例： 1234567891011class Person &#123; public String name; public int age; public Date birthDate; public String getInfo() &#123; // ... &#125;&#125;class Student extends Person &#123; public String school;&#125; 多态性(向上转型) 对象的多态性：父类的引用指向子类的对象 可以直接应用在抽象类和接口上 Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明 该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简 称：编译时，看左边；运行时，看右边。 若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)多态情况下，“看左边”：看的是父类的引用(父类中不具备子类特有的方法),“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法） 对象的多态 ——— 在Java中,子类的对象可以替代父类的对象使用 一个变量只能有一种确定的数据类型 一个引用类型变量可能指向(引用)多种不同类型的对象 123Person p = new Student(); Object o = new Person();//Object类型的变量o，指向Person类型的对象 o = new Student(); //Object类型的变量o，指向Student类型的对象 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法 1234Student m = new Student();m.school = “pku”; //合法,Student类有school成员变量 Person e = new Student();e.school = “pku”; //非法,Person类没有school成员变量 属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。不能调用子类特有的方法（父类特有的方法可以调用） 多态的使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class AnimalTest &#123; public static void main(String[] args) &#123; AnimalTest animaltest = new AnimalTest(); animaltest.func(new dog()); animaltest.func(new cat()); /* * Animal animal = new dog(); * animal.eat(); * animal.shout(); */ &#125; public void func(Animal animal) &#123; animal.eat(); animal.shout(); &#125; &#125;class Animal&#123; public void eat() &#123; System.out.println(&quot;动物，进食&quot;); &#125; public void shout() &#123; System.out.println(&quot;动物，叫&quot;); &#125;&#125;class dog extends Animal&#123; public void eat() &#123; System.out.println(&quot;吃狗粮&quot;); &#125; public void shout() &#123; System.out.println(&quot;汪汪汪&quot;); &#125; //狗类特有的方法 public void play()&#123; System.out.println(&quot;玩&quot;); &#125;&#125;class cat extends Animal&#123; public void eat() &#123; System.out.println(&quot;吃老鼠&quot;); &#125; public void shout() &#123; System.out.println(&quot;喵喵喵&quot;); &#125; //猫类特有的方法 public void sleep() &#123; System.out.println(&quot;睡觉&quot;); &#125;&#125; 面试题：多态是编译时行为还是运行时行为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 //面试题：多态是编译时行为还是运行时行为？ //证明如下：class Animal &#123; protected void eat() &#123; System.out.println(&quot;animal eat food&quot;); &#125;&#125;class Cat extends Animal &#123; protected void eat() &#123; System.out.println(&quot;cat eat fish&quot;); &#125;&#125;class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;Dog eat bone&quot;); &#125;&#125;class Sheep extends Animal &#123; public void eat() &#123; System.out.println(&quot;Sheep eat grass&quot;); &#125; &#125;public class InterviewTest &#123; public static Animal getInstance(int key) &#123; switch (key) &#123; case 0: return new Cat (); case 1: return new Dog (); default: return new Sheep (); &#125; &#125; public static void main(String[] args) &#123; int key = new Random().nextInt(3); System.out.println(key); Animal animal = getInstance(key); animal.eat(); &#125;&#125; 向下转型： 如何才能调用子类特有的属性和方法？向下转型：使用强制类型转换符。 123Animal animal = new dog();dog d = (dog)animal;d.play(); 使用强转时，可能出现ClassCastException的异常。 123Animal animal = new dog();// cat d = (cat)animal;// d.sleep(); 为了防止向下转型时出现ClassCastException的异常，使用instanceof关键字 。 a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。 如果 a instanceof A返回true,则 a instanceof B也返回true，其中，类B是类A的父类。 12345678910111213141516171819202122 //instanceof的使用： Animal animal = new dog(); if(animal instanceof dog)&#123; dog d1 = (dog)animal; d1.play(); System.out.println(&quot;====狗====&quot;);&#125;if(animal instanceof cat) &#123; cat c = (cat)animal; c.sleep(); System.out.println(&quot;====猫====&quot;);&#125;if(animal instanceof Animal) &#123; System.out.println(&quot;====Animal====&quot;);&#125;if(animal instanceof Object) &#123; System.out.println(&quot;====Object====&quot;);&#125; /* 输出： ====狗==== ====Animal==== ====Object==== */","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"方法重写和重载","slug":"方法重写和重载","date":"2020-04-14T03:02:10.000Z","updated":"2020-04-14T03:02:10.000Z","comments":true,"path":"2020/04/14/方法重写和重载/","link":"","permalink":"https://hujiahao.top/2020/04/14/%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/","excerpt":"方法重写和重载的区别","text":"方法重写和重载的区别 方法的重写： 定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称 为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。 要求： 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限 子类不能重写父类中声明为private权限的方法 子类方法抛出的异常不能大于父类被重写方法的异常 注意：子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为 static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。 举例1： 1234567891011121314151617public class Person &#123; public String name; public int age; public String getInfo() &#123; return &quot;Name: &quot;+ name + &quot;\\n&quot; +&quot;age: &quot;+ age; &#125; &#125; public class Student extends Person &#123; public String school; public String getInfo() &#123; //重写方法 return &quot;Name: &quot;+ name + &quot;\\nage: &quot;+ age + &quot;\\nschool: &quot;+ school; &#125; public static void main(String args[])&#123; Student s1=new Student(); s1.name=&quot;Bob&quot;; s1.age=20; s1.school=&quot;school2&quot;; System.out.println(s1.getInfo()); //Name:Bob age:20 school:school2 &#125; &#125; 举例2： 123456789101112131415class Parent &#123; public void method1() &#123;&#125; &#125;class Child extends Parent &#123; //非法，子类中的method1()的访问权限private比被覆盖方法的访问权限public小 private void method1() &#123;&#125; &#125;public class UseBoth &#123; public static void main(String[] args) &#123; Parent p1 = new Parent(); Child c1 = new Child(); p1.method1(); c1.method1();&#125; &#125; 方法的重载:必须就有不同的参数列表；可以有不同的返回类型；可以有不同的访问修饰符；可以抛出不同的异常； 举例： 12345678 public class Demo&#123; void speak()&#123; System.out.println(&quot;重载方法&quot;); &#125; void speak(int a)&#123; System.out.println(a); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"数组基础","slug":"数组基础","date":"2020-04-05T14:27:38.000Z","updated":"2020-04-05T14:27:38.000Z","comments":true,"path":"2020/04/05/数组基础/","link":"","permalink":"https://hujiahao.top/2020/04/05/%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/","excerpt":"关于一维数组和二维数组学习笔记","text":"关于一维数组和二维数组学习笔记 一维数组的声明和初始化 静态初始化：数组的初始化和数组元素的赋值操作同时操作 12int[] ids;ids &#x3D; new int[]&#123;12,87,24,88,39&#125;; 或 int[] ids={23,25,11,8} 动态初始化：数组的初始化和数组元素的赋值操作分开进行 Sring[] name = new String[5]; 数组元素的默认初始化： 一维数组的简化内存结构： 二维数组的声明和初始化数组元素初始化值针对初始化方式一：比如：int [][] arr = new int[4][3];外层元素的初始化值为：地址值内层元素的初始化值为：与一维数组初始化情况相同 针对初始化方式二：比如：int[][] arr = new int[4][];外层元素的初始化值为：null内层元素的初始化值为：不能调用，否则报错 1234567891011121314151617public static void main(String[] args) &#123; int[][] arr&#x3D;new int[4][3]; System.out.println(arr[0]);&#x2F;&#x2F;[I@1540e19d System.out.println(arr[0][0]);&#x2F;&#x2F;0 System.out.println(arr);&#x2F;&#x2F;[[I@677327b6 System.out.println(&quot;-------------&quot;); String[][] arr2&#x3D;new String[4][2]; System.out.println(arr2[1]);&#x2F;&#x2F;[Ljava.lang.String;@14ae5a5 System.out.println(arr2[1][1]);&#x2F;&#x2F;null System.out.println(&quot;-------------&quot;); String[][] arr3&#x3D;new String[4][]; System.out.println(arr3[1]);&#x2F;&#x2F;null System.out.println(arr3[1][0]);&#x2F;&#x2F;空指针异常&#125; 二维数组的遍历123456int[][] array &#x3D; new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;for(int i&#x3D;0;i&lt;arr.length;i++)&#123; for(int j&#x3D;0;j&lt;array[i].length;j++)&#123; System.out.println(array[i][j]); &#125;&#125; 二维数组的内存解析 杨辉三角123456789101112131415 int[][] arr2 &#x3D; new int[10][];for(int i&#x3D;0;i&lt;arr2.length;i++) &#123; arr2[i]&#x3D;new int[i+1]; arr2[i][0]&#x3D;arr2[i][i]&#x3D;1; for(int j&#x3D;1;j&lt;arr2[i].length -1;j++) &#123; arr2[i][j]&#x3D;arr2[i-1][j]+arr2[i-1][j-1]; &#125;&#125;for(int i&#x3D;0;i&lt;arr2.length;i++) &#123; for(int j&#x3D;0;j&lt;arr2[i].length;j++) &#123; System.out.print(arr2[i][j]+&quot; &quot;); &#125; System.out.println();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"}]},{"title":"数组常用算法","slug":"数组","date":"2020-04-04T14:13:25.000Z","updated":"2020-04-04T14:13:25.000Z","comments":true,"path":"2020/04/04/数组/","link":"","permalink":"https://hujiahao.top/2020/04/04/%E6%95%B0%E7%BB%84/","excerpt":"数组的常用查找和排序算法","text":"数组的常用查找和排序算法 线性查找12345678910111213141516171819&#x2F;&#x2F;线性查找：String dest &#x3D; &quot;BB&quot;;dest &#x3D; &quot;CC&quot;;boolean isFlag &#x3D; true;for(int i &#x3D; 0;i &lt; arr.length;i++)&#123; if(dest.equals(arr[i]))&#123; System.out.println(&quot;找到了指定的元素，位置为：&quot; + i); isFlag &#x3D; false; break; &#125; &#125;if(isFlag)&#123; System.out.println(&quot;很遗憾，没有找到的啦！&quot;); &#125; 二分法查找123456789101112131415161718192021222324252627282930&#x2F;&#x2F;二分法查找：&#x2F;&#x2F;前提：所要查找的数组必须有序。int[] arr2 &#x3D; new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;;int dest1 &#x3D; -34;dest1 &#x3D; 35;int head &#x3D; 0;&#x2F;&#x2F;初始的首索引int end &#x3D; arr2.length - 1;&#x2F;&#x2F;初始的末索引boolean isFlag1 &#x3D; true;while(head &lt;&#x3D; end)&#123; int middle &#x3D; (head + end)&#x2F;2; if(dest1 &#x3D;&#x3D; arr2[middle])&#123; System.out.println(&quot;找到了指定的元素，位置为：&quot; + middle); isFlag1 &#x3D; false; break; &#125;else if(arr2[middle] &gt; dest1)&#123; end &#x3D; middle - 1; &#125;else&#123;&#x2F;&#x2F;arr2[middle] &lt; dest1 head &#x3D; middle + 1; &#125; &#125;if(isFlag1)&#123; System.out.println(&quot;很遗憾，没有找到的啦！&quot;);&#125; 冒泡排序1234567891011121314151617int[] arr &#x3D; new int[]&#123;43,32,76,-98,0,64,33,-21,32,99&#125;;&#x2F;&#x2F;冒泡排序for(int i &#x3D; 0;i &lt; arr.length - 1;i++)&#123; for(int j &#x3D; 0;j &lt; arr.length - 1 - i;j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; int temp &#x3D; arr[j]; arr[j] &#x3D; arr[j + 1]; arr[j + 1] &#x3D; temp; &#125; &#125; &#125; for(int i &#x3D; 0;i &lt; arr.length;i++)&#123; System.out.print(arr[i] + &quot;\\t&quot;);&#125; 快速排序(sort排序)要想对数值型数组进行快速排序， 可以使用 Arrays 类中的 sort 方法： 12int[] a &#x3D; new int[10000];Arrays.sort(a) 这个方法使用了优化的快速排序算法。快速排序算法对于大多数数据集合来说都是效率比较高的 抽彩游戏中的随机数值组合，假如抽彩是从 49 个数值中抽取 6 个，那么程序可能的输出结果为： 1234567891011121314151617181920212223242526272829 import java.util.Arrays; import java.util.Scanner; public class shuzu &#123; public static void main(String[] args) &#123; Scanner in &#x3D; new Scanner(System.in); System.out.print(&quot;你想要从多少个数里面抽? &quot;); int n &#x3D; in.nextInt(); System.out.println(&quot;你想要抽几个数？&quot;); int k &#x3D;in.nextInt(); int[] number &#x3D; new int[n]; for(int i&#x3D;0;i&lt;number.length;i++)&#123; number[i]&#x3D;i+1; &#125; int[] result &#x3D; new int[k]; for (int i&#x3D;0;i&lt;result.length;i++)&#123; int r&#x3D;(int)(Math.random()*n); result[i]&#x3D;number[r]; number[r]&#x3D;number[n-1]; n--; System.out.println(n); &#125; Arrays.sort(result); System.out.println(&quot;Bet the following combination. I&quot;); for(int r:result) System.out.println(r); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://hujiahao.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"非谓语动词","slug":"非谓语动词","date":"2020-04-02T12:15:00.000Z","updated":"2020-04-02T12:15:00.000Z","comments":true,"path":"2020/04/02/非谓语动词/","link":"","permalink":"https://hujiahao.top/2020/04/02/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/","excerpt":"总结一下非谓语动词……","text":"总结一下非谓语动词…… 主动 被动 一般式 进行式 完成式 一般式 完成式 不定式 to do to be doing to have done to be done to have been done 动名词 doing ———— having done being done having been done 现在分词 doing ———— having done being done being been done 过去分词 done ———— ———— ———— ———— 固定搭配： It is/was + 名词 + to do sth. 做某事是…… (it为形式主语，真正的主语是后面的不定式（短语）) arrange for sb to do sth. 安排某人做某事。 go on to do sth. 做完一件事后继续做另一件事。 go on doing sth. 继续做正在做的事。 have sth. done 某事被做 have sb do sth. 某人做某事 be wothy of be woth doing 动名词名主动表被动 keep sb informed of sth. 及时通知某人 practice dong sth.练习做某事 be supposed to do sth. 计划做某事 leave for 动身去 leave + 宾语 + doing 让某人或某物处于某种状态 leave + sb to do sth. 让某人去做某事 leave sb doing sth. 让某人一直做某事 leave sb + 形容词 让某人保持一种状态 allow sb to do sth 允许某人做某事 allow doing sth 允许做某事 look forward to doing sth. 期望做某事 avoid doing sth. 避免做某事 catch sb dong sth. 抓住某人正在做某事 sb. spend some money/time (in) doing sth. spend some money/some time on sth. It takes (sb.) some time to do sth. 或 sth. take (sb.) some time it cost (sb.) some money to do sth. sb pay some money for sth. only to + 不定式 表示一种出乎意料或非主关希望的结果 It’s no use (no good,no help,fun,a waste time) + doing It做形式主语，真正的主语是后面的动名词(短语) enjoy doing sth 喜欢做某事 pretend to do sth. 假装做某事 mind doing sth 介意做某事 make oneself done 使自己被(别人)。。。。。。 sb./sth. + be动词 + said/thought/reported/believed/supposed…+to do相当于 It is/was said/thought/reported/believed/supposed…+that… confess to doing sth. 承认做某事 appreciate doing sth 感激做某事 suggest doing sth 建议做某事 keep sth done 让某事被做 insist on doing sth 坚持做某事 hate to do sth. happen to do sth. astonish to do sth. 对做某事吃惊 frightened to do sth. 害怕做某事 delighted to do sth. 乐于做某事 risk doing sth. 冒险做某事 be devoted to doing sth. 专心于/致力于做某事 be/get used to doing sth.习惯于做某事 be used to do sth 被用来做某事 used to do sth 过去常常做某事 have a hard time (in) doing sth. 做某事有困难 不定式 有些动词长跟不定式做宾语。这些动词有： afford,agree,aim,arrange,ask,attempt,begin,claim,continue,decide,demand,desire,determine,expect,fail,forget,happen,hate,hesite,hope,intend,learn,like,love,manage,mean,offer,plan,prepare,pretend,promise,prove,refuse,seem,start,try,undertake,want,wish等 奇思秒记： 动词不定做宾语，期希渴欲下决心。 愿望碰巧承担起，假装安排不拒绝。 准备计划却失败，好像提供又犹豫。 企图要把目标证，爱恨要求做选择。 同意试图要忘记，声称继续要学习。 设法想要去承诺，开始询问做绝定。 动名词 以下及物动词和动词短语常用动名词作宾语，而不能用动词不定式作宾语: admit,advise,advocate,allow,appreciate,avoid,consider,delay,deny,discuss,dislike, enjoy,escape,finish,imagine,keep,mind,miss,permit,postpone,practise,prevent,quit, recall,resent,resist,risk,suggest,tolerate,can’t help(禁不住)等 奇思妙计: 愤恨讨论停止作，阻止抵抗否避开。 建议考虑坚持练，允许想象不冒险。 不禁介意保持完，承认错过心喜欢。 回忆感激又逃避，厌恶容许又延期。 即可用动名词又可用不定式 forget to do sth. 忘记要去做某事 forget doing sth. 忘记已做过某事 go on to do sth. 做完一件事后继而做另一件事 go on doing sth. 继续做一直在做的事 mean to do sth. 打算去做某事 mean doing sth. 意味着做某事 regret to do sth. 因将要去做某事而感到遗憾 regret doing sth. 因做了某事而后悔 remember to do sth. 记得要去做某事 remember doing sth. 记得曾经做过某事 stop to do sth. 停下手中的事去做其他的事 stop doing sth.停下手中正在做的事 try to do sth. 努力去做某事 try doing sth. 试着做某事 can’t help(to) do sth. 不能帮助做某事 can’t help doing sth. 禁不住做某事","categories":[{"name":"English","slug":"English","permalink":"https://hujiahao.top/categories/English/"}],"tags":[{"name":"English","slug":"English","permalink":"https://hujiahao.top/tags/English/"},{"name":"非谓语动词","slug":"非谓语动词","permalink":"https://hujiahao.top/tags/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/"}]},{"title":"Hexo+icarus基本配置","slug":"jc","date":"2020-03-29T06:35:18.000Z","updated":"2020-03-29T06:35:18.000Z","comments":true,"path":"2020/03/29/jc/","link":"","permalink":"https://hujiahao.top/2020/03/29/jc/","excerpt":"","text":"icarus这个主题比较小众，想要改什么在网上搜到的基本都是关于NexT的，对于我这种前端知识匮乏的人来说，还是有点费劲的，所以看了各种博客后，总结一下icarus的基本配置 下载icarus主题icarus官方文档地址：https://blog.zhangruipeng.me/hexo-theme-icarus/ 12主题下载地址: git clone https:&#x2F;&#x2F;github.com&#x2F;ppoffice&#x2F;hexo-theme-icarus themes&#x2F;icarus 配置主题更改站点配置文件_config.yml,将主题改为icarusHexo\\blog\\ _config.yml 1theme: icarus 打开Hexo\\blog\\themes\\icarus_config.yml配置主题内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181# Version of the Icarus theme that is currently usedversion: 2.3.0# 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中favicon: &#x2F;images&#x2F;favicons.ico# Path or URL to RSS atom.xmlrss: &#x2F;atom.xml# 显示在导航栏左侧的网站logo，同样可以自己制作logo: &#x2F;images&#x2F;gen.svg# Open Graph metadata# https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # 导航栏navbar: #菜单（显示名称：对应文件夹） menu: 主页: &#x2F; 归档: &#x2F;archives 分类: &#x2F;categories 标签: &#x2F;tags 关于: &#x2F;about # 导航栏右侧图标链接 links: My GitHub: icon: fab fa-github url: &#39;你的gityhub地址&#39;# Footer section link settingsfooter: # 页脚图标链接 links: Creative Commons: icon: fab fa-creative-commons url: &#39;https:&#x2F;&#x2F;creativecommons.org&#x2F;&#39; Attribution 4.0 International: icon: fab fa-creative-commons-by url: &#39;https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by&#x2F;4.0&#x2F;&#39; Download on GitHub: icon: fab fa-github url: &#39;http:&#x2F;&#x2F;github.com&#x2F;ppoffice&#x2F;hexo-theme-icarus&#39;# 文章显示设置article: # Code highlight theme # https:&#x2F;&#x2F;github.com&#x2F;highlightjs&#x2F;highlight.js&#x2F;tree&#x2F;master&#x2F;src&#x2F;styles #代码主题atom-one-light亮色，atom-one-dark暗色 highlight: atom-one-dark # 是否显示文章主图 thumbnail: true # 是否显示估算阅读时间 readtime: true# 搜索插件设置# http:&#x2F;&#x2F;ppoffice.github.io&#x2F;hexo-theme-icarus&#x2F;categories&#x2F;Configuration&#x2F;Search-Pluginssearch: # Name of the search plugin type: insight# 评论插件设置# http:&#x2F;&#x2F;ppoffice.github.io&#x2F;hexo-theme-icarus&#x2F;categories&#x2F;Configuration&#x2F;Comment-Pluginscomment: #可选valine，disqus（科学上网）等 # Name of the comment plugin #type: valine #app_id: 不为空 #app_key: 不为空 #notify: true #verify: true #placeholder: type: disqus shortname: 不能为空# 打赏功能# http:&#x2F;&#x2F;ppoffice.github.io&#x2F;hexo-theme-icarus&#x2F;categories&#x2F;Donation&#x2F;donate: - # 阿里巴巴支付宝 type: alipay # 二维码图片 qrcode: &#39;&#x2F;images&#x2F;honbao.PNG&#39; - # 微信 type: wechat # 二维码图片 qrcode: &#39;&#x2F;images&#x2F;yjtp.png&#39; -# 分享插件设置# http:&#x2F;&#x2F;ppoffice.github.io&#x2F;hexo-theme-icarus&#x2F;categories&#x2F;Configuration&#x2F;Share-Pluginsshare: # 插件类型，有多种，可选，自行百度 type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # 左侧边栏设置 left: # 是否不随页面滚动 # http:&#x2F;&#x2F;ppoffice.github.io&#x2F;hexo-theme-icarus&#x2F;Configuration&#x2F;Theme&#x2F;make-a-sidebar-sticky-when-page-scrolls&#x2F; sticky: false # 右侧边栏设置 right: # 是否不随页面滚动 # http:&#x2F;&#x2F;ppoffice.github.io&#x2F;hexo-theme-icarus&#x2F;Configuration&#x2F;Theme&#x2F;make-a-sidebar-sticky-when-page-scrolls&#x2F; sticky: false# 边栏小部件设置# http:&#x2F;&#x2F;ppoffice.github.io&#x2F;hexo-theme-icarus&#x2F;categories&#x2F;Widgets&#x2F;widgets: - # 个人信息 type: profile # 部件位置（左） position: left # 作者名（字符串） author: 飞鱼 # 作者身份描述（字符串） author_title: Student # 作者当前居住地 location: China,Fujian # 头像（可用本地图片或网络图片链接） avatar: &#39;&#x2F;images&#x2F;ava.png&#39; # Email address for the Gravatar to be shown in the profile widget gravatar: # 关注我的链接，可设为你的GitHub主页 follow_link: &#39;https:&#x2F;&#x2F;github.com&#x2F;yourname&#39; # 个人介绍部件底部图标社交链接 social_links: Github: icon: fab fa-github url: &#39;https:&#x2F;&#x2F;github.com&#x2F;yourname&#39; Facebook: icon: fab fa-facebook url: &#39;https:&#x2F;&#x2F;facebook.com&#39; Twitter: icon: fab fa-twitter url: &#39;https:&#x2F;&#x2F;twitter.com&#x2F;yourname&#39; RSS: icon: fas fa-rss url: &#x2F; - # Widget name type: toc # Where should the widget be placed, left or right position: left - # 分类 type: category # 位置指定 position: left - # 标签云 type: tagcloud # 位置 position: right - # 近期文章 type: recent_posts # 位置 position: left - # 归档 type: archive # Where should the widget be placed, left or right position: right - # 标签 type: tag # Where should the widget be placed, left or right position: right - # 外部链接 type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: Google: &#39;https:&#x2F;&#x2F;google.com&#39; Baidu: &#39;https:&#x2F;&#x2F;baidu.com&#39; 参考网站 https://blog.csdn.net/marvine/article/details/89816846 未完，待续。。。。。。。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hujiahao.top/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hujiahao.top/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","permalink":"https://hujiahao.top/tags/Icarus/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/categories/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://hujiahao.top/categories/SSM/"},{"name":"随笔","slug":"随笔","permalink":"https://hujiahao.top/categories/%E9%9A%8F%E7%AC%94/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hujiahao.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"English","slug":"English","permalink":"https://hujiahao.top/categories/English/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hujiahao.top/categories/Hexo/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hujiahao.top/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://hujiahao.top/tags/Spring/"},{"name":"SSM","slug":"SSM","permalink":"https://hujiahao.top/tags/SSM/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hujiahao.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"算法","slug":"算法","permalink":"https://hujiahao.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"English","slug":"English","permalink":"https://hujiahao.top/tags/English/"},{"name":"非谓语动词","slug":"非谓语动词","permalink":"https://hujiahao.top/tags/%E9%9D%9E%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hujiahao.top/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","permalink":"https://hujiahao.top/tags/Icarus/"}]}